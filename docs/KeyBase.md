# Keybase Architecture

This document details the construction of an BCP compatible keybase system. It
describes the core concepts of UserProfiles, Keyrings, and the identity types
they contain.

## Key Terms:

- UserProfile: A collection of User materials. Includes multiple `keyringEntries` associated with a UserProfile.
- Keyring: An object containing `keyringEntries`.
- keyringEntries: An array owned by the `keyring`, which houses individual `KeyringEntry`s
- keyringEntry: An object which houses ONE `SecretIdentity` and N `PublicIdentities`.
- SecretIdentity: Single Private material entry in a `KeyringEntry`, used for signing transactions and deriving `PublicIdentities`.
- PublicIdentities: Public materials collection. Contains the an array of objects related to `SecretIdentity`.
- PublicIdentity: Derived Addresses, PublicKeys, and curve data that is chain specific. Always defined via the HD specifications. Used for end user queries for balances and transaction histories.

## Feature Set:

The Keybase includes a fully featured suite of key management. This includes the
creation of new seeds, publickeys, and addresses. It also includes the usage of
a Hardware Wallet, and various cryptographic algorithms.

### Generation and Import/Export of HD Seeds

The Web4 Keybase will require the ability to generate new seeds from entropy for
a user, when needed. This can occur when a UserProfile is made, or later on
demand by the User.

### Creation of Public Keys, and Addresses

The Seeds generated by the Keybase will be used to create new public keys, and
addresses for use with blockchain technology.

### Support for secp256k1 and ed25519

These are the two "industry standard" cryptographic algorithms. Both need to be
supported to enable the greatest compatibility. Others can be supported later,
such as `zk-snarks`.

### Hardware wallets, Ledger (Others TBA)

Hardware wallet support is necessary as more users are using these devices.
Ledger will be the first device type supported by the Keybase.

### Transaction/Message operations

The Keybase will have the following features:
- Sign Transactions
- Encrypt and Decrypt Messages
- Sign and Verify Messages

### Profile and HD Seed encryption

All data entered into a profile is encrypted before it is stored on disk.
Additionally, individual entries can be encrypted by a seperate passphrase. ##

## Standards Used:

The Keybase will implement a variety of standards regarding address derivation.
These have been listed here for review.

### Hierarchical Deterministic Wallets
HD wallets will be created through this standard to yield a master publickey:privatekey pair.

- BIP32: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki

### Multi-Account Hierarchy for Deterministic Wallets
HD Wallets for chain specific support will be created through the following standards for each algorithm.

#### secp256k1
- BIP43: https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki
- BIP44: https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki

#### ed25519
- SLIP0010: https://github.com/satoshilabs/slips/blob/master/slip-0010.md

#### Both
- SLIP0044: https://github.com/satoshilabs/slips/blob/master/slip-0044.md

### HD Seed Generation:
Seed generation will be performed through the BIP39 specification for HD seeds

- BIP39: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki


# Code Architecture
The code for keyring management is broken down into logical units, each performing a specific task. The design can be visualized as follows:

```
UserProfileController (1 UserProfileController)
  |
  | > UserProfile (1 UserProfile : N Users)
      |
      | > AddressBook (1 AddressBook : 1 UserProfile)
      |   | > AddressBookEntries (1 AddressBook : N AddressBookEntries)
      |
      | > SecurityModel (1 SecurityModel : 1 UserProfile)
      |
      | > Keyring (1 Keyring : 1 UserProfile)
          |
          | > keyringEntries (1 Keyring : N KeyringEntries)
              |
              | > SecretIdentity (1 KeyringEntry : 1 SecretIdentity)
                  |
                  | > PublicIdentities (1 SecretIdentity : N PublicIdentities)
```


## UserProfileController

The `UserProfileController` houses the logic to decrypt a user profile, when provided a valid `username:password` pair.

The following functions are called by the `User`, through the `UserProfileController`

### Functions:

- CreateUser: Creates a new user in the `UserProfileController`
- LoginUser: Passes `username:password` pair to the `UserProfileController`
- DeleteUser: Requests deletion of a `UserProfile` to the `UserProfileController`
- ExportUser: Requests the plaintext export of `UserProfile` details, requires a correct `login`

### Object Definition:

```
{
  "UserProfiles": []
}
```

## UserProfile

 A `UserProfile` contains an array called `keyringEntries`, an object called
`addressBook`, and an object called `securityModel`. This is a `1:N` relation,
where `N` is each `UserProfile` created by the `UserProfileController`.

### Object Definition:
```
"UserProfile": {
  "username": "isabella",
  "label": "My Profile",
  "created": "2018-06-18T14:52:26+00:00" #  ISO 8601 compatible
  "securityModel": {
    "password": "010000000105287a343ffb315b1...",
    "timeout": 3600,
    "retries": 100
  },
  "keyring": {
    "keyringEntries": [],
  },
  "addressBook": {
    "addressBookEntries": []
  }
}
```

## addressBook

Contains a list of addresses a user has interacted with, or added for frequent use.

### Functions:
- AddContact: Adds a contact to a `AddressBook` with the specified information. EX: `chain:address:humanName`
- DeleteContact: Deletes a contact from a `AddressBook`
- GetContact: Returns the `chain:address:humanName` for use in the application.

### Object Definition:
```
"addressBook": {
  "addressBookEntries": [
    {
      "address": "0x52b96095d265a93308fcf5cb9627085f029546be8b3",
      "chain": "ETH", # Up for debate, can be coin_type instead
      "created": "2018-06-18T14:52:26+00:00" #  ISO 8601 compatible,
      "label": "Friend's Account"
    }
  ]
}
```

## Keyring

The `Keyring` is an object that houses `keyringEntries`. This Object holds all
of the `UserProfile`'s `KeyringEntries`. This is a `1:1` relation inside of a
`UserProfile`.

### Functions:
- GetKeyringEntry: Returns a requested `KeyringEntry`'s details, such as `PublicIdentities`.
- AddKeyringEntry: Adds a new `KeyringEntry`, with a specified `SecretIdentity` to the `Keyring`.
- DeleteKeyringEntry: Removes an existing `KeyringEntry` from the `KeyringEntries` array.
- ExportKeyringEntry: Exports a `KeyringEntry` in plain text

### Object Definition:
```
"keyring": {
  "keyringEntries": []
},
```

## KeyringEntry

A `KeyringEntry` contains all of the related `SecretIdentity`,
`PublicIdentities` and personality information for an associated `SecretIdentity`.

A `SecretIdentity` is only an HD Seed value (`Mnemonic Passphrase`) or a
hardware device identifier for a `Ledger`.

This is a `1:1` relation, where each `KeyringEntry` has one `SecretIdentity`.

### Functions:
- CreateSecretIdentity: Creates a `SecretIdentity`, if the `KeyRingEntry` has none.
- RenameSecretIdentity: Changes the label of the `keyringEntry`.
- DeleteSecretIdentity: Removes the `SecretIdentity` from the `keyringEntry`.
- ExportSecretIdentity: Exports the `SecretIdentity` in plain text.

### Object Definition:
```
"KeyringEntry": {
  "label": "My Account",
  "SecretIdentity": {
   "seed": "shift nature mean excess demise mule winter between swing success bitter patch",
   "type": "HD" || "hardware"
  },
  "PublicIdentities": [
    "PublicIdentity": {}
  ]
}
```

## PublicIdentities

A `PublicIdentities` are derived from `seed:curve` pairs, which are used to
create a `PublicIdentity`.

This is a `1:N` relation, where 1 is the `SecretIdentity` for which the
`PublicIdentity` is related and N are the generated `PublicIdentities`.  

### Functions:
- GetPublicIdentity: Returns `PublicIdentity` details for a specific algorithm.
- CreatePublicIdentity: Creates a `PublicIdentity` from the `SecretIdentity`.
- DeletePublicIdentity: Removes a `PublicIdentity` from `PublicIdentities`.
- ExportPublicIdentity: Exports  a `PublicIdentity` in plain text.

### Object Definition:
```
"PublicIdentities": [
  "PublicIdentity": {
    "address": "0x6806ea1d9b2eb59DAc7fdcdf28bf8d5a12AD84Bc",
    "label": "Wells Fargo",
    "publicKey": {
      "algo": ed25519,
      "data": "52b96095d265a93308fcf5cb9627085f029546be8b31eccb00bad386a92544d7"
    },
    "curve": {
      "root": "m",
      "purpose": "44'",
      "coin_type": "60'", # Defined here: https://github.com/satoshilabs/slips/blob/master/slip-0044.md
      "account": "0'",
      "change": "0'",
      "address_index": "0"
    }
  }
]
```

## Complete Object Definition

The following is what a fully initialized profile will look like. This includes one relation of each type.
```
"UserProfile": {
  "username": "isabella",
  "label": "My Profile",
  "created": "2018-06-18T14:52:26+00:00" #  ISO 8601 compatible
  "securityModel": {
    "password": "010000000105287a343ffb315b1...",
    "timeout": 3600,
    "retries": 100
  },
  "keyring": {
    "keyringEntries": [
      "KeyringEntry": {
        "SecretIdentity": {
         "label": "My Account",
         "seed": "shift nature mean excess demise mule winter between swing success bitter patch",
         "type": "HD" || "hardware"
        },
        "PublicIdentities": [
          "PublicIdentity": {
            "address": "0x6806ea1d9b2eb59DAc7fdcdf28bf8d5a12AD84Bc",
            "label": "Wells Fargo",
            "publicKey": {
              "algo": ed25519,
              "data": "52b96095d265a93308fcf5cb9627085f029546be8b31eccb00bad386a92544d7"
            },
            "curve": {
              "root": "m",
              "purpose": "44'",
              "coin_type": "60'", # Defined here: https://github.com/satoshilabs/slips/blob/master/slip-0044.md
              "account": "0'",
              "change": "0'",
              "address_index": "0"
            }
          }
        ]
      }
    ],
  },
  "addressBook": {
    "addressBookEntries": [
      {
        "address": "0x52b96095d265a93308fcf5cb9627085f029546be8b3",
        "chain": "ETH", # Up for debate, can be coin_type instead
        "created": "2018-06-18T14:52:26+00:00" #  ISO 8601 compatible,
        "label": "Friend's Account"
      }
    ]
  }
}
```

# Address Architecture

There are type main types of addresses implemented into the Keybase. These are `Universal Address` and `Extended Addresses`. The Universal address will implement the base set of features offered by BIP32. The extended addresses will implement the full suite of BIP44 features.

## Universal Address:

The BCP and BNS will both support the standard cryptography algorithms found in the majority of blockchain ecosystems. This includes `ed25519` and `secp256k1`. While these algorithms are different, we can use some key features of Bitcoin that have propogated and become standard throughout many implementations.

### Default Key Path (Purpose 0)

BIP32 describes the standard HD path specification. It reserves Purpose 0 for this purpose, below is a quote from BIP44 about this claimed position.

> Note that m / 0' / * is already taken by BIP32 (default account), which preceded this BIP.

We can use this knowledge of default account from BIP32 to establish the universal wallet independent of coin_type, which resides at Purpose 0, and coin_type 0. This can be then used to derive a public key for both support cryptographic algorithms, and provides us the highest level of compatibility, as only BIP32 is required for support.

## Extended Addresses:

In many circumstances, users will want a chain specific key that can be portable if needed. We can provide them access to these keys using the full BIP43/44 specifications.

> m / purpose' / coin_type' / account' / change / address_index

Purpose MUST follow the BIP44 specification and as such, be set to be `44'`. `coin_type` MUST be supported according to the SLIP list. This will provide the greatest compatibility, especially if a user needs to exit the system.

Users MAY use these individual chain specific addresses.

This is support is also critical for users who are importing HD seeds from other software, so that we can locate existing tokens for that user. During the import process, that user should be given a choice of supported tokens to add to the list and the software can automatically derive the addresses that are already used. In the case of many addresses, the user can use a `load more` button.

# Security Concerns

There are a few minor security concerns around Seed management and private key usage, these are addressed here.

## Persisting Seeds on Disk

Users will be forced to encrypt all HD Seeds kept on disk through their user
profile. Users will be given the option of a second layer of security by
encrypting each Seed separately.

## Private Keys Per Curve

We can reuse the same seed for each `Curve`, and derive different
publickey/private key pairs using the instructions found in SLIP-0010. This
mitigates security concerns around private key reuse. This method is how Trezor
and Ledger derive keys for different curves.

# User Stories

Below is a list of User Stories that can guide a developer on an End Users work
flow when using the Keybase.

## User Profiles

### I want to Add a Profile

Create a profile with `username`, `label`, and a `password` calling
`UserProfileController.CreateUser`.

This has an empty `addressBook` and `keyring`. The `securityModel` is
initialized from the system defaults.

### I have Profile and want to Login.

Request login using supplied `username` and `password` by calling
`UserProfileController.LoginUser`. This password needs to match against the hash
in the `UserProfile.securityModel.password`.

### I want to delete my User Profile.

Request profile deletion using supplied `username` and `password` by calling
`UserProfileController.DeleteUser`. This password needs to match against the
hash in the `UserProfile.securityModel.password`.

### I want to export my profile

Request profile export using supplied `username` and `password` by calling
`UserProfileController.DeleteUser`. This password needs to match against the
hash in the `UserProfile.securityModel.password`.

## SecretIdentity

### I don't have a `SecretIdentity` and want to Add one

Create a new a `keyringEntry` populated with a `SecretIdentity`. This
`keyringEntry` is added to the `keyringEntries` array.

## I have a `SecretIdentity` and I want to create an address

Add a `publicIdentity` to `publicIdentities` using the `SecretIdentity`.
