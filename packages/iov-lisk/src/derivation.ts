import Long from "long";

import { Address } from "@iov/bcp-types";
import { Ed25519, Ed25519Keypair, Sha256 } from "@iov/crypto";
import { Encoding } from "@iov/encoding";

/**
 * Lisk-specific passphrase to Ed25519 keypair derivation
 *
 * "passphrase" is Lisk's word for an autogenerated 12 word english BIP39 mnemonic
 * encoded as a string. Since the BIP39 property is not used for anything but validation
 * in the user interface we work with plain strings here.
 */
export async function passphraseToKeypair(passphrase: string): Promise<Ed25519Keypair> {
  const encodedPassphrase = Encoding.toUtf8(passphrase);
  const hash = new Sha256(encodedPassphrase).digest();
  const keypair = await Ed25519.makeKeypair(hash);
  return keypair;
}

export function pubkeyToAddress(pubkey: Uint8Array): Address {
  // https://github.com/prolina-foundation/snapshot-validator/blob/35621c7/src/lisk.cpp#L26
  const hash = new Sha256(pubkey).digest();
  const firstEightBytes = Array.from(hash.slice(0, 8));
  const addressString = Long.fromBytesLE(firstEightBytes, true).toString(10) + "L";
  return addressString as Address;
}

export function isValidAddress(address: string): boolean {
  return isValidAddressWithEnding(address, "L");
}

export function isValidAddressWithEnding(address: string, ending: string): boolean {
  const tail = address.slice(-ending.length);
  if (tail !== ending) {
    return false;
  }
  const addressString = address.slice(0, -ending.length);
  // parse as unsigned base 10 number and verify re-encoding matches encoding
  // this is no leading zeros, no decimals, within 0 <= addressString <= 2**64-1
  const addressNumber = Long.fromString(addressString, true, 10); // true => unsigned
  return addressNumber.toString(10) === addressString;
}
