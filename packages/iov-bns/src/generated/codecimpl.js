/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.app = (function() {

    /**
     * Namespace app.
     * @exports app
     * @namespace
     */
    var app = {};

    app.ResultSet = (function() {

        /**
         * Properties of a ResultSet.
         * @memberof app
         * @interface IResultSet
         * @property {Array.<Uint8Array>|null} [results] ResultSet results
         */

        /**
         * Constructs a new ResultSet.
         * @memberof app
         * @classdesc ResultSet contains a list of keys or values
         * @implements IResultSet
         * @constructor
         * @param {app.IResultSet=} [properties] Properties to set
         */
        function ResultSet(properties) {
            this.results = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResultSet results.
         * @member {Array.<Uint8Array>} results
         * @memberof app.ResultSet
         * @instance
         */
        ResultSet.prototype.results = $util.emptyArray;

        /**
         * Creates a new ResultSet instance using the specified properties.
         * @function create
         * @memberof app.ResultSet
         * @static
         * @param {app.IResultSet=} [properties] Properties to set
         * @returns {app.ResultSet} ResultSet instance
         */
        ResultSet.create = function create(properties) {
            return new ResultSet(properties);
        };

        /**
         * Encodes the specified ResultSet message. Does not implicitly {@link app.ResultSet.verify|verify} messages.
         * @function encode
         * @memberof app.ResultSet
         * @static
         * @param {app.IResultSet} message ResultSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.results != null && message.results.length)
                for (var i = 0; i < message.results.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.results[i]);
            return writer;
        };

        /**
         * Encodes the specified ResultSet message, length delimited. Does not implicitly {@link app.ResultSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof app.ResultSet
         * @static
         * @param {app.IResultSet} message ResultSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultSet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResultSet message from the specified reader or buffer.
         * @function decode
         * @memberof app.ResultSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {app.ResultSet} ResultSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.app.ResultSet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResultSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof app.ResultSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {app.ResultSet} ResultSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResultSet message.
         * @function verify
         * @memberof app.ResultSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResultSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (var i = 0; i < message.results.length; ++i)
                    if (!(message.results[i] && typeof message.results[i].length === "number" || $util.isString(message.results[i])))
                        return "results: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a ResultSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof app.ResultSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {app.ResultSet} ResultSet
         */
        ResultSet.fromObject = function fromObject(object) {
            if (object instanceof $root.app.ResultSet)
                return object;
            var message = new $root.app.ResultSet();
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".app.ResultSet.results: array expected");
                message.results = [];
                for (var i = 0; i < object.results.length; ++i)
                    if (typeof object.results[i] === "string")
                        $util.base64.decode(object.results[i], message.results[i] = $util.newBuffer($util.base64.length(object.results[i])), 0);
                    else if (object.results[i].length)
                        message.results[i] = object.results[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a ResultSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof app.ResultSet
         * @static
         * @param {app.ResultSet} message ResultSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResultSet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.results = [];
            if (message.results && message.results.length) {
                object.results = [];
                for (var j = 0; j < message.results.length; ++j)
                    object.results[j] = options.bytes === String ? $util.base64.encode(message.results[j], 0, message.results[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.results[j]) : message.results[j];
            }
            return object;
        };

        /**
         * Converts this ResultSet to JSON.
         * @function toJSON
         * @memberof app.ResultSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResultSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResultSet;
    })();

    app.Tx = (function() {

        /**
         * Properties of a Tx.
         * @memberof app
         * @interface ITx
         * @property {cash.IFeeInfo|null} [fees] Tx fees
         * @property {Array.<sigs.IStdSignature>|null} [signatures] Tx signatures
         * @property {Uint8Array|null} [preimage] Preimage for hashlock.
         * @property {Array.<Uint8Array>|null} [multisig] ID of a multisig contract.
         * @property {cash.ISendMsg|null} [sendMsg] Tx sendMsg
         * @property {escrow.ICreateEscrowMsg|null} [createEscrowMsg] Tx createEscrowMsg
         * @property {escrow.IReleaseEscrowMsg|null} [releaseEscrowMsg] Tx releaseEscrowMsg
         * @property {escrow.IReturnEscrowMsg|null} [returnEscrowMsg] Tx returnEscrowMsg
         * @property {escrow.IUpdateEscrowPartiesMsg|null} [updateEscrowMsg] Tx updateEscrowMsg
         * @property {multisig.ICreateContractMsg|null} [createContractMsg] Tx createContractMsg
         * @property {multisig.IUpdateContractMsg|null} [updateContractMsg] Tx updateContractMsg
         * @property {validators.ISetValidatorsMsg|null} [setValidatorsMsg] Tx setValidatorsMsg
         * @property {currency.INewTokenInfoMsg|null} [newTokenInfoMsg] Tx newTokenInfoMsg
         * @property {nft.IAddApprovalMsg|null} [addApprovalMsg] BatchMsg batch_msg = 60;
         * @property {nft.IRemoveApprovalMsg|null} [removeApprovalMsg] Tx removeApprovalMsg
         * @property {username.IIssueTokenMsg|null} [issueUsernameNftMsg] Tx issueUsernameNftMsg
         * @property {username.IAddChainAddressMsg|null} [addUsernameAddressNftMsg] Tx addUsernameAddressNftMsg
         * @property {username.IRemoveChainAddressMsg|null} [removeUsernameAddressMsg] Tx removeUsernameAddressMsg
         * @property {distribution.INewRevenueMsg|null} [newRevenueMsg] Tx newRevenueMsg
         * @property {distribution.IDistributeMsg|null} [distributeMsg] Tx distributeMsg
         * @property {distribution.IResetRevenueMsg|null} [resetRevenueMsg] Tx resetRevenueMsg
         * @property {migration.IUpgradeSchemaMsg|null} [upgradeSchemaMsg] Tx upgradeSchemaMsg
         * @property {aswap.ICreateSwapMsg|null} [createSwapMsg] Tx createSwapMsg
         * @property {aswap.IReleaseSwapMsg|null} [releaseSwapMsg] Tx releaseSwapMsg
         * @property {aswap.IReturnSwapMsg|null} [returnSwapMsg] Tx returnSwapMsg
         */

        /**
         * Constructs a new Tx.
         * @memberof app
         * @classdesc clarity).
         * @implements ITx
         * @constructor
         * @param {app.ITx=} [properties] Properties to set
         */
        function Tx(properties) {
            this.signatures = [];
            this.multisig = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Tx fees.
         * @member {cash.IFeeInfo|null|undefined} fees
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.fees = null;

        /**
         * Tx signatures.
         * @member {Array.<sigs.IStdSignature>} signatures
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.signatures = $util.emptyArray;

        /**
         * Preimage for hashlock.
         * @member {Uint8Array} preimage
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.preimage = $util.newBuffer([]);

        /**
         * ID of a multisig contract.
         * @member {Array.<Uint8Array>} multisig
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.multisig = $util.emptyArray;

        /**
         * Tx sendMsg.
         * @member {cash.ISendMsg|null|undefined} sendMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.sendMsg = null;

        /**
         * Tx createEscrowMsg.
         * @member {escrow.ICreateEscrowMsg|null|undefined} createEscrowMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.createEscrowMsg = null;

        /**
         * Tx releaseEscrowMsg.
         * @member {escrow.IReleaseEscrowMsg|null|undefined} releaseEscrowMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.releaseEscrowMsg = null;

        /**
         * Tx returnEscrowMsg.
         * @member {escrow.IReturnEscrowMsg|null|undefined} returnEscrowMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.returnEscrowMsg = null;

        /**
         * Tx updateEscrowMsg.
         * @member {escrow.IUpdateEscrowPartiesMsg|null|undefined} updateEscrowMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.updateEscrowMsg = null;

        /**
         * Tx createContractMsg.
         * @member {multisig.ICreateContractMsg|null|undefined} createContractMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.createContractMsg = null;

        /**
         * Tx updateContractMsg.
         * @member {multisig.IUpdateContractMsg|null|undefined} updateContractMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.updateContractMsg = null;

        /**
         * Tx setValidatorsMsg.
         * @member {validators.ISetValidatorsMsg|null|undefined} setValidatorsMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.setValidatorsMsg = null;

        /**
         * Tx newTokenInfoMsg.
         * @member {currency.INewTokenInfoMsg|null|undefined} newTokenInfoMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.newTokenInfoMsg = null;

        /**
         * BatchMsg batch_msg = 60;
         * @member {nft.IAddApprovalMsg|null|undefined} addApprovalMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.addApprovalMsg = null;

        /**
         * Tx removeApprovalMsg.
         * @member {nft.IRemoveApprovalMsg|null|undefined} removeApprovalMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.removeApprovalMsg = null;

        /**
         * Tx issueUsernameNftMsg.
         * @member {username.IIssueTokenMsg|null|undefined} issueUsernameNftMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.issueUsernameNftMsg = null;

        /**
         * Tx addUsernameAddressNftMsg.
         * @member {username.IAddChainAddressMsg|null|undefined} addUsernameAddressNftMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.addUsernameAddressNftMsg = null;

        /**
         * Tx removeUsernameAddressMsg.
         * @member {username.IRemoveChainAddressMsg|null|undefined} removeUsernameAddressMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.removeUsernameAddressMsg = null;

        /**
         * Tx newRevenueMsg.
         * @member {distribution.INewRevenueMsg|null|undefined} newRevenueMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.newRevenueMsg = null;

        /**
         * Tx distributeMsg.
         * @member {distribution.IDistributeMsg|null|undefined} distributeMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.distributeMsg = null;

        /**
         * Tx resetRevenueMsg.
         * @member {distribution.IResetRevenueMsg|null|undefined} resetRevenueMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.resetRevenueMsg = null;

        /**
         * Tx upgradeSchemaMsg.
         * @member {migration.IUpgradeSchemaMsg|null|undefined} upgradeSchemaMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.upgradeSchemaMsg = null;

        /**
         * Tx createSwapMsg.
         * @member {aswap.ICreateSwapMsg|null|undefined} createSwapMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.createSwapMsg = null;

        /**
         * Tx releaseSwapMsg.
         * @member {aswap.IReleaseSwapMsg|null|undefined} releaseSwapMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.releaseSwapMsg = null;

        /**
         * Tx returnSwapMsg.
         * @member {aswap.IReturnSwapMsg|null|undefined} returnSwapMsg
         * @memberof app.Tx
         * @instance
         */
        Tx.prototype.returnSwapMsg = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * msg is a sum type over all allowed messages on this chain.
         * @member {"sendMsg"|"createEscrowMsg"|"releaseEscrowMsg"|"returnEscrowMsg"|"updateEscrowMsg"|"createContractMsg"|"updateContractMsg"|"setValidatorsMsg"|"newTokenInfoMsg"|"addApprovalMsg"|"removeApprovalMsg"|"issueUsernameNftMsg"|"addUsernameAddressNftMsg"|"removeUsernameAddressMsg"|"newRevenueMsg"|"distributeMsg"|"resetRevenueMsg"|"upgradeSchemaMsg"|"createSwapMsg"|"releaseSwapMsg"|"returnSwapMsg"|undefined} sum
         * @memberof app.Tx
         * @instance
         */
        Object.defineProperty(Tx.prototype, "sum", {
            get: $util.oneOfGetter($oneOfFields = ["sendMsg", "createEscrowMsg", "releaseEscrowMsg", "returnEscrowMsg", "updateEscrowMsg", "createContractMsg", "updateContractMsg", "setValidatorsMsg", "newTokenInfoMsg", "addApprovalMsg", "removeApprovalMsg", "issueUsernameNftMsg", "addUsernameAddressNftMsg", "removeUsernameAddressMsg", "newRevenueMsg", "distributeMsg", "resetRevenueMsg", "upgradeSchemaMsg", "createSwapMsg", "releaseSwapMsg", "returnSwapMsg"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Tx instance using the specified properties.
         * @function create
         * @memberof app.Tx
         * @static
         * @param {app.ITx=} [properties] Properties to set
         * @returns {app.Tx} Tx instance
         */
        Tx.create = function create(properties) {
            return new Tx(properties);
        };

        /**
         * Encodes the specified Tx message. Does not implicitly {@link app.Tx.verify|verify} messages.
         * @function encode
         * @memberof app.Tx
         * @static
         * @param {app.ITx} message Tx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tx.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fees != null && message.hasOwnProperty("fees"))
                $root.cash.FeeInfo.encode(message.fees, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signatures != null && message.signatures.length)
                for (var i = 0; i < message.signatures.length; ++i)
                    $root.sigs.StdSignature.encode(message.signatures[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.preimage);
            if (message.multisig != null && message.multisig.length)
                for (var i = 0; i < message.multisig.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.multisig[i]);
            if (message.sendMsg != null && message.hasOwnProperty("sendMsg"))
                $root.cash.SendMsg.encode(message.sendMsg, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            if (message.createEscrowMsg != null && message.hasOwnProperty("createEscrowMsg"))
                $root.escrow.CreateEscrowMsg.encode(message.createEscrowMsg, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
            if (message.releaseEscrowMsg != null && message.hasOwnProperty("releaseEscrowMsg"))
                $root.escrow.ReleaseEscrowMsg.encode(message.releaseEscrowMsg, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
            if (message.returnEscrowMsg != null && message.hasOwnProperty("returnEscrowMsg"))
                $root.escrow.ReturnEscrowMsg.encode(message.returnEscrowMsg, writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
            if (message.updateEscrowMsg != null && message.hasOwnProperty("updateEscrowMsg"))
                $root.escrow.UpdateEscrowPartiesMsg.encode(message.updateEscrowMsg, writer.uint32(/* id 55, wireType 2 =*/442).fork()).ldelim();
            if (message.createContractMsg != null && message.hasOwnProperty("createContractMsg"))
                $root.multisig.CreateContractMsg.encode(message.createContractMsg, writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
            if (message.updateContractMsg != null && message.hasOwnProperty("updateContractMsg"))
                $root.multisig.UpdateContractMsg.encode(message.updateContractMsg, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
            if (message.setValidatorsMsg != null && message.hasOwnProperty("setValidatorsMsg"))
                $root.validators.SetValidatorsMsg.encode(message.setValidatorsMsg, writer.uint32(/* id 58, wireType 2 =*/466).fork()).ldelim();
            if (message.newTokenInfoMsg != null && message.hasOwnProperty("newTokenInfoMsg"))
                $root.currency.NewTokenInfoMsg.encode(message.newTokenInfoMsg, writer.uint32(/* id 59, wireType 2 =*/474).fork()).ldelim();
            if (message.addApprovalMsg != null && message.hasOwnProperty("addApprovalMsg"))
                $root.nft.AddApprovalMsg.encode(message.addApprovalMsg, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
            if (message.removeApprovalMsg != null && message.hasOwnProperty("removeApprovalMsg"))
                $root.nft.RemoveApprovalMsg.encode(message.removeApprovalMsg, writer.uint32(/* id 62, wireType 2 =*/498).fork()).ldelim();
            if (message.issueUsernameNftMsg != null && message.hasOwnProperty("issueUsernameNftMsg"))
                $root.username.IssueTokenMsg.encode(message.issueUsernameNftMsg, writer.uint32(/* id 63, wireType 2 =*/506).fork()).ldelim();
            if (message.addUsernameAddressNftMsg != null && message.hasOwnProperty("addUsernameAddressNftMsg"))
                $root.username.AddChainAddressMsg.encode(message.addUsernameAddressNftMsg, writer.uint32(/* id 64, wireType 2 =*/514).fork()).ldelim();
            if (message.removeUsernameAddressMsg != null && message.hasOwnProperty("removeUsernameAddressMsg"))
                $root.username.RemoveChainAddressMsg.encode(message.removeUsernameAddressMsg, writer.uint32(/* id 65, wireType 2 =*/522).fork()).ldelim();
            if (message.newRevenueMsg != null && message.hasOwnProperty("newRevenueMsg"))
                $root.distribution.NewRevenueMsg.encode(message.newRevenueMsg, writer.uint32(/* id 66, wireType 2 =*/530).fork()).ldelim();
            if (message.distributeMsg != null && message.hasOwnProperty("distributeMsg"))
                $root.distribution.DistributeMsg.encode(message.distributeMsg, writer.uint32(/* id 67, wireType 2 =*/538).fork()).ldelim();
            if (message.resetRevenueMsg != null && message.hasOwnProperty("resetRevenueMsg"))
                $root.distribution.ResetRevenueMsg.encode(message.resetRevenueMsg, writer.uint32(/* id 68, wireType 2 =*/546).fork()).ldelim();
            if (message.upgradeSchemaMsg != null && message.hasOwnProperty("upgradeSchemaMsg"))
                $root.migration.UpgradeSchemaMsg.encode(message.upgradeSchemaMsg, writer.uint32(/* id 69, wireType 2 =*/554).fork()).ldelim();
            if (message.createSwapMsg != null && message.hasOwnProperty("createSwapMsg"))
                $root.aswap.CreateSwapMsg.encode(message.createSwapMsg, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
            if (message.releaseSwapMsg != null && message.hasOwnProperty("releaseSwapMsg"))
                $root.aswap.ReleaseSwapMsg.encode(message.releaseSwapMsg, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
            if (message.returnSwapMsg != null && message.hasOwnProperty("returnSwapMsg"))
                $root.aswap.ReturnSwapMsg.encode(message.returnSwapMsg, writer.uint32(/* id 72, wireType 2 =*/578).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Tx message, length delimited. Does not implicitly {@link app.Tx.verify|verify} messages.
         * @function encodeDelimited
         * @memberof app.Tx
         * @static
         * @param {app.ITx} message Tx message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Tx.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Tx message from the specified reader or buffer.
         * @function decode
         * @memberof app.Tx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {app.Tx} Tx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tx.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.app.Tx();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fees = $root.cash.FeeInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.signatures && message.signatures.length))
                        message.signatures = [];
                    message.signatures.push($root.sigs.StdSignature.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.preimage = reader.bytes();
                    break;
                case 4:
                    if (!(message.multisig && message.multisig.length))
                        message.multisig = [];
                    message.multisig.push(reader.bytes());
                    break;
                case 51:
                    message.sendMsg = $root.cash.SendMsg.decode(reader, reader.uint32());
                    break;
                case 52:
                    message.createEscrowMsg = $root.escrow.CreateEscrowMsg.decode(reader, reader.uint32());
                    break;
                case 53:
                    message.releaseEscrowMsg = $root.escrow.ReleaseEscrowMsg.decode(reader, reader.uint32());
                    break;
                case 54:
                    message.returnEscrowMsg = $root.escrow.ReturnEscrowMsg.decode(reader, reader.uint32());
                    break;
                case 55:
                    message.updateEscrowMsg = $root.escrow.UpdateEscrowPartiesMsg.decode(reader, reader.uint32());
                    break;
                case 56:
                    message.createContractMsg = $root.multisig.CreateContractMsg.decode(reader, reader.uint32());
                    break;
                case 57:
                    message.updateContractMsg = $root.multisig.UpdateContractMsg.decode(reader, reader.uint32());
                    break;
                case 58:
                    message.setValidatorsMsg = $root.validators.SetValidatorsMsg.decode(reader, reader.uint32());
                    break;
                case 59:
                    message.newTokenInfoMsg = $root.currency.NewTokenInfoMsg.decode(reader, reader.uint32());
                    break;
                case 61:
                    message.addApprovalMsg = $root.nft.AddApprovalMsg.decode(reader, reader.uint32());
                    break;
                case 62:
                    message.removeApprovalMsg = $root.nft.RemoveApprovalMsg.decode(reader, reader.uint32());
                    break;
                case 63:
                    message.issueUsernameNftMsg = $root.username.IssueTokenMsg.decode(reader, reader.uint32());
                    break;
                case 64:
                    message.addUsernameAddressNftMsg = $root.username.AddChainAddressMsg.decode(reader, reader.uint32());
                    break;
                case 65:
                    message.removeUsernameAddressMsg = $root.username.RemoveChainAddressMsg.decode(reader, reader.uint32());
                    break;
                case 66:
                    message.newRevenueMsg = $root.distribution.NewRevenueMsg.decode(reader, reader.uint32());
                    break;
                case 67:
                    message.distributeMsg = $root.distribution.DistributeMsg.decode(reader, reader.uint32());
                    break;
                case 68:
                    message.resetRevenueMsg = $root.distribution.ResetRevenueMsg.decode(reader, reader.uint32());
                    break;
                case 69:
                    message.upgradeSchemaMsg = $root.migration.UpgradeSchemaMsg.decode(reader, reader.uint32());
                    break;
                case 70:
                    message.createSwapMsg = $root.aswap.CreateSwapMsg.decode(reader, reader.uint32());
                    break;
                case 71:
                    message.releaseSwapMsg = $root.aswap.ReleaseSwapMsg.decode(reader, reader.uint32());
                    break;
                case 72:
                    message.returnSwapMsg = $root.aswap.ReturnSwapMsg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Tx message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof app.Tx
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {app.Tx} Tx
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Tx.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Tx message.
         * @function verify
         * @memberof app.Tx
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Tx.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.fees != null && message.hasOwnProperty("fees")) {
                var error = $root.cash.FeeInfo.verify(message.fees);
                if (error)
                    return "fees." + error;
            }
            if (message.signatures != null && message.hasOwnProperty("signatures")) {
                if (!Array.isArray(message.signatures))
                    return "signatures: array expected";
                for (var i = 0; i < message.signatures.length; ++i) {
                    var error = $root.sigs.StdSignature.verify(message.signatures[i]);
                    if (error)
                        return "signatures." + error;
                }
            }
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                if (!(message.preimage && typeof message.preimage.length === "number" || $util.isString(message.preimage)))
                    return "preimage: buffer expected";
            if (message.multisig != null && message.hasOwnProperty("multisig")) {
                if (!Array.isArray(message.multisig))
                    return "multisig: array expected";
                for (var i = 0; i < message.multisig.length; ++i)
                    if (!(message.multisig[i] && typeof message.multisig[i].length === "number" || $util.isString(message.multisig[i])))
                        return "multisig: buffer[] expected";
            }
            if (message.sendMsg != null && message.hasOwnProperty("sendMsg")) {
                properties.sum = 1;
                {
                    var error = $root.cash.SendMsg.verify(message.sendMsg);
                    if (error)
                        return "sendMsg." + error;
                }
            }
            if (message.createEscrowMsg != null && message.hasOwnProperty("createEscrowMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.escrow.CreateEscrowMsg.verify(message.createEscrowMsg);
                    if (error)
                        return "createEscrowMsg." + error;
                }
            }
            if (message.releaseEscrowMsg != null && message.hasOwnProperty("releaseEscrowMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.escrow.ReleaseEscrowMsg.verify(message.releaseEscrowMsg);
                    if (error)
                        return "releaseEscrowMsg." + error;
                }
            }
            if (message.returnEscrowMsg != null && message.hasOwnProperty("returnEscrowMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.escrow.ReturnEscrowMsg.verify(message.returnEscrowMsg);
                    if (error)
                        return "returnEscrowMsg." + error;
                }
            }
            if (message.updateEscrowMsg != null && message.hasOwnProperty("updateEscrowMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.escrow.UpdateEscrowPartiesMsg.verify(message.updateEscrowMsg);
                    if (error)
                        return "updateEscrowMsg." + error;
                }
            }
            if (message.createContractMsg != null && message.hasOwnProperty("createContractMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.multisig.CreateContractMsg.verify(message.createContractMsg);
                    if (error)
                        return "createContractMsg." + error;
                }
            }
            if (message.updateContractMsg != null && message.hasOwnProperty("updateContractMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.multisig.UpdateContractMsg.verify(message.updateContractMsg);
                    if (error)
                        return "updateContractMsg." + error;
                }
            }
            if (message.setValidatorsMsg != null && message.hasOwnProperty("setValidatorsMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.validators.SetValidatorsMsg.verify(message.setValidatorsMsg);
                    if (error)
                        return "setValidatorsMsg." + error;
                }
            }
            if (message.newTokenInfoMsg != null && message.hasOwnProperty("newTokenInfoMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.currency.NewTokenInfoMsg.verify(message.newTokenInfoMsg);
                    if (error)
                        return "newTokenInfoMsg." + error;
                }
            }
            if (message.addApprovalMsg != null && message.hasOwnProperty("addApprovalMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.nft.AddApprovalMsg.verify(message.addApprovalMsg);
                    if (error)
                        return "addApprovalMsg." + error;
                }
            }
            if (message.removeApprovalMsg != null && message.hasOwnProperty("removeApprovalMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.nft.RemoveApprovalMsg.verify(message.removeApprovalMsg);
                    if (error)
                        return "removeApprovalMsg." + error;
                }
            }
            if (message.issueUsernameNftMsg != null && message.hasOwnProperty("issueUsernameNftMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.username.IssueTokenMsg.verify(message.issueUsernameNftMsg);
                    if (error)
                        return "issueUsernameNftMsg." + error;
                }
            }
            if (message.addUsernameAddressNftMsg != null && message.hasOwnProperty("addUsernameAddressNftMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.username.AddChainAddressMsg.verify(message.addUsernameAddressNftMsg);
                    if (error)
                        return "addUsernameAddressNftMsg." + error;
                }
            }
            if (message.removeUsernameAddressMsg != null && message.hasOwnProperty("removeUsernameAddressMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.username.RemoveChainAddressMsg.verify(message.removeUsernameAddressMsg);
                    if (error)
                        return "removeUsernameAddressMsg." + error;
                }
            }
            if (message.newRevenueMsg != null && message.hasOwnProperty("newRevenueMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.distribution.NewRevenueMsg.verify(message.newRevenueMsg);
                    if (error)
                        return "newRevenueMsg." + error;
                }
            }
            if (message.distributeMsg != null && message.hasOwnProperty("distributeMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.distribution.DistributeMsg.verify(message.distributeMsg);
                    if (error)
                        return "distributeMsg." + error;
                }
            }
            if (message.resetRevenueMsg != null && message.hasOwnProperty("resetRevenueMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.distribution.ResetRevenueMsg.verify(message.resetRevenueMsg);
                    if (error)
                        return "resetRevenueMsg." + error;
                }
            }
            if (message.upgradeSchemaMsg != null && message.hasOwnProperty("upgradeSchemaMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.migration.UpgradeSchemaMsg.verify(message.upgradeSchemaMsg);
                    if (error)
                        return "upgradeSchemaMsg." + error;
                }
            }
            if (message.createSwapMsg != null && message.hasOwnProperty("createSwapMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.aswap.CreateSwapMsg.verify(message.createSwapMsg);
                    if (error)
                        return "createSwapMsg." + error;
                }
            }
            if (message.releaseSwapMsg != null && message.hasOwnProperty("releaseSwapMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.aswap.ReleaseSwapMsg.verify(message.releaseSwapMsg);
                    if (error)
                        return "releaseSwapMsg." + error;
                }
            }
            if (message.returnSwapMsg != null && message.hasOwnProperty("returnSwapMsg")) {
                if (properties.sum === 1)
                    return "sum: multiple values";
                properties.sum = 1;
                {
                    var error = $root.aswap.ReturnSwapMsg.verify(message.returnSwapMsg);
                    if (error)
                        return "returnSwapMsg." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Tx message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof app.Tx
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {app.Tx} Tx
         */
        Tx.fromObject = function fromObject(object) {
            if (object instanceof $root.app.Tx)
                return object;
            var message = new $root.app.Tx();
            if (object.fees != null) {
                if (typeof object.fees !== "object")
                    throw TypeError(".app.Tx.fees: object expected");
                message.fees = $root.cash.FeeInfo.fromObject(object.fees);
            }
            if (object.signatures) {
                if (!Array.isArray(object.signatures))
                    throw TypeError(".app.Tx.signatures: array expected");
                message.signatures = [];
                for (var i = 0; i < object.signatures.length; ++i) {
                    if (typeof object.signatures[i] !== "object")
                        throw TypeError(".app.Tx.signatures: object expected");
                    message.signatures[i] = $root.sigs.StdSignature.fromObject(object.signatures[i]);
                }
            }
            if (object.preimage != null)
                if (typeof object.preimage === "string")
                    $util.base64.decode(object.preimage, message.preimage = $util.newBuffer($util.base64.length(object.preimage)), 0);
                else if (object.preimage.length)
                    message.preimage = object.preimage;
            if (object.multisig) {
                if (!Array.isArray(object.multisig))
                    throw TypeError(".app.Tx.multisig: array expected");
                message.multisig = [];
                for (var i = 0; i < object.multisig.length; ++i)
                    if (typeof object.multisig[i] === "string")
                        $util.base64.decode(object.multisig[i], message.multisig[i] = $util.newBuffer($util.base64.length(object.multisig[i])), 0);
                    else if (object.multisig[i].length)
                        message.multisig[i] = object.multisig[i];
            }
            if (object.sendMsg != null) {
                if (typeof object.sendMsg !== "object")
                    throw TypeError(".app.Tx.sendMsg: object expected");
                message.sendMsg = $root.cash.SendMsg.fromObject(object.sendMsg);
            }
            if (object.createEscrowMsg != null) {
                if (typeof object.createEscrowMsg !== "object")
                    throw TypeError(".app.Tx.createEscrowMsg: object expected");
                message.createEscrowMsg = $root.escrow.CreateEscrowMsg.fromObject(object.createEscrowMsg);
            }
            if (object.releaseEscrowMsg != null) {
                if (typeof object.releaseEscrowMsg !== "object")
                    throw TypeError(".app.Tx.releaseEscrowMsg: object expected");
                message.releaseEscrowMsg = $root.escrow.ReleaseEscrowMsg.fromObject(object.releaseEscrowMsg);
            }
            if (object.returnEscrowMsg != null) {
                if (typeof object.returnEscrowMsg !== "object")
                    throw TypeError(".app.Tx.returnEscrowMsg: object expected");
                message.returnEscrowMsg = $root.escrow.ReturnEscrowMsg.fromObject(object.returnEscrowMsg);
            }
            if (object.updateEscrowMsg != null) {
                if (typeof object.updateEscrowMsg !== "object")
                    throw TypeError(".app.Tx.updateEscrowMsg: object expected");
                message.updateEscrowMsg = $root.escrow.UpdateEscrowPartiesMsg.fromObject(object.updateEscrowMsg);
            }
            if (object.createContractMsg != null) {
                if (typeof object.createContractMsg !== "object")
                    throw TypeError(".app.Tx.createContractMsg: object expected");
                message.createContractMsg = $root.multisig.CreateContractMsg.fromObject(object.createContractMsg);
            }
            if (object.updateContractMsg != null) {
                if (typeof object.updateContractMsg !== "object")
                    throw TypeError(".app.Tx.updateContractMsg: object expected");
                message.updateContractMsg = $root.multisig.UpdateContractMsg.fromObject(object.updateContractMsg);
            }
            if (object.setValidatorsMsg != null) {
                if (typeof object.setValidatorsMsg !== "object")
                    throw TypeError(".app.Tx.setValidatorsMsg: object expected");
                message.setValidatorsMsg = $root.validators.SetValidatorsMsg.fromObject(object.setValidatorsMsg);
            }
            if (object.newTokenInfoMsg != null) {
                if (typeof object.newTokenInfoMsg !== "object")
                    throw TypeError(".app.Tx.newTokenInfoMsg: object expected");
                message.newTokenInfoMsg = $root.currency.NewTokenInfoMsg.fromObject(object.newTokenInfoMsg);
            }
            if (object.addApprovalMsg != null) {
                if (typeof object.addApprovalMsg !== "object")
                    throw TypeError(".app.Tx.addApprovalMsg: object expected");
                message.addApprovalMsg = $root.nft.AddApprovalMsg.fromObject(object.addApprovalMsg);
            }
            if (object.removeApprovalMsg != null) {
                if (typeof object.removeApprovalMsg !== "object")
                    throw TypeError(".app.Tx.removeApprovalMsg: object expected");
                message.removeApprovalMsg = $root.nft.RemoveApprovalMsg.fromObject(object.removeApprovalMsg);
            }
            if (object.issueUsernameNftMsg != null) {
                if (typeof object.issueUsernameNftMsg !== "object")
                    throw TypeError(".app.Tx.issueUsernameNftMsg: object expected");
                message.issueUsernameNftMsg = $root.username.IssueTokenMsg.fromObject(object.issueUsernameNftMsg);
            }
            if (object.addUsernameAddressNftMsg != null) {
                if (typeof object.addUsernameAddressNftMsg !== "object")
                    throw TypeError(".app.Tx.addUsernameAddressNftMsg: object expected");
                message.addUsernameAddressNftMsg = $root.username.AddChainAddressMsg.fromObject(object.addUsernameAddressNftMsg);
            }
            if (object.removeUsernameAddressMsg != null) {
                if (typeof object.removeUsernameAddressMsg !== "object")
                    throw TypeError(".app.Tx.removeUsernameAddressMsg: object expected");
                message.removeUsernameAddressMsg = $root.username.RemoveChainAddressMsg.fromObject(object.removeUsernameAddressMsg);
            }
            if (object.newRevenueMsg != null) {
                if (typeof object.newRevenueMsg !== "object")
                    throw TypeError(".app.Tx.newRevenueMsg: object expected");
                message.newRevenueMsg = $root.distribution.NewRevenueMsg.fromObject(object.newRevenueMsg);
            }
            if (object.distributeMsg != null) {
                if (typeof object.distributeMsg !== "object")
                    throw TypeError(".app.Tx.distributeMsg: object expected");
                message.distributeMsg = $root.distribution.DistributeMsg.fromObject(object.distributeMsg);
            }
            if (object.resetRevenueMsg != null) {
                if (typeof object.resetRevenueMsg !== "object")
                    throw TypeError(".app.Tx.resetRevenueMsg: object expected");
                message.resetRevenueMsg = $root.distribution.ResetRevenueMsg.fromObject(object.resetRevenueMsg);
            }
            if (object.upgradeSchemaMsg != null) {
                if (typeof object.upgradeSchemaMsg !== "object")
                    throw TypeError(".app.Tx.upgradeSchemaMsg: object expected");
                message.upgradeSchemaMsg = $root.migration.UpgradeSchemaMsg.fromObject(object.upgradeSchemaMsg);
            }
            if (object.createSwapMsg != null) {
                if (typeof object.createSwapMsg !== "object")
                    throw TypeError(".app.Tx.createSwapMsg: object expected");
                message.createSwapMsg = $root.aswap.CreateSwapMsg.fromObject(object.createSwapMsg);
            }
            if (object.releaseSwapMsg != null) {
                if (typeof object.releaseSwapMsg !== "object")
                    throw TypeError(".app.Tx.releaseSwapMsg: object expected");
                message.releaseSwapMsg = $root.aswap.ReleaseSwapMsg.fromObject(object.releaseSwapMsg);
            }
            if (object.returnSwapMsg != null) {
                if (typeof object.returnSwapMsg !== "object")
                    throw TypeError(".app.Tx.returnSwapMsg: object expected");
                message.returnSwapMsg = $root.aswap.ReturnSwapMsg.fromObject(object.returnSwapMsg);
            }
            return message;
        };

        /**
         * Creates a plain object from a Tx message. Also converts values to other types if specified.
         * @function toObject
         * @memberof app.Tx
         * @static
         * @param {app.Tx} message Tx
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Tx.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.signatures = [];
                object.multisig = [];
            }
            if (options.defaults) {
                object.fees = null;
                if (options.bytes === String)
                    object.preimage = "";
                else {
                    object.preimage = [];
                    if (options.bytes !== Array)
                        object.preimage = $util.newBuffer(object.preimage);
                }
            }
            if (message.fees != null && message.hasOwnProperty("fees"))
                object.fees = $root.cash.FeeInfo.toObject(message.fees, options);
            if (message.signatures && message.signatures.length) {
                object.signatures = [];
                for (var j = 0; j < message.signatures.length; ++j)
                    object.signatures[j] = $root.sigs.StdSignature.toObject(message.signatures[j], options);
            }
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                object.preimage = options.bytes === String ? $util.base64.encode(message.preimage, 0, message.preimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.preimage) : message.preimage;
            if (message.multisig && message.multisig.length) {
                object.multisig = [];
                for (var j = 0; j < message.multisig.length; ++j)
                    object.multisig[j] = options.bytes === String ? $util.base64.encode(message.multisig[j], 0, message.multisig[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.multisig[j]) : message.multisig[j];
            }
            if (message.sendMsg != null && message.hasOwnProperty("sendMsg")) {
                object.sendMsg = $root.cash.SendMsg.toObject(message.sendMsg, options);
                if (options.oneofs)
                    object.sum = "sendMsg";
            }
            if (message.createEscrowMsg != null && message.hasOwnProperty("createEscrowMsg")) {
                object.createEscrowMsg = $root.escrow.CreateEscrowMsg.toObject(message.createEscrowMsg, options);
                if (options.oneofs)
                    object.sum = "createEscrowMsg";
            }
            if (message.releaseEscrowMsg != null && message.hasOwnProperty("releaseEscrowMsg")) {
                object.releaseEscrowMsg = $root.escrow.ReleaseEscrowMsg.toObject(message.releaseEscrowMsg, options);
                if (options.oneofs)
                    object.sum = "releaseEscrowMsg";
            }
            if (message.returnEscrowMsg != null && message.hasOwnProperty("returnEscrowMsg")) {
                object.returnEscrowMsg = $root.escrow.ReturnEscrowMsg.toObject(message.returnEscrowMsg, options);
                if (options.oneofs)
                    object.sum = "returnEscrowMsg";
            }
            if (message.updateEscrowMsg != null && message.hasOwnProperty("updateEscrowMsg")) {
                object.updateEscrowMsg = $root.escrow.UpdateEscrowPartiesMsg.toObject(message.updateEscrowMsg, options);
                if (options.oneofs)
                    object.sum = "updateEscrowMsg";
            }
            if (message.createContractMsg != null && message.hasOwnProperty("createContractMsg")) {
                object.createContractMsg = $root.multisig.CreateContractMsg.toObject(message.createContractMsg, options);
                if (options.oneofs)
                    object.sum = "createContractMsg";
            }
            if (message.updateContractMsg != null && message.hasOwnProperty("updateContractMsg")) {
                object.updateContractMsg = $root.multisig.UpdateContractMsg.toObject(message.updateContractMsg, options);
                if (options.oneofs)
                    object.sum = "updateContractMsg";
            }
            if (message.setValidatorsMsg != null && message.hasOwnProperty("setValidatorsMsg")) {
                object.setValidatorsMsg = $root.validators.SetValidatorsMsg.toObject(message.setValidatorsMsg, options);
                if (options.oneofs)
                    object.sum = "setValidatorsMsg";
            }
            if (message.newTokenInfoMsg != null && message.hasOwnProperty("newTokenInfoMsg")) {
                object.newTokenInfoMsg = $root.currency.NewTokenInfoMsg.toObject(message.newTokenInfoMsg, options);
                if (options.oneofs)
                    object.sum = "newTokenInfoMsg";
            }
            if (message.addApprovalMsg != null && message.hasOwnProperty("addApprovalMsg")) {
                object.addApprovalMsg = $root.nft.AddApprovalMsg.toObject(message.addApprovalMsg, options);
                if (options.oneofs)
                    object.sum = "addApprovalMsg";
            }
            if (message.removeApprovalMsg != null && message.hasOwnProperty("removeApprovalMsg")) {
                object.removeApprovalMsg = $root.nft.RemoveApprovalMsg.toObject(message.removeApprovalMsg, options);
                if (options.oneofs)
                    object.sum = "removeApprovalMsg";
            }
            if (message.issueUsernameNftMsg != null && message.hasOwnProperty("issueUsernameNftMsg")) {
                object.issueUsernameNftMsg = $root.username.IssueTokenMsg.toObject(message.issueUsernameNftMsg, options);
                if (options.oneofs)
                    object.sum = "issueUsernameNftMsg";
            }
            if (message.addUsernameAddressNftMsg != null && message.hasOwnProperty("addUsernameAddressNftMsg")) {
                object.addUsernameAddressNftMsg = $root.username.AddChainAddressMsg.toObject(message.addUsernameAddressNftMsg, options);
                if (options.oneofs)
                    object.sum = "addUsernameAddressNftMsg";
            }
            if (message.removeUsernameAddressMsg != null && message.hasOwnProperty("removeUsernameAddressMsg")) {
                object.removeUsernameAddressMsg = $root.username.RemoveChainAddressMsg.toObject(message.removeUsernameAddressMsg, options);
                if (options.oneofs)
                    object.sum = "removeUsernameAddressMsg";
            }
            if (message.newRevenueMsg != null && message.hasOwnProperty("newRevenueMsg")) {
                object.newRevenueMsg = $root.distribution.NewRevenueMsg.toObject(message.newRevenueMsg, options);
                if (options.oneofs)
                    object.sum = "newRevenueMsg";
            }
            if (message.distributeMsg != null && message.hasOwnProperty("distributeMsg")) {
                object.distributeMsg = $root.distribution.DistributeMsg.toObject(message.distributeMsg, options);
                if (options.oneofs)
                    object.sum = "distributeMsg";
            }
            if (message.resetRevenueMsg != null && message.hasOwnProperty("resetRevenueMsg")) {
                object.resetRevenueMsg = $root.distribution.ResetRevenueMsg.toObject(message.resetRevenueMsg, options);
                if (options.oneofs)
                    object.sum = "resetRevenueMsg";
            }
            if (message.upgradeSchemaMsg != null && message.hasOwnProperty("upgradeSchemaMsg")) {
                object.upgradeSchemaMsg = $root.migration.UpgradeSchemaMsg.toObject(message.upgradeSchemaMsg, options);
                if (options.oneofs)
                    object.sum = "upgradeSchemaMsg";
            }
            if (message.createSwapMsg != null && message.hasOwnProperty("createSwapMsg")) {
                object.createSwapMsg = $root.aswap.CreateSwapMsg.toObject(message.createSwapMsg, options);
                if (options.oneofs)
                    object.sum = "createSwapMsg";
            }
            if (message.releaseSwapMsg != null && message.hasOwnProperty("releaseSwapMsg")) {
                object.releaseSwapMsg = $root.aswap.ReleaseSwapMsg.toObject(message.releaseSwapMsg, options);
                if (options.oneofs)
                    object.sum = "releaseSwapMsg";
            }
            if (message.returnSwapMsg != null && message.hasOwnProperty("returnSwapMsg")) {
                object.returnSwapMsg = $root.aswap.ReturnSwapMsg.toObject(message.returnSwapMsg, options);
                if (options.oneofs)
                    object.sum = "returnSwapMsg";
            }
            return object;
        };

        /**
         * Converts this Tx to JSON.
         * @function toJSON
         * @memberof app.Tx
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Tx.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Tx;
    })();

    return app;
})();

$root.username = (function() {

    /**
     * Namespace username.
     * @exports username
     * @namespace
     */
    var username = {};

    username.UsernameToken = (function() {

        /**
         * Properties of a UsernameToken.
         * @memberof username
         * @interface IUsernameToken
         * @property {nft.INonFungibleToken|null} [base] UsernameToken base
         * @property {username.ITokenDetails|null} [details] UsernameToken details
         */

        /**
         * Constructs a new UsernameToken.
         * @memberof username
         * @classdesc Represents a UsernameToken.
         * @implements IUsernameToken
         * @constructor
         * @param {username.IUsernameToken=} [properties] Properties to set
         */
        function UsernameToken(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UsernameToken base.
         * @member {nft.INonFungibleToken|null|undefined} base
         * @memberof username.UsernameToken
         * @instance
         */
        UsernameToken.prototype.base = null;

        /**
         * UsernameToken details.
         * @member {username.ITokenDetails|null|undefined} details
         * @memberof username.UsernameToken
         * @instance
         */
        UsernameToken.prototype.details = null;

        /**
         * Creates a new UsernameToken instance using the specified properties.
         * @function create
         * @memberof username.UsernameToken
         * @static
         * @param {username.IUsernameToken=} [properties] Properties to set
         * @returns {username.UsernameToken} UsernameToken instance
         */
        UsernameToken.create = function create(properties) {
            return new UsernameToken(properties);
        };

        /**
         * Encodes the specified UsernameToken message. Does not implicitly {@link username.UsernameToken.verify|verify} messages.
         * @function encode
         * @memberof username.UsernameToken
         * @static
         * @param {username.IUsernameToken} message UsernameToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsernameToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.base != null && message.hasOwnProperty("base"))
                $root.nft.NonFungibleToken.encode(message.base, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.details != null && message.hasOwnProperty("details"))
                $root.username.TokenDetails.encode(message.details, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UsernameToken message, length delimited. Does not implicitly {@link username.UsernameToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.UsernameToken
         * @static
         * @param {username.IUsernameToken} message UsernameToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsernameToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UsernameToken message from the specified reader or buffer.
         * @function decode
         * @memberof username.UsernameToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.UsernameToken} UsernameToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsernameToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.UsernameToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.base = $root.nft.NonFungibleToken.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.details = $root.username.TokenDetails.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UsernameToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.UsernameToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.UsernameToken} UsernameToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsernameToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UsernameToken message.
         * @function verify
         * @memberof username.UsernameToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UsernameToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.base != null && message.hasOwnProperty("base")) {
                var error = $root.nft.NonFungibleToken.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.details != null && message.hasOwnProperty("details")) {
                var error = $root.username.TokenDetails.verify(message.details);
                if (error)
                    return "details." + error;
            }
            return null;
        };

        /**
         * Creates a UsernameToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.UsernameToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.UsernameToken} UsernameToken
         */
        UsernameToken.fromObject = function fromObject(object) {
            if (object instanceof $root.username.UsernameToken)
                return object;
            var message = new $root.username.UsernameToken();
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".username.UsernameToken.base: object expected");
                message.base = $root.nft.NonFungibleToken.fromObject(object.base);
            }
            if (object.details != null) {
                if (typeof object.details !== "object")
                    throw TypeError(".username.UsernameToken.details: object expected");
                message.details = $root.username.TokenDetails.fromObject(object.details);
            }
            return message;
        };

        /**
         * Creates a plain object from a UsernameToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.UsernameToken
         * @static
         * @param {username.UsernameToken} message UsernameToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UsernameToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.base = null;
                object.details = null;
            }
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.nft.NonFungibleToken.toObject(message.base, options);
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = $root.username.TokenDetails.toObject(message.details, options);
            return object;
        };

        /**
         * Converts this UsernameToken to JSON.
         * @function toJSON
         * @memberof username.UsernameToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UsernameToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UsernameToken;
    })();

    username.TokenDetails = (function() {

        /**
         * Properties of a TokenDetails.
         * @memberof username
         * @interface ITokenDetails
         * @property {Array.<username.IChainAddress>|null} [addresses] TokenDetails addresses
         */

        /**
         * Constructs a new TokenDetails.
         * @memberof username
         * @classdesc Represents a TokenDetails.
         * @implements ITokenDetails
         * @constructor
         * @param {username.ITokenDetails=} [properties] Properties to set
         */
        function TokenDetails(properties) {
            this.addresses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TokenDetails addresses.
         * @member {Array.<username.IChainAddress>} addresses
         * @memberof username.TokenDetails
         * @instance
         */
        TokenDetails.prototype.addresses = $util.emptyArray;

        /**
         * Creates a new TokenDetails instance using the specified properties.
         * @function create
         * @memberof username.TokenDetails
         * @static
         * @param {username.ITokenDetails=} [properties] Properties to set
         * @returns {username.TokenDetails} TokenDetails instance
         */
        TokenDetails.create = function create(properties) {
            return new TokenDetails(properties);
        };

        /**
         * Encodes the specified TokenDetails message. Does not implicitly {@link username.TokenDetails.verify|verify} messages.
         * @function encode
         * @memberof username.TokenDetails
         * @static
         * @param {username.ITokenDetails} message TokenDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addresses != null && message.addresses.length)
                for (var i = 0; i < message.addresses.length; ++i)
                    $root.username.ChainAddress.encode(message.addresses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TokenDetails message, length delimited. Does not implicitly {@link username.TokenDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.TokenDetails
         * @static
         * @param {username.ITokenDetails} message TokenDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TokenDetails message from the specified reader or buffer.
         * @function decode
         * @memberof username.TokenDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.TokenDetails} TokenDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.TokenDetails();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.addresses && message.addresses.length))
                        message.addresses = [];
                    message.addresses.push($root.username.ChainAddress.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TokenDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.TokenDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.TokenDetails} TokenDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TokenDetails message.
         * @function verify
         * @memberof username.TokenDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TokenDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addresses != null && message.hasOwnProperty("addresses")) {
                if (!Array.isArray(message.addresses))
                    return "addresses: array expected";
                for (var i = 0; i < message.addresses.length; ++i) {
                    var error = $root.username.ChainAddress.verify(message.addresses[i]);
                    if (error)
                        return "addresses." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TokenDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.TokenDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.TokenDetails} TokenDetails
         */
        TokenDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.username.TokenDetails)
                return object;
            var message = new $root.username.TokenDetails();
            if (object.addresses) {
                if (!Array.isArray(object.addresses))
                    throw TypeError(".username.TokenDetails.addresses: array expected");
                message.addresses = [];
                for (var i = 0; i < object.addresses.length; ++i) {
                    if (typeof object.addresses[i] !== "object")
                        throw TypeError(".username.TokenDetails.addresses: object expected");
                    message.addresses[i] = $root.username.ChainAddress.fromObject(object.addresses[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TokenDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.TokenDetails
         * @static
         * @param {username.TokenDetails} message TokenDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TokenDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.addresses = [];
            if (message.addresses && message.addresses.length) {
                object.addresses = [];
                for (var j = 0; j < message.addresses.length; ++j)
                    object.addresses[j] = $root.username.ChainAddress.toObject(message.addresses[j], options);
            }
            return object;
        };

        /**
         * Converts this TokenDetails to JSON.
         * @function toJSON
         * @memberof username.TokenDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TokenDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TokenDetails;
    })();

    username.ChainAddress = (function() {

        /**
         * Properties of a ChainAddress.
         * @memberof username
         * @interface IChainAddress
         * @property {Uint8Array|null} [blockchainId] validating it.
         * @property {string|null} [address] blockchain.
         */

        /**
         * Constructs a new ChainAddress.
         * @memberof username
         * @classdesc ChainAddress is an address bind to a specific blockchain chain.
         * @implements IChainAddress
         * @constructor
         * @param {username.IChainAddress=} [properties] Properties to set
         */
        function ChainAddress(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * validating it.
         * @member {Uint8Array} blockchainId
         * @memberof username.ChainAddress
         * @instance
         */
        ChainAddress.prototype.blockchainId = $util.newBuffer([]);

        /**
         * blockchain.
         * @member {string} address
         * @memberof username.ChainAddress
         * @instance
         */
        ChainAddress.prototype.address = "";

        /**
         * Creates a new ChainAddress instance using the specified properties.
         * @function create
         * @memberof username.ChainAddress
         * @static
         * @param {username.IChainAddress=} [properties] Properties to set
         * @returns {username.ChainAddress} ChainAddress instance
         */
        ChainAddress.create = function create(properties) {
            return new ChainAddress(properties);
        };

        /**
         * Encodes the specified ChainAddress message. Does not implicitly {@link username.ChainAddress.verify|verify} messages.
         * @function encode
         * @memberof username.ChainAddress
         * @static
         * @param {username.IChainAddress} message ChainAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockchainId);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
            return writer;
        };

        /**
         * Encodes the specified ChainAddress message, length delimited. Does not implicitly {@link username.ChainAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.ChainAddress
         * @static
         * @param {username.IChainAddress} message ChainAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChainAddress message from the specified reader or buffer.
         * @function decode
         * @memberof username.ChainAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.ChainAddress} ChainAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.ChainAddress();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockchainId = reader.bytes();
                    break;
                case 2:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChainAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.ChainAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.ChainAddress} ChainAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChainAddress message.
         * @function verify
         * @memberof username.ChainAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChainAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                if (!(message.blockchainId && typeof message.blockchainId.length === "number" || $util.isString(message.blockchainId)))
                    return "blockchainId: buffer expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            return null;
        };

        /**
         * Creates a ChainAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.ChainAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.ChainAddress} ChainAddress
         */
        ChainAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.username.ChainAddress)
                return object;
            var message = new $root.username.ChainAddress();
            if (object.blockchainId != null)
                if (typeof object.blockchainId === "string")
                    $util.base64.decode(object.blockchainId, message.blockchainId = $util.newBuffer($util.base64.length(object.blockchainId)), 0);
                else if (object.blockchainId.length)
                    message.blockchainId = object.blockchainId;
            if (object.address != null)
                message.address = String(object.address);
            return message;
        };

        /**
         * Creates a plain object from a ChainAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.ChainAddress
         * @static
         * @param {username.ChainAddress} message ChainAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChainAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.blockchainId = "";
                else {
                    object.blockchainId = [];
                    if (options.bytes !== Array)
                        object.blockchainId = $util.newBuffer(object.blockchainId);
                }
                object.address = "";
            }
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                object.blockchainId = options.bytes === String ? $util.base64.encode(message.blockchainId, 0, message.blockchainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockchainId) : message.blockchainId;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            return object;
        };

        /**
         * Converts this ChainAddress to JSON.
         * @function toJSON
         * @memberof username.ChainAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChainAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChainAddress;
    })();

    username.IssueTokenMsg = (function() {

        /**
         * Properties of an IssueTokenMsg.
         * @memberof username
         * @interface IIssueTokenMsg
         * @property {Uint8Array|null} [id] IssueTokenMsg id
         * @property {Uint8Array|null} [owner] IssueTokenMsg owner
         * @property {Array.<nft.IActionApprovals>|null} [approvals] IssueTokenMsg approvals
         * @property {username.ITokenDetails|null} [details] IssueTokenMsg details
         */

        /**
         * Constructs a new IssueTokenMsg.
         * @memberof username
         * @classdesc Represents an IssueTokenMsg.
         * @implements IIssueTokenMsg
         * @constructor
         * @param {username.IIssueTokenMsg=} [properties] Properties to set
         */
        function IssueTokenMsg(properties) {
            this.approvals = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IssueTokenMsg id.
         * @member {Uint8Array} id
         * @memberof username.IssueTokenMsg
         * @instance
         */
        IssueTokenMsg.prototype.id = $util.newBuffer([]);

        /**
         * IssueTokenMsg owner.
         * @member {Uint8Array} owner
         * @memberof username.IssueTokenMsg
         * @instance
         */
        IssueTokenMsg.prototype.owner = $util.newBuffer([]);

        /**
         * IssueTokenMsg approvals.
         * @member {Array.<nft.IActionApprovals>} approvals
         * @memberof username.IssueTokenMsg
         * @instance
         */
        IssueTokenMsg.prototype.approvals = $util.emptyArray;

        /**
         * IssueTokenMsg details.
         * @member {username.ITokenDetails|null|undefined} details
         * @memberof username.IssueTokenMsg
         * @instance
         */
        IssueTokenMsg.prototype.details = null;

        /**
         * Creates a new IssueTokenMsg instance using the specified properties.
         * @function create
         * @memberof username.IssueTokenMsg
         * @static
         * @param {username.IIssueTokenMsg=} [properties] Properties to set
         * @returns {username.IssueTokenMsg} IssueTokenMsg instance
         */
        IssueTokenMsg.create = function create(properties) {
            return new IssueTokenMsg(properties);
        };

        /**
         * Encodes the specified IssueTokenMsg message. Does not implicitly {@link username.IssueTokenMsg.verify|verify} messages.
         * @function encode
         * @memberof username.IssueTokenMsg
         * @static
         * @param {username.IIssueTokenMsg} message IssueTokenMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueTokenMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.owner);
            if (message.approvals != null && message.approvals.length)
                for (var i = 0; i < message.approvals.length; ++i)
                    $root.nft.ActionApprovals.encode(message.approvals[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.details != null && message.hasOwnProperty("details"))
                $root.username.TokenDetails.encode(message.details, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified IssueTokenMsg message, length delimited. Does not implicitly {@link username.IssueTokenMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.IssueTokenMsg
         * @static
         * @param {username.IIssueTokenMsg} message IssueTokenMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IssueTokenMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IssueTokenMsg message from the specified reader or buffer.
         * @function decode
         * @memberof username.IssueTokenMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.IssueTokenMsg} IssueTokenMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueTokenMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.IssueTokenMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.owner = reader.bytes();
                    break;
                case 3:
                    if (!(message.approvals && message.approvals.length))
                        message.approvals = [];
                    message.approvals.push($root.nft.ActionApprovals.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.details = $root.username.TokenDetails.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IssueTokenMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.IssueTokenMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.IssueTokenMsg} IssueTokenMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IssueTokenMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IssueTokenMsg message.
         * @function verify
         * @memberof username.IssueTokenMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IssueTokenMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                    return "owner: buffer expected";
            if (message.approvals != null && message.hasOwnProperty("approvals")) {
                if (!Array.isArray(message.approvals))
                    return "approvals: array expected";
                for (var i = 0; i < message.approvals.length; ++i) {
                    var error = $root.nft.ActionApprovals.verify(message.approvals[i]);
                    if (error)
                        return "approvals." + error;
                }
            }
            if (message.details != null && message.hasOwnProperty("details")) {
                var error = $root.username.TokenDetails.verify(message.details);
                if (error)
                    return "details." + error;
            }
            return null;
        };

        /**
         * Creates an IssueTokenMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.IssueTokenMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.IssueTokenMsg} IssueTokenMsg
         */
        IssueTokenMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.username.IssueTokenMsg)
                return object;
            var message = new $root.username.IssueTokenMsg();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.owner != null)
                if (typeof object.owner === "string")
                    $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                else if (object.owner.length)
                    message.owner = object.owner;
            if (object.approvals) {
                if (!Array.isArray(object.approvals))
                    throw TypeError(".username.IssueTokenMsg.approvals: array expected");
                message.approvals = [];
                for (var i = 0; i < object.approvals.length; ++i) {
                    if (typeof object.approvals[i] !== "object")
                        throw TypeError(".username.IssueTokenMsg.approvals: object expected");
                    message.approvals[i] = $root.nft.ActionApprovals.fromObject(object.approvals[i]);
                }
            }
            if (object.details != null) {
                if (typeof object.details !== "object")
                    throw TypeError(".username.IssueTokenMsg.details: object expected");
                message.details = $root.username.TokenDetails.fromObject(object.details);
            }
            return message;
        };

        /**
         * Creates a plain object from an IssueTokenMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.IssueTokenMsg
         * @static
         * @param {username.IssueTokenMsg} message IssueTokenMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IssueTokenMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.approvals = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.owner = "";
                else {
                    object.owner = [];
                    if (options.bytes !== Array)
                        object.owner = $util.newBuffer(object.owner);
                }
                object.details = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
            if (message.approvals && message.approvals.length) {
                object.approvals = [];
                for (var j = 0; j < message.approvals.length; ++j)
                    object.approvals[j] = $root.nft.ActionApprovals.toObject(message.approvals[j], options);
            }
            if (message.details != null && message.hasOwnProperty("details"))
                object.details = $root.username.TokenDetails.toObject(message.details, options);
            return object;
        };

        /**
         * Converts this IssueTokenMsg to JSON.
         * @function toJSON
         * @memberof username.IssueTokenMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IssueTokenMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IssueTokenMsg;
    })();

    username.AddChainAddressMsg = (function() {

        /**
         * Properties of an AddChainAddressMsg.
         * @memberof username
         * @interface IAddChainAddressMsg
         * @property {Uint8Array|null} [usernameId] AddChainAddressMsg usernameId
         * @property {Uint8Array|null} [blockchainId] AddChainAddressMsg blockchainId
         * @property {string|null} [address] AddChainAddressMsg address
         */

        /**
         * Constructs a new AddChainAddressMsg.
         * @memberof username
         * @classdesc Represents an AddChainAddressMsg.
         * @implements IAddChainAddressMsg
         * @constructor
         * @param {username.IAddChainAddressMsg=} [properties] Properties to set
         */
        function AddChainAddressMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddChainAddressMsg usernameId.
         * @member {Uint8Array} usernameId
         * @memberof username.AddChainAddressMsg
         * @instance
         */
        AddChainAddressMsg.prototype.usernameId = $util.newBuffer([]);

        /**
         * AddChainAddressMsg blockchainId.
         * @member {Uint8Array} blockchainId
         * @memberof username.AddChainAddressMsg
         * @instance
         */
        AddChainAddressMsg.prototype.blockchainId = $util.newBuffer([]);

        /**
         * AddChainAddressMsg address.
         * @member {string} address
         * @memberof username.AddChainAddressMsg
         * @instance
         */
        AddChainAddressMsg.prototype.address = "";

        /**
         * Creates a new AddChainAddressMsg instance using the specified properties.
         * @function create
         * @memberof username.AddChainAddressMsg
         * @static
         * @param {username.IAddChainAddressMsg=} [properties] Properties to set
         * @returns {username.AddChainAddressMsg} AddChainAddressMsg instance
         */
        AddChainAddressMsg.create = function create(properties) {
            return new AddChainAddressMsg(properties);
        };

        /**
         * Encodes the specified AddChainAddressMsg message. Does not implicitly {@link username.AddChainAddressMsg.verify|verify} messages.
         * @function encode
         * @memberof username.AddChainAddressMsg
         * @static
         * @param {username.IAddChainAddressMsg} message AddChainAddressMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddChainAddressMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.usernameId != null && message.hasOwnProperty("usernameId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.usernameId);
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.blockchainId);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.address);
            return writer;
        };

        /**
         * Encodes the specified AddChainAddressMsg message, length delimited. Does not implicitly {@link username.AddChainAddressMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.AddChainAddressMsg
         * @static
         * @param {username.IAddChainAddressMsg} message AddChainAddressMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddChainAddressMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddChainAddressMsg message from the specified reader or buffer.
         * @function decode
         * @memberof username.AddChainAddressMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.AddChainAddressMsg} AddChainAddressMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddChainAddressMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.AddChainAddressMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.usernameId = reader.bytes();
                    break;
                case 2:
                    message.blockchainId = reader.bytes();
                    break;
                case 3:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddChainAddressMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.AddChainAddressMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.AddChainAddressMsg} AddChainAddressMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddChainAddressMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddChainAddressMsg message.
         * @function verify
         * @memberof username.AddChainAddressMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddChainAddressMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.usernameId != null && message.hasOwnProperty("usernameId"))
                if (!(message.usernameId && typeof message.usernameId.length === "number" || $util.isString(message.usernameId)))
                    return "usernameId: buffer expected";
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                if (!(message.blockchainId && typeof message.blockchainId.length === "number" || $util.isString(message.blockchainId)))
                    return "blockchainId: buffer expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            return null;
        };

        /**
         * Creates an AddChainAddressMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.AddChainAddressMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.AddChainAddressMsg} AddChainAddressMsg
         */
        AddChainAddressMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.username.AddChainAddressMsg)
                return object;
            var message = new $root.username.AddChainAddressMsg();
            if (object.usernameId != null)
                if (typeof object.usernameId === "string")
                    $util.base64.decode(object.usernameId, message.usernameId = $util.newBuffer($util.base64.length(object.usernameId)), 0);
                else if (object.usernameId.length)
                    message.usernameId = object.usernameId;
            if (object.blockchainId != null)
                if (typeof object.blockchainId === "string")
                    $util.base64.decode(object.blockchainId, message.blockchainId = $util.newBuffer($util.base64.length(object.blockchainId)), 0);
                else if (object.blockchainId.length)
                    message.blockchainId = object.blockchainId;
            if (object.address != null)
                message.address = String(object.address);
            return message;
        };

        /**
         * Creates a plain object from an AddChainAddressMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.AddChainAddressMsg
         * @static
         * @param {username.AddChainAddressMsg} message AddChainAddressMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddChainAddressMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.usernameId = "";
                else {
                    object.usernameId = [];
                    if (options.bytes !== Array)
                        object.usernameId = $util.newBuffer(object.usernameId);
                }
                if (options.bytes === String)
                    object.blockchainId = "";
                else {
                    object.blockchainId = [];
                    if (options.bytes !== Array)
                        object.blockchainId = $util.newBuffer(object.blockchainId);
                }
                object.address = "";
            }
            if (message.usernameId != null && message.hasOwnProperty("usernameId"))
                object.usernameId = options.bytes === String ? $util.base64.encode(message.usernameId, 0, message.usernameId.length) : options.bytes === Array ? Array.prototype.slice.call(message.usernameId) : message.usernameId;
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                object.blockchainId = options.bytes === String ? $util.base64.encode(message.blockchainId, 0, message.blockchainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockchainId) : message.blockchainId;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            return object;
        };

        /**
         * Converts this AddChainAddressMsg to JSON.
         * @function toJSON
         * @memberof username.AddChainAddressMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddChainAddressMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddChainAddressMsg;
    })();

    username.RemoveChainAddressMsg = (function() {

        /**
         * Properties of a RemoveChainAddressMsg.
         * @memberof username
         * @interface IRemoveChainAddressMsg
         * @property {Uint8Array|null} [usernameId] RemoveChainAddressMsg usernameId
         * @property {Uint8Array|null} [blockchainId] RemoveChainAddressMsg blockchainId
         * @property {string|null} [address] RemoveChainAddressMsg address
         */

        /**
         * Constructs a new RemoveChainAddressMsg.
         * @memberof username
         * @classdesc Represents a RemoveChainAddressMsg.
         * @implements IRemoveChainAddressMsg
         * @constructor
         * @param {username.IRemoveChainAddressMsg=} [properties] Properties to set
         */
        function RemoveChainAddressMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RemoveChainAddressMsg usernameId.
         * @member {Uint8Array} usernameId
         * @memberof username.RemoveChainAddressMsg
         * @instance
         */
        RemoveChainAddressMsg.prototype.usernameId = $util.newBuffer([]);

        /**
         * RemoveChainAddressMsg blockchainId.
         * @member {Uint8Array} blockchainId
         * @memberof username.RemoveChainAddressMsg
         * @instance
         */
        RemoveChainAddressMsg.prototype.blockchainId = $util.newBuffer([]);

        /**
         * RemoveChainAddressMsg address.
         * @member {string} address
         * @memberof username.RemoveChainAddressMsg
         * @instance
         */
        RemoveChainAddressMsg.prototype.address = "";

        /**
         * Creates a new RemoveChainAddressMsg instance using the specified properties.
         * @function create
         * @memberof username.RemoveChainAddressMsg
         * @static
         * @param {username.IRemoveChainAddressMsg=} [properties] Properties to set
         * @returns {username.RemoveChainAddressMsg} RemoveChainAddressMsg instance
         */
        RemoveChainAddressMsg.create = function create(properties) {
            return new RemoveChainAddressMsg(properties);
        };

        /**
         * Encodes the specified RemoveChainAddressMsg message. Does not implicitly {@link username.RemoveChainAddressMsg.verify|verify} messages.
         * @function encode
         * @memberof username.RemoveChainAddressMsg
         * @static
         * @param {username.IRemoveChainAddressMsg} message RemoveChainAddressMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveChainAddressMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.usernameId != null && message.hasOwnProperty("usernameId"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.usernameId);
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.blockchainId);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.address);
            return writer;
        };

        /**
         * Encodes the specified RemoveChainAddressMsg message, length delimited. Does not implicitly {@link username.RemoveChainAddressMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof username.RemoveChainAddressMsg
         * @static
         * @param {username.IRemoveChainAddressMsg} message RemoveChainAddressMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveChainAddressMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RemoveChainAddressMsg message from the specified reader or buffer.
         * @function decode
         * @memberof username.RemoveChainAddressMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {username.RemoveChainAddressMsg} RemoveChainAddressMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveChainAddressMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.username.RemoveChainAddressMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.usernameId = reader.bytes();
                    break;
                case 2:
                    message.blockchainId = reader.bytes();
                    break;
                case 3:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RemoveChainAddressMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof username.RemoveChainAddressMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {username.RemoveChainAddressMsg} RemoveChainAddressMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveChainAddressMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RemoveChainAddressMsg message.
         * @function verify
         * @memberof username.RemoveChainAddressMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RemoveChainAddressMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.usernameId != null && message.hasOwnProperty("usernameId"))
                if (!(message.usernameId && typeof message.usernameId.length === "number" || $util.isString(message.usernameId)))
                    return "usernameId: buffer expected";
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                if (!(message.blockchainId && typeof message.blockchainId.length === "number" || $util.isString(message.blockchainId)))
                    return "blockchainId: buffer expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            return null;
        };

        /**
         * Creates a RemoveChainAddressMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof username.RemoveChainAddressMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {username.RemoveChainAddressMsg} RemoveChainAddressMsg
         */
        RemoveChainAddressMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.username.RemoveChainAddressMsg)
                return object;
            var message = new $root.username.RemoveChainAddressMsg();
            if (object.usernameId != null)
                if (typeof object.usernameId === "string")
                    $util.base64.decode(object.usernameId, message.usernameId = $util.newBuffer($util.base64.length(object.usernameId)), 0);
                else if (object.usernameId.length)
                    message.usernameId = object.usernameId;
            if (object.blockchainId != null)
                if (typeof object.blockchainId === "string")
                    $util.base64.decode(object.blockchainId, message.blockchainId = $util.newBuffer($util.base64.length(object.blockchainId)), 0);
                else if (object.blockchainId.length)
                    message.blockchainId = object.blockchainId;
            if (object.address != null)
                message.address = String(object.address);
            return message;
        };

        /**
         * Creates a plain object from a RemoveChainAddressMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof username.RemoveChainAddressMsg
         * @static
         * @param {username.RemoveChainAddressMsg} message RemoveChainAddressMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RemoveChainAddressMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.usernameId = "";
                else {
                    object.usernameId = [];
                    if (options.bytes !== Array)
                        object.usernameId = $util.newBuffer(object.usernameId);
                }
                if (options.bytes === String)
                    object.blockchainId = "";
                else {
                    object.blockchainId = [];
                    if (options.bytes !== Array)
                        object.blockchainId = $util.newBuffer(object.blockchainId);
                }
                object.address = "";
            }
            if (message.usernameId != null && message.hasOwnProperty("usernameId"))
                object.usernameId = options.bytes === String ? $util.base64.encode(message.usernameId, 0, message.usernameId.length) : options.bytes === Array ? Array.prototype.slice.call(message.usernameId) : message.usernameId;
            if (message.blockchainId != null && message.hasOwnProperty("blockchainId"))
                object.blockchainId = options.bytes === String ? $util.base64.encode(message.blockchainId, 0, message.blockchainId.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockchainId) : message.blockchainId;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            return object;
        };

        /**
         * Converts this RemoveChainAddressMsg to JSON.
         * @function toJSON
         * @memberof username.RemoveChainAddressMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RemoveChainAddressMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RemoveChainAddressMsg;
    })();

    return username;
})();

$root.weave = (function() {

    /**
     * Namespace weave.
     * @exports weave
     * @namespace
     */
    var weave = {};

    weave.Metadata = (function() {

        /**
         * Properties of a Metadata.
         * @memberof weave
         * @interface IMetadata
         * @property {number|null} [schema] Metadata schema
         */

        /**
         * Constructs a new Metadata.
         * @memberof weave
         * @classdesc weave.Metadata metadata = 1;
         * @implements IMetadata
         * @constructor
         * @param {weave.IMetadata=} [properties] Properties to set
         */
        function Metadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Metadata schema.
         * @member {number} schema
         * @memberof weave.Metadata
         * @instance
         */
        Metadata.prototype.schema = 0;

        /**
         * Creates a new Metadata instance using the specified properties.
         * @function create
         * @memberof weave.Metadata
         * @static
         * @param {weave.IMetadata=} [properties] Properties to set
         * @returns {weave.Metadata} Metadata instance
         */
        Metadata.create = function create(properties) {
            return new Metadata(properties);
        };

        /**
         * Encodes the specified Metadata message. Does not implicitly {@link weave.Metadata.verify|verify} messages.
         * @function encode
         * @memberof weave.Metadata
         * @static
         * @param {weave.IMetadata} message Metadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && message.hasOwnProperty("schema"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.schema);
            return writer;
        };

        /**
         * Encodes the specified Metadata message, length delimited. Does not implicitly {@link weave.Metadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof weave.Metadata
         * @static
         * @param {weave.IMetadata} message Metadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Metadata message from the specified reader or buffer.
         * @function decode
         * @memberof weave.Metadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {weave.Metadata} Metadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.weave.Metadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.schema = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Metadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof weave.Metadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {weave.Metadata} Metadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Metadata message.
         * @function verify
         * @memberof weave.Metadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Metadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isInteger(message.schema))
                    return "schema: integer expected";
            return null;
        };

        /**
         * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof weave.Metadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {weave.Metadata} Metadata
         */
        Metadata.fromObject = function fromObject(object) {
            if (object instanceof $root.weave.Metadata)
                return object;
            var message = new $root.weave.Metadata();
            if (object.schema != null)
                message.schema = object.schema >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Metadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof weave.Metadata
         * @static
         * @param {weave.Metadata} message Metadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Metadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.schema = 0;
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            return object;
        };

        /**
         * Converts this Metadata to JSON.
         * @function toJSON
         * @memberof weave.Metadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Metadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Metadata;
    })();

    return weave;
})();

$root.coin = (function() {

    /**
     * Namespace coin.
     * @exports coin
     * @namespace
     */
    var coin = {};

    coin.Coin = (function() {

        /**
         * Properties of a Coin.
         * @memberof coin
         * @interface ICoin
         * @property {number|Long|null} [whole] Whole coins, -10^15 < integer < 10^15
         * @property {number|Long|null} [fractional] If fractional != 0, must have same sign as integer
         * @property {string|null} [ticker] all Coins of the same currency can be combined
         */

        /**
         * Constructs a new Coin.
         * @memberof coin
         * @classdesc own type, possibly borrowing from this code.
         * @implements ICoin
         * @constructor
         * @param {coin.ICoin=} [properties] Properties to set
         */
        function Coin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Whole coins, -10^15 < integer < 10^15
         * @member {number|Long} whole
         * @memberof coin.Coin
         * @instance
         */
        Coin.prototype.whole = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * If fractional != 0, must have same sign as integer
         * @member {number|Long} fractional
         * @memberof coin.Coin
         * @instance
         */
        Coin.prototype.fractional = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * all Coins of the same currency can be combined
         * @member {string} ticker
         * @memberof coin.Coin
         * @instance
         */
        Coin.prototype.ticker = "";

        /**
         * Creates a new Coin instance using the specified properties.
         * @function create
         * @memberof coin.Coin
         * @static
         * @param {coin.ICoin=} [properties] Properties to set
         * @returns {coin.Coin} Coin instance
         */
        Coin.create = function create(properties) {
            return new Coin(properties);
        };

        /**
         * Encodes the specified Coin message. Does not implicitly {@link coin.Coin.verify|verify} messages.
         * @function encode
         * @memberof coin.Coin
         * @static
         * @param {coin.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.whole != null && message.hasOwnProperty("whole"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.whole);
            if (message.fractional != null && message.hasOwnProperty("fractional"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fractional);
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ticker);
            return writer;
        };

        /**
         * Encodes the specified Coin message, length delimited. Does not implicitly {@link coin.Coin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof coin.Coin
         * @static
         * @param {coin.ICoin} message Coin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Coin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Coin message from the specified reader or buffer.
         * @function decode
         * @memberof coin.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {coin.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.coin.Coin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.whole = reader.int64();
                    break;
                case 2:
                    message.fractional = reader.int64();
                    break;
                case 3:
                    message.ticker = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Coin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof coin.Coin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {coin.Coin} Coin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Coin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Coin message.
         * @function verify
         * @memberof coin.Coin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Coin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.whole != null && message.hasOwnProperty("whole"))
                if (!$util.isInteger(message.whole) && !(message.whole && $util.isInteger(message.whole.low) && $util.isInteger(message.whole.high)))
                    return "whole: integer|Long expected";
            if (message.fractional != null && message.hasOwnProperty("fractional"))
                if (!$util.isInteger(message.fractional) && !(message.fractional && $util.isInteger(message.fractional.low) && $util.isInteger(message.fractional.high)))
                    return "fractional: integer|Long expected";
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                if (!$util.isString(message.ticker))
                    return "ticker: string expected";
            return null;
        };

        /**
         * Creates a Coin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof coin.Coin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {coin.Coin} Coin
         */
        Coin.fromObject = function fromObject(object) {
            if (object instanceof $root.coin.Coin)
                return object;
            var message = new $root.coin.Coin();
            if (object.whole != null)
                if ($util.Long)
                    (message.whole = $util.Long.fromValue(object.whole)).unsigned = false;
                else if (typeof object.whole === "string")
                    message.whole = parseInt(object.whole, 10);
                else if (typeof object.whole === "number")
                    message.whole = object.whole;
                else if (typeof object.whole === "object")
                    message.whole = new $util.LongBits(object.whole.low >>> 0, object.whole.high >>> 0).toNumber();
            if (object.fractional != null)
                if ($util.Long)
                    (message.fractional = $util.Long.fromValue(object.fractional)).unsigned = false;
                else if (typeof object.fractional === "string")
                    message.fractional = parseInt(object.fractional, 10);
                else if (typeof object.fractional === "number")
                    message.fractional = object.fractional;
                else if (typeof object.fractional === "object")
                    message.fractional = new $util.LongBits(object.fractional.low >>> 0, object.fractional.high >>> 0).toNumber();
            if (object.ticker != null)
                message.ticker = String(object.ticker);
            return message;
        };

        /**
         * Creates a plain object from a Coin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof coin.Coin
         * @static
         * @param {coin.Coin} message Coin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Coin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.whole = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.whole = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fractional = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fractional = options.longs === String ? "0" : 0;
                object.ticker = "";
            }
            if (message.whole != null && message.hasOwnProperty("whole"))
                if (typeof message.whole === "number")
                    object.whole = options.longs === String ? String(message.whole) : message.whole;
                else
                    object.whole = options.longs === String ? $util.Long.prototype.toString.call(message.whole) : options.longs === Number ? new $util.LongBits(message.whole.low >>> 0, message.whole.high >>> 0).toNumber() : message.whole;
            if (message.fractional != null && message.hasOwnProperty("fractional"))
                if (typeof message.fractional === "number")
                    object.fractional = options.longs === String ? String(message.fractional) : message.fractional;
                else
                    object.fractional = options.longs === String ? $util.Long.prototype.toString.call(message.fractional) : options.longs === Number ? new $util.LongBits(message.fractional.low >>> 0, message.fractional.high >>> 0).toNumber() : message.fractional;
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                object.ticker = message.ticker;
            return object;
        };

        /**
         * Converts this Coin to JSON.
         * @function toJSON
         * @memberof coin.Coin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Coin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Coin;
    })();

    return coin;
})();

$root.crypto = (function() {

    /**
     * Namespace crypto.
     * @exports crypto
     * @namespace
     */
    var crypto = {};

    crypto.PublicKey = (function() {

        /**
         * Properties of a PublicKey.
         * @memberof crypto
         * @interface IPublicKey
         * @property {Uint8Array|null} [ed25519] PublicKey ed25519
         */

        /**
         * Constructs a new PublicKey.
         * @memberof crypto
         * @classdesc Represents a PublicKey.
         * @implements IPublicKey
         * @constructor
         * @param {crypto.IPublicKey=} [properties] Properties to set
         */
        function PublicKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublicKey ed25519.
         * @member {Uint8Array} ed25519
         * @memberof crypto.PublicKey
         * @instance
         */
        PublicKey.prototype.ed25519 = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * PublicKey pub.
         * @member {"ed25519"|undefined} pub
         * @memberof crypto.PublicKey
         * @instance
         */
        Object.defineProperty(PublicKey.prototype, "pub", {
            get: $util.oneOfGetter($oneOfFields = ["ed25519"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PublicKey instance using the specified properties.
         * @function create
         * @memberof crypto.PublicKey
         * @static
         * @param {crypto.IPublicKey=} [properties] Properties to set
         * @returns {crypto.PublicKey} PublicKey instance
         */
        PublicKey.create = function create(properties) {
            return new PublicKey(properties);
        };

        /**
         * Encodes the specified PublicKey message. Does not implicitly {@link crypto.PublicKey.verify|verify} messages.
         * @function encode
         * @memberof crypto.PublicKey
         * @static
         * @param {crypto.IPublicKey} message PublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ed25519 != null && message.hasOwnProperty("ed25519"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ed25519);
            return writer;
        };

        /**
         * Encodes the specified PublicKey message, length delimited. Does not implicitly {@link crypto.PublicKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof crypto.PublicKey
         * @static
         * @param {crypto.IPublicKey} message PublicKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublicKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublicKey message from the specified reader or buffer.
         * @function decode
         * @memberof crypto.PublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {crypto.PublicKey} PublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.crypto.PublicKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ed25519 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublicKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof crypto.PublicKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {crypto.PublicKey} PublicKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublicKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublicKey message.
         * @function verify
         * @memberof crypto.PublicKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublicKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                properties.pub = 1;
                if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
                    return "ed25519: buffer expected";
            }
            return null;
        };

        /**
         * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof crypto.PublicKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {crypto.PublicKey} PublicKey
         */
        PublicKey.fromObject = function fromObject(object) {
            if (object instanceof $root.crypto.PublicKey)
                return object;
            var message = new $root.crypto.PublicKey();
            if (object.ed25519 != null)
                if (typeof object.ed25519 === "string")
                    $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
                else if (object.ed25519.length)
                    message.ed25519 = object.ed25519;
            return message;
        };

        /**
         * Creates a plain object from a PublicKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof crypto.PublicKey
         * @static
         * @param {crypto.PublicKey} message PublicKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PublicKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
                if (options.oneofs)
                    object.pub = "ed25519";
            }
            return object;
        };

        /**
         * Converts this PublicKey to JSON.
         * @function toJSON
         * @memberof crypto.PublicKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PublicKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PublicKey;
    })();

    crypto.PrivateKey = (function() {

        /**
         * Properties of a PrivateKey.
         * @memberof crypto
         * @interface IPrivateKey
         * @property {Uint8Array|null} [ed25519] PrivateKey ed25519
         */

        /**
         * Constructs a new PrivateKey.
         * @memberof crypto
         * @classdesc Represents a PrivateKey.
         * @implements IPrivateKey
         * @constructor
         * @param {crypto.IPrivateKey=} [properties] Properties to set
         */
        function PrivateKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivateKey ed25519.
         * @member {Uint8Array} ed25519
         * @memberof crypto.PrivateKey
         * @instance
         */
        PrivateKey.prototype.ed25519 = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * PrivateKey priv.
         * @member {"ed25519"|undefined} priv
         * @memberof crypto.PrivateKey
         * @instance
         */
        Object.defineProperty(PrivateKey.prototype, "priv", {
            get: $util.oneOfGetter($oneOfFields = ["ed25519"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PrivateKey instance using the specified properties.
         * @function create
         * @memberof crypto.PrivateKey
         * @static
         * @param {crypto.IPrivateKey=} [properties] Properties to set
         * @returns {crypto.PrivateKey} PrivateKey instance
         */
        PrivateKey.create = function create(properties) {
            return new PrivateKey(properties);
        };

        /**
         * Encodes the specified PrivateKey message. Does not implicitly {@link crypto.PrivateKey.verify|verify} messages.
         * @function encode
         * @memberof crypto.PrivateKey
         * @static
         * @param {crypto.IPrivateKey} message PrivateKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ed25519 != null && message.hasOwnProperty("ed25519"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ed25519);
            return writer;
        };

        /**
         * Encodes the specified PrivateKey message, length delimited. Does not implicitly {@link crypto.PrivateKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof crypto.PrivateKey
         * @static
         * @param {crypto.IPrivateKey} message PrivateKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivateKey message from the specified reader or buffer.
         * @function decode
         * @memberof crypto.PrivateKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {crypto.PrivateKey} PrivateKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.crypto.PrivateKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ed25519 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivateKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof crypto.PrivateKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {crypto.PrivateKey} PrivateKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivateKey message.
         * @function verify
         * @memberof crypto.PrivateKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                properties.priv = 1;
                if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
                    return "ed25519: buffer expected";
            }
            return null;
        };

        /**
         * Creates a PrivateKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof crypto.PrivateKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {crypto.PrivateKey} PrivateKey
         */
        PrivateKey.fromObject = function fromObject(object) {
            if (object instanceof $root.crypto.PrivateKey)
                return object;
            var message = new $root.crypto.PrivateKey();
            if (object.ed25519 != null)
                if (typeof object.ed25519 === "string")
                    $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
                else if (object.ed25519.length)
                    message.ed25519 = object.ed25519;
            return message;
        };

        /**
         * Creates a plain object from a PrivateKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof crypto.PrivateKey
         * @static
         * @param {crypto.PrivateKey} message PrivateKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrivateKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
                if (options.oneofs)
                    object.priv = "ed25519";
            }
            return object;
        };

        /**
         * Converts this PrivateKey to JSON.
         * @function toJSON
         * @memberof crypto.PrivateKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrivateKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PrivateKey;
    })();

    crypto.Signature = (function() {

        /**
         * Properties of a Signature.
         * @memberof crypto
         * @interface ISignature
         * @property {Uint8Array|null} [ed25519] Signature ed25519
         */

        /**
         * Constructs a new Signature.
         * @memberof crypto
         * @classdesc Represents a Signature.
         * @implements ISignature
         * @constructor
         * @param {crypto.ISignature=} [properties] Properties to set
         */
        function Signature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Signature ed25519.
         * @member {Uint8Array} ed25519
         * @memberof crypto.Signature
         * @instance
         */
        Signature.prototype.ed25519 = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Signature sig.
         * @member {"ed25519"|undefined} sig
         * @memberof crypto.Signature
         * @instance
         */
        Object.defineProperty(Signature.prototype, "sig", {
            get: $util.oneOfGetter($oneOfFields = ["ed25519"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Signature instance using the specified properties.
         * @function create
         * @memberof crypto.Signature
         * @static
         * @param {crypto.ISignature=} [properties] Properties to set
         * @returns {crypto.Signature} Signature instance
         */
        Signature.create = function create(properties) {
            return new Signature(properties);
        };

        /**
         * Encodes the specified Signature message. Does not implicitly {@link crypto.Signature.verify|verify} messages.
         * @function encode
         * @memberof crypto.Signature
         * @static
         * @param {crypto.ISignature} message Signature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ed25519 != null && message.hasOwnProperty("ed25519"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ed25519);
            return writer;
        };

        /**
         * Encodes the specified Signature message, length delimited. Does not implicitly {@link crypto.Signature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof crypto.Signature
         * @static
         * @param {crypto.ISignature} message Signature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Signature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Signature message from the specified reader or buffer.
         * @function decode
         * @memberof crypto.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {crypto.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.crypto.Signature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ed25519 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Signature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof crypto.Signature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {crypto.Signature} Signature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Signature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Signature message.
         * @function verify
         * @memberof crypto.Signature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Signature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                properties.sig = 1;
                if (!(message.ed25519 && typeof message.ed25519.length === "number" || $util.isString(message.ed25519)))
                    return "ed25519: buffer expected";
            }
            return null;
        };

        /**
         * Creates a Signature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof crypto.Signature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {crypto.Signature} Signature
         */
        Signature.fromObject = function fromObject(object) {
            if (object instanceof $root.crypto.Signature)
                return object;
            var message = new $root.crypto.Signature();
            if (object.ed25519 != null)
                if (typeof object.ed25519 === "string")
                    $util.base64.decode(object.ed25519, message.ed25519 = $util.newBuffer($util.base64.length(object.ed25519)), 0);
                else if (object.ed25519.length)
                    message.ed25519 = object.ed25519;
            return message;
        };

        /**
         * Creates a plain object from a Signature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof crypto.Signature
         * @static
         * @param {crypto.Signature} message Signature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Signature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.ed25519 != null && message.hasOwnProperty("ed25519")) {
                object.ed25519 = options.bytes === String ? $util.base64.encode(message.ed25519, 0, message.ed25519.length) : options.bytes === Array ? Array.prototype.slice.call(message.ed25519) : message.ed25519;
                if (options.oneofs)
                    object.sig = "ed25519";
            }
            return object;
        };

        /**
         * Converts this Signature to JSON.
         * @function toJSON
         * @memberof crypto.Signature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Signature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Signature;
    })();

    return crypto;
})();

$root.migration = (function() {

    /**
     * Namespace migration.
     * @exports migration
     * @namespace
     */
    var migration = {};

    migration.Configuration = (function() {

        /**
         * Properties of a Configuration.
         * @memberof migration
         * @interface IConfiguration
         * @property {Uint8Array|null} [admin] multisig.
         */

        /**
         * Constructs a new Configuration.
         * @memberof migration
         * @classdesc Represents a Configuration.
         * @implements IConfiguration
         * @constructor
         * @param {migration.IConfiguration=} [properties] Properties to set
         */
        function Configuration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * multisig.
         * @member {Uint8Array} admin
         * @memberof migration.Configuration
         * @instance
         */
        Configuration.prototype.admin = $util.newBuffer([]);

        /**
         * Creates a new Configuration instance using the specified properties.
         * @function create
         * @memberof migration.Configuration
         * @static
         * @param {migration.IConfiguration=} [properties] Properties to set
         * @returns {migration.Configuration} Configuration instance
         */
        Configuration.create = function create(properties) {
            return new Configuration(properties);
        };

        /**
         * Encodes the specified Configuration message. Does not implicitly {@link migration.Configuration.verify|verify} messages.
         * @function encode
         * @memberof migration.Configuration
         * @static
         * @param {migration.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.admin);
            return writer;
        };

        /**
         * Encodes the specified Configuration message, length delimited. Does not implicitly {@link migration.Configuration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof migration.Configuration
         * @static
         * @param {migration.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer.
         * @function decode
         * @memberof migration.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {migration.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.migration.Configuration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.admin = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof migration.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {migration.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Configuration message.
         * @function verify
         * @memberof migration.Configuration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Configuration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            return null;
        };

        /**
         * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof migration.Configuration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {migration.Configuration} Configuration
         */
        Configuration.fromObject = function fromObject(object) {
            if (object instanceof $root.migration.Configuration)
                return object;
            var message = new $root.migration.Configuration();
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            return message;
        };

        /**
         * Creates a plain object from a Configuration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof migration.Configuration
         * @static
         * @param {migration.Configuration} message Configuration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Configuration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            return object;
        };

        /**
         * Converts this Configuration to JSON.
         * @function toJSON
         * @memberof migration.Configuration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Configuration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Configuration;
    })();

    migration.Schema = (function() {

        /**
         * Properties of a Schema.
         * @memberof migration
         * @interface ISchema
         * @property {weave.IMetadata|null} [metadata] Schema metadata
         * @property {string|null} [pkg] For example, for extension `x/myext` package value is `myext`
         * @property {number|null} [version] Version holds the highest supported schema version.
         */

        /**
         * Constructs a new Schema.
         * @memberof migration
         * @classdesc Schema declares the maxiumum supported schema version for a package.
         * @implements ISchema
         * @constructor
         * @param {migration.ISchema=} [properties] Properties to set
         */
        function Schema(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Schema metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof migration.Schema
         * @instance
         */
        Schema.prototype.metadata = null;

        /**
         * For example, for extension `x/myext` package value is `myext`
         * @member {string} pkg
         * @memberof migration.Schema
         * @instance
         */
        Schema.prototype.pkg = "";

        /**
         * Version holds the highest supported schema version.
         * @member {number} version
         * @memberof migration.Schema
         * @instance
         */
        Schema.prototype.version = 0;

        /**
         * Creates a new Schema instance using the specified properties.
         * @function create
         * @memberof migration.Schema
         * @static
         * @param {migration.ISchema=} [properties] Properties to set
         * @returns {migration.Schema} Schema instance
         */
        Schema.create = function create(properties) {
            return new Schema(properties);
        };

        /**
         * Encodes the specified Schema message. Does not implicitly {@link migration.Schema.verify|verify} messages.
         * @function encode
         * @memberof migration.Schema
         * @static
         * @param {migration.ISchema} message Schema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Schema.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pkg);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified Schema message, length delimited. Does not implicitly {@link migration.Schema.verify|verify} messages.
         * @function encodeDelimited
         * @memberof migration.Schema
         * @static
         * @param {migration.ISchema} message Schema message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Schema.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Schema message from the specified reader or buffer.
         * @function decode
         * @memberof migration.Schema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {migration.Schema} Schema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Schema.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.migration.Schema();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pkg = reader.string();
                    break;
                case 3:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Schema message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof migration.Schema
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {migration.Schema} Schema
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Schema.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Schema message.
         * @function verify
         * @memberof migration.Schema
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Schema.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                if (!$util.isString(message.pkg))
                    return "pkg: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates a Schema message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof migration.Schema
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {migration.Schema} Schema
         */
        Schema.fromObject = function fromObject(object) {
            if (object instanceof $root.migration.Schema)
                return object;
            var message = new $root.migration.Schema();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".migration.Schema.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.pkg != null)
                message.pkg = String(object.pkg);
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Schema message. Also converts values to other types if specified.
         * @function toObject
         * @memberof migration.Schema
         * @static
         * @param {migration.Schema} message Schema
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Schema.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.pkg = "";
                object.version = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                object.pkg = message.pkg;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this Schema to JSON.
         * @function toJSON
         * @memberof migration.Schema
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Schema.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Schema;
    })();

    migration.UpgradeSchemaMsg = (function() {

        /**
         * Properties of an UpgradeSchemaMsg.
         * @memberof migration
         * @interface IUpgradeSchemaMsg
         * @property {weave.IMetadata|null} [metadata] UpgradeSchemaMsg metadata
         * @property {string|null} [pkg] Name of the package that schema version upgrade is made for.
         */

        /**
         * Constructs a new UpgradeSchemaMsg.
         * @memberof migration
         * @classdesc by one version.
         * @implements IUpgradeSchemaMsg
         * @constructor
         * @param {migration.IUpgradeSchemaMsg=} [properties] Properties to set
         */
        function UpgradeSchemaMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpgradeSchemaMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof migration.UpgradeSchemaMsg
         * @instance
         */
        UpgradeSchemaMsg.prototype.metadata = null;

        /**
         * Name of the package that schema version upgrade is made for.
         * @member {string} pkg
         * @memberof migration.UpgradeSchemaMsg
         * @instance
         */
        UpgradeSchemaMsg.prototype.pkg = "";

        /**
         * Creates a new UpgradeSchemaMsg instance using the specified properties.
         * @function create
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {migration.IUpgradeSchemaMsg=} [properties] Properties to set
         * @returns {migration.UpgradeSchemaMsg} UpgradeSchemaMsg instance
         */
        UpgradeSchemaMsg.create = function create(properties) {
            return new UpgradeSchemaMsg(properties);
        };

        /**
         * Encodes the specified UpgradeSchemaMsg message. Does not implicitly {@link migration.UpgradeSchemaMsg.verify|verify} messages.
         * @function encode
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {migration.IUpgradeSchemaMsg} message UpgradeSchemaMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpgradeSchemaMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pkg);
            return writer;
        };

        /**
         * Encodes the specified UpgradeSchemaMsg message, length delimited. Does not implicitly {@link migration.UpgradeSchemaMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {migration.IUpgradeSchemaMsg} message UpgradeSchemaMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpgradeSchemaMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpgradeSchemaMsg message from the specified reader or buffer.
         * @function decode
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {migration.UpgradeSchemaMsg} UpgradeSchemaMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpgradeSchemaMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.migration.UpgradeSchemaMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pkg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpgradeSchemaMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {migration.UpgradeSchemaMsg} UpgradeSchemaMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpgradeSchemaMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpgradeSchemaMsg message.
         * @function verify
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpgradeSchemaMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                if (!$util.isString(message.pkg))
                    return "pkg: string expected";
            return null;
        };

        /**
         * Creates an UpgradeSchemaMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {migration.UpgradeSchemaMsg} UpgradeSchemaMsg
         */
        UpgradeSchemaMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.migration.UpgradeSchemaMsg)
                return object;
            var message = new $root.migration.UpgradeSchemaMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".migration.UpgradeSchemaMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.pkg != null)
                message.pkg = String(object.pkg);
            return message;
        };

        /**
         * Creates a plain object from an UpgradeSchemaMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof migration.UpgradeSchemaMsg
         * @static
         * @param {migration.UpgradeSchemaMsg} message UpgradeSchemaMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpgradeSchemaMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.pkg = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.pkg != null && message.hasOwnProperty("pkg"))
                object.pkg = message.pkg;
            return object;
        };

        /**
         * Converts this UpgradeSchemaMsg to JSON.
         * @function toJSON
         * @memberof migration.UpgradeSchemaMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpgradeSchemaMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpgradeSchemaMsg;
    })();

    return migration;
})();

$root.orm = (function() {

    /**
     * Namespace orm.
     * @exports orm
     * @namespace
     */
    var orm = {};

    orm.MultiRef = (function() {

        /**
         * Properties of a MultiRef.
         * @memberof orm
         * @interface IMultiRef
         * @property {Array.<Uint8Array>|null} [refs] MultiRef refs
         */

        /**
         * Constructs a new MultiRef.
         * @memberof orm
         * @classdesc MultiRef contains a list of references to pks
         * @implements IMultiRef
         * @constructor
         * @param {orm.IMultiRef=} [properties] Properties to set
         */
        function MultiRef(properties) {
            this.refs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MultiRef refs.
         * @member {Array.<Uint8Array>} refs
         * @memberof orm.MultiRef
         * @instance
         */
        MultiRef.prototype.refs = $util.emptyArray;

        /**
         * Creates a new MultiRef instance using the specified properties.
         * @function create
         * @memberof orm.MultiRef
         * @static
         * @param {orm.IMultiRef=} [properties] Properties to set
         * @returns {orm.MultiRef} MultiRef instance
         */
        MultiRef.create = function create(properties) {
            return new MultiRef(properties);
        };

        /**
         * Encodes the specified MultiRef message. Does not implicitly {@link orm.MultiRef.verify|verify} messages.
         * @function encode
         * @memberof orm.MultiRef
         * @static
         * @param {orm.IMultiRef} message MultiRef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiRef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.refs != null && message.refs.length)
                for (var i = 0; i < message.refs.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.refs[i]);
            return writer;
        };

        /**
         * Encodes the specified MultiRef message, length delimited. Does not implicitly {@link orm.MultiRef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof orm.MultiRef
         * @static
         * @param {orm.IMultiRef} message MultiRef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiRef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MultiRef message from the specified reader or buffer.
         * @function decode
         * @memberof orm.MultiRef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {orm.MultiRef} MultiRef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiRef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orm.MultiRef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.refs && message.refs.length))
                        message.refs = [];
                    message.refs.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MultiRef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof orm.MultiRef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {orm.MultiRef} MultiRef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiRef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MultiRef message.
         * @function verify
         * @memberof orm.MultiRef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MultiRef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.refs != null && message.hasOwnProperty("refs")) {
                if (!Array.isArray(message.refs))
                    return "refs: array expected";
                for (var i = 0; i < message.refs.length; ++i)
                    if (!(message.refs[i] && typeof message.refs[i].length === "number" || $util.isString(message.refs[i])))
                        return "refs: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a MultiRef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof orm.MultiRef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {orm.MultiRef} MultiRef
         */
        MultiRef.fromObject = function fromObject(object) {
            if (object instanceof $root.orm.MultiRef)
                return object;
            var message = new $root.orm.MultiRef();
            if (object.refs) {
                if (!Array.isArray(object.refs))
                    throw TypeError(".orm.MultiRef.refs: array expected");
                message.refs = [];
                for (var i = 0; i < object.refs.length; ++i)
                    if (typeof object.refs[i] === "string")
                        $util.base64.decode(object.refs[i], message.refs[i] = $util.newBuffer($util.base64.length(object.refs[i])), 0);
                    else if (object.refs[i].length)
                        message.refs[i] = object.refs[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a MultiRef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof orm.MultiRef
         * @static
         * @param {orm.MultiRef} message MultiRef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MultiRef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.refs = [];
            if (message.refs && message.refs.length) {
                object.refs = [];
                for (var j = 0; j < message.refs.length; ++j)
                    object.refs[j] = options.bytes === String ? $util.base64.encode(message.refs[j], 0, message.refs[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.refs[j]) : message.refs[j];
            }
            return object;
        };

        /**
         * Converts this MultiRef to JSON.
         * @function toJSON
         * @memberof orm.MultiRef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MultiRef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MultiRef;
    })();

    orm.Counter = (function() {

        /**
         * Properties of a Counter.
         * @memberof orm
         * @interface ICounter
         * @property {number|Long|null} [count] Counter count
         */

        /**
         * Constructs a new Counter.
         * @memberof orm
         * @classdesc Counter could be used for sequence, but mainly just for test
         * @implements ICounter
         * @constructor
         * @param {orm.ICounter=} [properties] Properties to set
         */
        function Counter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Counter count.
         * @member {number|Long} count
         * @memberof orm.Counter
         * @instance
         */
        Counter.prototype.count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Counter instance using the specified properties.
         * @function create
         * @memberof orm.Counter
         * @static
         * @param {orm.ICounter=} [properties] Properties to set
         * @returns {orm.Counter} Counter instance
         */
        Counter.create = function create(properties) {
            return new Counter(properties);
        };

        /**
         * Encodes the specified Counter message. Does not implicitly {@link orm.Counter.verify|verify} messages.
         * @function encode
         * @memberof orm.Counter
         * @static
         * @param {orm.ICounter} message Counter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Counter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.count);
            return writer;
        };

        /**
         * Encodes the specified Counter message, length delimited. Does not implicitly {@link orm.Counter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof orm.Counter
         * @static
         * @param {orm.ICounter} message Counter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Counter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Counter message from the specified reader or buffer.
         * @function decode
         * @memberof orm.Counter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {orm.Counter} Counter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Counter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orm.Counter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Counter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof orm.Counter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {orm.Counter} Counter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Counter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Counter message.
         * @function verify
         * @memberof orm.Counter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Counter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                    return "count: integer|Long expected";
            return null;
        };

        /**
         * Creates a Counter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof orm.Counter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {orm.Counter} Counter
         */
        Counter.fromObject = function fromObject(object) {
            if (object instanceof $root.orm.Counter)
                return object;
            var message = new $root.orm.Counter();
            if (object.count != null)
                if ($util.Long)
                    (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                else if (typeof object.count === "string")
                    message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number")
                    message.count = object.count;
                else if (typeof object.count === "object")
                    message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Counter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof orm.Counter
         * @static
         * @param {orm.Counter} message Counter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Counter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.count = options.longs === String ? "0" : 0;
            if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                    object.count = options.longs === String ? String(message.count) : message.count;
                else
                    object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
            return object;
        };

        /**
         * Converts this Counter to JSON.
         * @function toJSON
         * @memberof orm.Counter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Counter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Counter;
    })();

    orm.VersionedIDRef = (function() {

        /**
         * Properties of a VersionedIDRef.
         * @memberof orm
         * @interface IVersionedIDRef
         * @property {Uint8Array|null} [id] Unique identifier
         * @property {number|null} [version] Document version, starting with 1.
         */

        /**
         * Constructs a new VersionedIDRef.
         * @memberof orm
         * @classdesc VersionedID is the combination of document ID and version number.
         * @implements IVersionedIDRef
         * @constructor
         * @param {orm.IVersionedIDRef=} [properties] Properties to set
         */
        function VersionedIDRef(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Unique identifier
         * @member {Uint8Array} id
         * @memberof orm.VersionedIDRef
         * @instance
         */
        VersionedIDRef.prototype.id = $util.newBuffer([]);

        /**
         * Document version, starting with 1.
         * @member {number} version
         * @memberof orm.VersionedIDRef
         * @instance
         */
        VersionedIDRef.prototype.version = 0;

        /**
         * Creates a new VersionedIDRef instance using the specified properties.
         * @function create
         * @memberof orm.VersionedIDRef
         * @static
         * @param {orm.IVersionedIDRef=} [properties] Properties to set
         * @returns {orm.VersionedIDRef} VersionedIDRef instance
         */
        VersionedIDRef.create = function create(properties) {
            return new VersionedIDRef(properties);
        };

        /**
         * Encodes the specified VersionedIDRef message. Does not implicitly {@link orm.VersionedIDRef.verify|verify} messages.
         * @function encode
         * @memberof orm.VersionedIDRef
         * @static
         * @param {orm.IVersionedIDRef} message VersionedIDRef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionedIDRef.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.id);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.version);
            return writer;
        };

        /**
         * Encodes the specified VersionedIDRef message, length delimited. Does not implicitly {@link orm.VersionedIDRef.verify|verify} messages.
         * @function encodeDelimited
         * @memberof orm.VersionedIDRef
         * @static
         * @param {orm.IVersionedIDRef} message VersionedIDRef message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VersionedIDRef.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VersionedIDRef message from the specified reader or buffer.
         * @function decode
         * @memberof orm.VersionedIDRef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {orm.VersionedIDRef} VersionedIDRef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionedIDRef.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.orm.VersionedIDRef();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 4:
                    message.id = reader.bytes();
                    break;
                case 5:
                    message.version = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VersionedIDRef message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof orm.VersionedIDRef
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {orm.VersionedIDRef} VersionedIDRef
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VersionedIDRef.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VersionedIDRef message.
         * @function verify
         * @memberof orm.VersionedIDRef
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VersionedIDRef.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            return null;
        };

        /**
         * Creates a VersionedIDRef message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof orm.VersionedIDRef
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {orm.VersionedIDRef} VersionedIDRef
         */
        VersionedIDRef.fromObject = function fromObject(object) {
            if (object instanceof $root.orm.VersionedIDRef)
                return object;
            var message = new $root.orm.VersionedIDRef();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.version != null)
                message.version = object.version >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a VersionedIDRef message. Also converts values to other types if specified.
         * @function toObject
         * @memberof orm.VersionedIDRef
         * @static
         * @param {orm.VersionedIDRef} message VersionedIDRef
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VersionedIDRef.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                object.version = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            return object;
        };

        /**
         * Converts this VersionedIDRef to JSON.
         * @function toJSON
         * @memberof orm.VersionedIDRef
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VersionedIDRef.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VersionedIDRef;
    })();

    return orm;
})();

$root.aswap = (function() {

    /**
     * Namespace aswap.
     * @exports aswap
     * @namespace
     */
    var aswap = {};

    aswap.Swap = (function() {

        /**
         * Properties of a Swap.
         * @memberof aswap
         * @interface ISwap
         * @property {weave.IMetadata|null} [metadata] metadata is used for schema versioning support
         * @property {Uint8Array|null} [preimageHash] sha256 hash of preimage, 32 bytes long
         * @property {Uint8Array|null} [src] src is a sender address
         * @property {Uint8Array|null} [recipient] recipient is an address of recipient
         * @property {number|Long|null} [timeout] expired: [timeout, infinity)
         * @property {string|null} [memo] max length 128 characters
         */

        /**
         * Constructs a new Swap.
         * @memberof aswap
         * @classdesc Swap is designed to hold some coins for atomic swap, locked by preimage_hash
         * @implements ISwap
         * @constructor
         * @param {aswap.ISwap=} [properties] Properties to set
         */
        function Swap(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * metadata is used for schema versioning support
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.metadata = null;

        /**
         * sha256 hash of preimage, 32 bytes long
         * @member {Uint8Array} preimageHash
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.preimageHash = $util.newBuffer([]);

        /**
         * src is a sender address
         * @member {Uint8Array} src
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.src = $util.newBuffer([]);

        /**
         * recipient is an address of recipient
         * @member {Uint8Array} recipient
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.recipient = $util.newBuffer([]);

        /**
         * expired: [timeout, infinity)
         * @member {number|Long} timeout
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * max length 128 characters
         * @member {string} memo
         * @memberof aswap.Swap
         * @instance
         */
        Swap.prototype.memo = "";

        /**
         * Creates a new Swap instance using the specified properties.
         * @function create
         * @memberof aswap.Swap
         * @static
         * @param {aswap.ISwap=} [properties] Properties to set
         * @returns {aswap.Swap} Swap instance
         */
        Swap.create = function create(properties) {
            return new Swap(properties);
        };

        /**
         * Encodes the specified Swap message. Does not implicitly {@link aswap.Swap.verify|verify} messages.
         * @function encode
         * @memberof aswap.Swap
         * @static
         * @param {aswap.ISwap} message Swap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Swap.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.preimageHash);
            if (message.src != null && message.hasOwnProperty("src"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.src);
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.recipient);
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified Swap message, length delimited. Does not implicitly {@link aswap.Swap.verify|verify} messages.
         * @function encodeDelimited
         * @memberof aswap.Swap
         * @static
         * @param {aswap.ISwap} message Swap message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Swap.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Swap message from the specified reader or buffer.
         * @function decode
         * @memberof aswap.Swap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {aswap.Swap} Swap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Swap.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.aswap.Swap();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.preimageHash = reader.bytes();
                    break;
                case 3:
                    message.src = reader.bytes();
                    break;
                case 5:
                    message.recipient = reader.bytes();
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Swap message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof aswap.Swap
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {aswap.Swap} Swap
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Swap.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Swap message.
         * @function verify
         * @memberof aswap.Swap
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Swap.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                if (!(message.preimageHash && typeof message.preimageHash.length === "number" || $util.isString(message.preimageHash)))
                    return "preimageHash: buffer expected";
            if (message.src != null && message.hasOwnProperty("src"))
                if (!(message.src && typeof message.src.length === "number" || $util.isString(message.src)))
                    return "src: buffer expected";
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a Swap message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof aswap.Swap
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {aswap.Swap} Swap
         */
        Swap.fromObject = function fromObject(object) {
            if (object instanceof $root.aswap.Swap)
                return object;
            var message = new $root.aswap.Swap();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".aswap.Swap.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.preimageHash != null)
                if (typeof object.preimageHash === "string")
                    $util.base64.decode(object.preimageHash, message.preimageHash = $util.newBuffer($util.base64.length(object.preimageHash)), 0);
                else if (object.preimageHash.length)
                    message.preimageHash = object.preimageHash;
            if (object.src != null)
                if (typeof object.src === "string")
                    $util.base64.decode(object.src, message.src = $util.newBuffer($util.base64.length(object.src)), 0);
                else if (object.src.length)
                    message.src = object.src;
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a Swap message. Also converts values to other types if specified.
         * @function toObject
         * @memberof aswap.Swap
         * @static
         * @param {aswap.Swap} message Swap
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Swap.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.preimageHash = "";
                else {
                    object.preimageHash = [];
                    if (options.bytes !== Array)
                        object.preimageHash = $util.newBuffer(object.preimageHash);
                }
                if (options.bytes === String)
                    object.src = "";
                else {
                    object.src = [];
                    if (options.bytes !== Array)
                        object.src = $util.newBuffer(object.src);
                }
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                object.preimageHash = options.bytes === String ? $util.base64.encode(message.preimageHash, 0, message.preimageHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.preimageHash) : message.preimageHash;
            if (message.src != null && message.hasOwnProperty("src"))
                object.src = options.bytes === String ? $util.base64.encode(message.src, 0, message.src.length) : options.bytes === Array ? Array.prototype.slice.call(message.src) : message.src;
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this Swap to JSON.
         * @function toJSON
         * @memberof aswap.Swap
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Swap.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Swap;
    })();

    aswap.CreateSwapMsg = (function() {

        /**
         * Properties of a CreateSwapMsg.
         * @memberof aswap
         * @interface ICreateSwapMsg
         * @property {weave.IMetadata|null} [metadata] CreateSwapMsg metadata
         * @property {Uint8Array|null} [src] CreateSwapMsg src
         * @property {Uint8Array|null} [preimageHash] sha256 hash of preimage, 32 bytes long
         * @property {Uint8Array|null} [recipient] CreateSwapMsg recipient
         * @property {Array.<coin.ICoin>|null} [amount] amount may contain multiple token types
         * @property {number|Long|null} [timeout] Timeout represents wall clock time.
         * @property {string|null} [memo] max length 128 character
         */

        /**
         * Constructs a new CreateSwapMsg.
         * @memberof aswap
         * @classdesc CreateSwapMsg creates a Swap with some coins.
         * @implements ICreateSwapMsg
         * @constructor
         * @param {aswap.ICreateSwapMsg=} [properties] Properties to set
         */
        function CreateSwapMsg(properties) {
            this.amount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateSwapMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof aswap.CreateSwapMsg
         * @instance
         */
        CreateSwapMsg.prototype.metadata = null;

        /**
         * CreateSwapMsg src.
         * @member {Uint8Array} src
         * @memberof aswap.CreateSwapMsg
         * @instance
         */
        CreateSwapMsg.prototype.src = $util.newBuffer([]);

        /**
         * sha256 hash of preimage, 32 bytes long
         * @member {Uint8Array} preimageHash
         * @memberof aswap.CreateSwapMsg
         * @instance
         */
        CreateSwapMsg.prototype.preimageHash = $util.newBuffer([]);

        /**
         * CreateSwapMsg recipient.
         * @member {Uint8Array} recipient
         * @memberof aswap.CreateSwapMsg
         * @instance
         */
        CreateSwapMsg.prototype.recipient = $util.newBuffer([]);

        /**
         * amount may contain multiple token types
         * @member {Array.<coin.ICoin>} amount
         * @memberof aswap.CreateSwapMsg
         * @instance
         */
        CreateSwapMsg.prototype.amount = $util.emptyArray;

        /**
         * Timeout represents wall clock time.
         * @member {number|Long} timeout
         * @memberof aswap.CreateSwapMsg
         * @instance
         */
        CreateSwapMsg.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * max length 128 character
         * @member {string} memo
         * @memberof aswap.CreateSwapMsg
         * @instance
         */
        CreateSwapMsg.prototype.memo = "";

        /**
         * Creates a new CreateSwapMsg instance using the specified properties.
         * @function create
         * @memberof aswap.CreateSwapMsg
         * @static
         * @param {aswap.ICreateSwapMsg=} [properties] Properties to set
         * @returns {aswap.CreateSwapMsg} CreateSwapMsg instance
         */
        CreateSwapMsg.create = function create(properties) {
            return new CreateSwapMsg(properties);
        };

        /**
         * Encodes the specified CreateSwapMsg message. Does not implicitly {@link aswap.CreateSwapMsg.verify|verify} messages.
         * @function encode
         * @memberof aswap.CreateSwapMsg
         * @static
         * @param {aswap.ICreateSwapMsg} message CreateSwapMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateSwapMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.src != null && message.hasOwnProperty("src"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.src);
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.preimageHash);
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.recipient);
            if (message.amount != null && message.amount.length)
                for (var i = 0; i < message.amount.length; ++i)
                    $root.coin.Coin.encode(message.amount[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified CreateSwapMsg message, length delimited. Does not implicitly {@link aswap.CreateSwapMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof aswap.CreateSwapMsg
         * @static
         * @param {aswap.ICreateSwapMsg} message CreateSwapMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateSwapMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateSwapMsg message from the specified reader or buffer.
         * @function decode
         * @memberof aswap.CreateSwapMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {aswap.CreateSwapMsg} CreateSwapMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateSwapMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.aswap.CreateSwapMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.src = reader.bytes();
                    break;
                case 3:
                    message.preimageHash = reader.bytes();
                    break;
                case 4:
                    message.recipient = reader.bytes();
                    break;
                case 5:
                    if (!(message.amount && message.amount.length))
                        message.amount = [];
                    message.amount.push($root.coin.Coin.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateSwapMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof aswap.CreateSwapMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {aswap.CreateSwapMsg} CreateSwapMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateSwapMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateSwapMsg message.
         * @function verify
         * @memberof aswap.CreateSwapMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateSwapMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.src != null && message.hasOwnProperty("src"))
                if (!(message.src && typeof message.src.length === "number" || $util.isString(message.src)))
                    return "src: buffer expected";
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                if (!(message.preimageHash && typeof message.preimageHash.length === "number" || $util.isString(message.preimageHash)))
                    return "preimageHash: buffer expected";
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                if (!Array.isArray(message.amount))
                    return "amount: array expected";
                for (var i = 0; i < message.amount.length; ++i) {
                    var error = $root.coin.Coin.verify(message.amount[i]);
                    if (error)
                        return "amount." + error;
                }
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a CreateSwapMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof aswap.CreateSwapMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {aswap.CreateSwapMsg} CreateSwapMsg
         */
        CreateSwapMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.aswap.CreateSwapMsg)
                return object;
            var message = new $root.aswap.CreateSwapMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".aswap.CreateSwapMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.src != null)
                if (typeof object.src === "string")
                    $util.base64.decode(object.src, message.src = $util.newBuffer($util.base64.length(object.src)), 0);
                else if (object.src.length)
                    message.src = object.src;
            if (object.preimageHash != null)
                if (typeof object.preimageHash === "string")
                    $util.base64.decode(object.preimageHash, message.preimageHash = $util.newBuffer($util.base64.length(object.preimageHash)), 0);
                else if (object.preimageHash.length)
                    message.preimageHash = object.preimageHash;
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.amount) {
                if (!Array.isArray(object.amount))
                    throw TypeError(".aswap.CreateSwapMsg.amount: array expected");
                message.amount = [];
                for (var i = 0; i < object.amount.length; ++i) {
                    if (typeof object.amount[i] !== "object")
                        throw TypeError(".aswap.CreateSwapMsg.amount: object expected");
                    message.amount[i] = $root.coin.Coin.fromObject(object.amount[i]);
                }
            }
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a CreateSwapMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof aswap.CreateSwapMsg
         * @static
         * @param {aswap.CreateSwapMsg} message CreateSwapMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateSwapMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.amount = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.src = "";
                else {
                    object.src = [];
                    if (options.bytes !== Array)
                        object.src = $util.newBuffer(object.src);
                }
                if (options.bytes === String)
                    object.preimageHash = "";
                else {
                    object.preimageHash = [];
                    if (options.bytes !== Array)
                        object.preimageHash = $util.newBuffer(object.preimageHash);
                }
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.src != null && message.hasOwnProperty("src"))
                object.src = options.bytes === String ? $util.base64.encode(message.src, 0, message.src.length) : options.bytes === Array ? Array.prototype.slice.call(message.src) : message.src;
            if (message.preimageHash != null && message.hasOwnProperty("preimageHash"))
                object.preimageHash = options.bytes === String ? $util.base64.encode(message.preimageHash, 0, message.preimageHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.preimageHash) : message.preimageHash;
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.amount && message.amount.length) {
                object.amount = [];
                for (var j = 0; j < message.amount.length; ++j)
                    object.amount[j] = $root.coin.Coin.toObject(message.amount[j], options);
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this CreateSwapMsg to JSON.
         * @function toJSON
         * @memberof aswap.CreateSwapMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateSwapMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateSwapMsg;
    })();

    aswap.ReleaseSwapMsg = (function() {

        /**
         * Properties of a ReleaseSwapMsg.
         * @memberof aswap
         * @interface IReleaseSwapMsg
         * @property {weave.IMetadata|null} [metadata] ReleaseSwapMsg metadata
         * @property {Uint8Array|null} [swapId] swap_id to release
         * @property {Uint8Array|null} [preimage] must be exactly 32 bytes long
         */

        /**
         * Constructs a new ReleaseSwapMsg.
         * @memberof aswap
         * @classdesc This operation is authorized by preimage, which is sent raw and then hashed on the backend.
         * @implements IReleaseSwapMsg
         * @constructor
         * @param {aswap.IReleaseSwapMsg=} [properties] Properties to set
         */
        function ReleaseSwapMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReleaseSwapMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof aswap.ReleaseSwapMsg
         * @instance
         */
        ReleaseSwapMsg.prototype.metadata = null;

        /**
         * swap_id to release
         * @member {Uint8Array} swapId
         * @memberof aswap.ReleaseSwapMsg
         * @instance
         */
        ReleaseSwapMsg.prototype.swapId = $util.newBuffer([]);

        /**
         * must be exactly 32 bytes long
         * @member {Uint8Array} preimage
         * @memberof aswap.ReleaseSwapMsg
         * @instance
         */
        ReleaseSwapMsg.prototype.preimage = $util.newBuffer([]);

        /**
         * Creates a new ReleaseSwapMsg instance using the specified properties.
         * @function create
         * @memberof aswap.ReleaseSwapMsg
         * @static
         * @param {aswap.IReleaseSwapMsg=} [properties] Properties to set
         * @returns {aswap.ReleaseSwapMsg} ReleaseSwapMsg instance
         */
        ReleaseSwapMsg.create = function create(properties) {
            return new ReleaseSwapMsg(properties);
        };

        /**
         * Encodes the specified ReleaseSwapMsg message. Does not implicitly {@link aswap.ReleaseSwapMsg.verify|verify} messages.
         * @function encode
         * @memberof aswap.ReleaseSwapMsg
         * @static
         * @param {aswap.IReleaseSwapMsg} message ReleaseSwapMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseSwapMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.swapId);
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.preimage);
            return writer;
        };

        /**
         * Encodes the specified ReleaseSwapMsg message, length delimited. Does not implicitly {@link aswap.ReleaseSwapMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof aswap.ReleaseSwapMsg
         * @static
         * @param {aswap.IReleaseSwapMsg} message ReleaseSwapMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseSwapMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReleaseSwapMsg message from the specified reader or buffer.
         * @function decode
         * @memberof aswap.ReleaseSwapMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {aswap.ReleaseSwapMsg} ReleaseSwapMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseSwapMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.aswap.ReleaseSwapMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.swapId = reader.bytes();
                    break;
                case 3:
                    message.preimage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReleaseSwapMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof aswap.ReleaseSwapMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {aswap.ReleaseSwapMsg} ReleaseSwapMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseSwapMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReleaseSwapMsg message.
         * @function verify
         * @memberof aswap.ReleaseSwapMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReleaseSwapMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                if (!(message.swapId && typeof message.swapId.length === "number" || $util.isString(message.swapId)))
                    return "swapId: buffer expected";
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                if (!(message.preimage && typeof message.preimage.length === "number" || $util.isString(message.preimage)))
                    return "preimage: buffer expected";
            return null;
        };

        /**
         * Creates a ReleaseSwapMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof aswap.ReleaseSwapMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {aswap.ReleaseSwapMsg} ReleaseSwapMsg
         */
        ReleaseSwapMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.aswap.ReleaseSwapMsg)
                return object;
            var message = new $root.aswap.ReleaseSwapMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".aswap.ReleaseSwapMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.swapId != null)
                if (typeof object.swapId === "string")
                    $util.base64.decode(object.swapId, message.swapId = $util.newBuffer($util.base64.length(object.swapId)), 0);
                else if (object.swapId.length)
                    message.swapId = object.swapId;
            if (object.preimage != null)
                if (typeof object.preimage === "string")
                    $util.base64.decode(object.preimage, message.preimage = $util.newBuffer($util.base64.length(object.preimage)), 0);
                else if (object.preimage.length)
                    message.preimage = object.preimage;
            return message;
        };

        /**
         * Creates a plain object from a ReleaseSwapMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof aswap.ReleaseSwapMsg
         * @static
         * @param {aswap.ReleaseSwapMsg} message ReleaseSwapMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReleaseSwapMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.swapId = "";
                else {
                    object.swapId = [];
                    if (options.bytes !== Array)
                        object.swapId = $util.newBuffer(object.swapId);
                }
                if (options.bytes === String)
                    object.preimage = "";
                else {
                    object.preimage = [];
                    if (options.bytes !== Array)
                        object.preimage = $util.newBuffer(object.preimage);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                object.swapId = options.bytes === String ? $util.base64.encode(message.swapId, 0, message.swapId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swapId) : message.swapId;
            if (message.preimage != null && message.hasOwnProperty("preimage"))
                object.preimage = options.bytes === String ? $util.base64.encode(message.preimage, 0, message.preimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.preimage) : message.preimage;
            return object;
        };

        /**
         * Converts this ReleaseSwapMsg to JSON.
         * @function toJSON
         * @memberof aswap.ReleaseSwapMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReleaseSwapMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReleaseSwapMsg;
    })();

    aswap.ReturnSwapMsg = (function() {

        /**
         * Properties of a ReturnSwapMsg.
         * @memberof aswap
         * @interface IReturnSwapMsg
         * @property {weave.IMetadata|null} [metadata] ReturnSwapMsg metadata
         * @property {Uint8Array|null} [swapId] swap_id to return
         */

        /**
         * Constructs a new ReturnSwapMsg.
         * @memberof aswap
         * @classdesc This operation only works if the Swap is expired.
         * @implements IReturnSwapMsg
         * @constructor
         * @param {aswap.IReturnSwapMsg=} [properties] Properties to set
         */
        function ReturnSwapMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReturnSwapMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof aswap.ReturnSwapMsg
         * @instance
         */
        ReturnSwapMsg.prototype.metadata = null;

        /**
         * swap_id to return
         * @member {Uint8Array} swapId
         * @memberof aswap.ReturnSwapMsg
         * @instance
         */
        ReturnSwapMsg.prototype.swapId = $util.newBuffer([]);

        /**
         * Creates a new ReturnSwapMsg instance using the specified properties.
         * @function create
         * @memberof aswap.ReturnSwapMsg
         * @static
         * @param {aswap.IReturnSwapMsg=} [properties] Properties to set
         * @returns {aswap.ReturnSwapMsg} ReturnSwapMsg instance
         */
        ReturnSwapMsg.create = function create(properties) {
            return new ReturnSwapMsg(properties);
        };

        /**
         * Encodes the specified ReturnSwapMsg message. Does not implicitly {@link aswap.ReturnSwapMsg.verify|verify} messages.
         * @function encode
         * @memberof aswap.ReturnSwapMsg
         * @static
         * @param {aswap.IReturnSwapMsg} message ReturnSwapMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnSwapMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.swapId);
            return writer;
        };

        /**
         * Encodes the specified ReturnSwapMsg message, length delimited. Does not implicitly {@link aswap.ReturnSwapMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof aswap.ReturnSwapMsg
         * @static
         * @param {aswap.IReturnSwapMsg} message ReturnSwapMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnSwapMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReturnSwapMsg message from the specified reader or buffer.
         * @function decode
         * @memberof aswap.ReturnSwapMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {aswap.ReturnSwapMsg} ReturnSwapMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnSwapMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.aswap.ReturnSwapMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.swapId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReturnSwapMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof aswap.ReturnSwapMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {aswap.ReturnSwapMsg} ReturnSwapMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnSwapMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReturnSwapMsg message.
         * @function verify
         * @memberof aswap.ReturnSwapMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReturnSwapMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                if (!(message.swapId && typeof message.swapId.length === "number" || $util.isString(message.swapId)))
                    return "swapId: buffer expected";
            return null;
        };

        /**
         * Creates a ReturnSwapMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof aswap.ReturnSwapMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {aswap.ReturnSwapMsg} ReturnSwapMsg
         */
        ReturnSwapMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.aswap.ReturnSwapMsg)
                return object;
            var message = new $root.aswap.ReturnSwapMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".aswap.ReturnSwapMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.swapId != null)
                if (typeof object.swapId === "string")
                    $util.base64.decode(object.swapId, message.swapId = $util.newBuffer($util.base64.length(object.swapId)), 0);
                else if (object.swapId.length)
                    message.swapId = object.swapId;
            return message;
        };

        /**
         * Creates a plain object from a ReturnSwapMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof aswap.ReturnSwapMsg
         * @static
         * @param {aswap.ReturnSwapMsg} message ReturnSwapMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReturnSwapMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.swapId = "";
                else {
                    object.swapId = [];
                    if (options.bytes !== Array)
                        object.swapId = $util.newBuffer(object.swapId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.swapId != null && message.hasOwnProperty("swapId"))
                object.swapId = options.bytes === String ? $util.base64.encode(message.swapId, 0, message.swapId.length) : options.bytes === Array ? Array.prototype.slice.call(message.swapId) : message.swapId;
            return object;
        };

        /**
         * Converts this ReturnSwapMsg to JSON.
         * @function toJSON
         * @memberof aswap.ReturnSwapMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReturnSwapMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReturnSwapMsg;
    })();

    return aswap;
})();

$root.batch = (function() {

    /**
     * Namespace batch.
     * @exports batch
     * @namespace
     */
    var batch = {};

    batch.ByteArrayList = (function() {

        /**
         * Properties of a ByteArrayList.
         * @memberof batch
         * @interface IByteArrayList
         * @property {Array.<Uint8Array>|null} [elements] ByteArrayList elements
         */

        /**
         * Constructs a new ByteArrayList.
         * @memberof batch
         * @classdesc Represents a ByteArrayList.
         * @implements IByteArrayList
         * @constructor
         * @param {batch.IByteArrayList=} [properties] Properties to set
         */
        function ByteArrayList(properties) {
            this.elements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ByteArrayList elements.
         * @member {Array.<Uint8Array>} elements
         * @memberof batch.ByteArrayList
         * @instance
         */
        ByteArrayList.prototype.elements = $util.emptyArray;

        /**
         * Creates a new ByteArrayList instance using the specified properties.
         * @function create
         * @memberof batch.ByteArrayList
         * @static
         * @param {batch.IByteArrayList=} [properties] Properties to set
         * @returns {batch.ByteArrayList} ByteArrayList instance
         */
        ByteArrayList.create = function create(properties) {
            return new ByteArrayList(properties);
        };

        /**
         * Encodes the specified ByteArrayList message. Does not implicitly {@link batch.ByteArrayList.verify|verify} messages.
         * @function encode
         * @memberof batch.ByteArrayList
         * @static
         * @param {batch.IByteArrayList} message ByteArrayList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ByteArrayList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elements != null && message.elements.length)
                for (var i = 0; i < message.elements.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.elements[i]);
            return writer;
        };

        /**
         * Encodes the specified ByteArrayList message, length delimited. Does not implicitly {@link batch.ByteArrayList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof batch.ByteArrayList
         * @static
         * @param {batch.IByteArrayList} message ByteArrayList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ByteArrayList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ByteArrayList message from the specified reader or buffer.
         * @function decode
         * @memberof batch.ByteArrayList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {batch.ByteArrayList} ByteArrayList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ByteArrayList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.batch.ByteArrayList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.elements && message.elements.length))
                        message.elements = [];
                    message.elements.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ByteArrayList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof batch.ByteArrayList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {batch.ByteArrayList} ByteArrayList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ByteArrayList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ByteArrayList message.
         * @function verify
         * @memberof batch.ByteArrayList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ByteArrayList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elements != null && message.hasOwnProperty("elements")) {
                if (!Array.isArray(message.elements))
                    return "elements: array expected";
                for (var i = 0; i < message.elements.length; ++i)
                    if (!(message.elements[i] && typeof message.elements[i].length === "number" || $util.isString(message.elements[i])))
                        return "elements: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a ByteArrayList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof batch.ByteArrayList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {batch.ByteArrayList} ByteArrayList
         */
        ByteArrayList.fromObject = function fromObject(object) {
            if (object instanceof $root.batch.ByteArrayList)
                return object;
            var message = new $root.batch.ByteArrayList();
            if (object.elements) {
                if (!Array.isArray(object.elements))
                    throw TypeError(".batch.ByteArrayList.elements: array expected");
                message.elements = [];
                for (var i = 0; i < object.elements.length; ++i)
                    if (typeof object.elements[i] === "string")
                        $util.base64.decode(object.elements[i], message.elements[i] = $util.newBuffer($util.base64.length(object.elements[i])), 0);
                    else if (object.elements[i].length)
                        message.elements[i] = object.elements[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a ByteArrayList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof batch.ByteArrayList
         * @static
         * @param {batch.ByteArrayList} message ByteArrayList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ByteArrayList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.elements = [];
            if (message.elements && message.elements.length) {
                object.elements = [];
                for (var j = 0; j < message.elements.length; ++j)
                    object.elements[j] = options.bytes === String ? $util.base64.encode(message.elements[j], 0, message.elements[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.elements[j]) : message.elements[j];
            }
            return object;
        };

        /**
         * Converts this ByteArrayList to JSON.
         * @function toJSON
         * @memberof batch.ByteArrayList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ByteArrayList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ByteArrayList;
    })();

    return batch;
})();

$root.cash = (function() {

    /**
     * Namespace cash.
     * @exports cash
     * @namespace
     */
    var cash = {};

    cash.Set = (function() {

        /**
         * Properties of a Set.
         * @memberof cash
         * @interface ISet
         * @property {weave.IMetadata|null} [metadata] Set metadata
         * @property {Array.<coin.ICoin>|null} [coins] Set coins
         */

        /**
         * Constructs a new Set.
         * @memberof cash
         * @classdesc It handles adding and subtracting sets of currencies.
         * @implements ISet
         * @constructor
         * @param {cash.ISet=} [properties] Properties to set
         */
        function Set(properties) {
            this.coins = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Set metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof cash.Set
         * @instance
         */
        Set.prototype.metadata = null;

        /**
         * Set coins.
         * @member {Array.<coin.ICoin>} coins
         * @memberof cash.Set
         * @instance
         */
        Set.prototype.coins = $util.emptyArray;

        /**
         * Creates a new Set instance using the specified properties.
         * @function create
         * @memberof cash.Set
         * @static
         * @param {cash.ISet=} [properties] Properties to set
         * @returns {cash.Set} Set instance
         */
        Set.create = function create(properties) {
            return new Set(properties);
        };

        /**
         * Encodes the specified Set message. Does not implicitly {@link cash.Set.verify|verify} messages.
         * @function encode
         * @memberof cash.Set
         * @static
         * @param {cash.ISet} message Set message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Set.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.coins != null && message.coins.length)
                for (var i = 0; i < message.coins.length; ++i)
                    $root.coin.Coin.encode(message.coins[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Set message, length delimited. Does not implicitly {@link cash.Set.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.Set
         * @static
         * @param {cash.ISet} message Set message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Set.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Set message from the specified reader or buffer.
         * @function decode
         * @memberof cash.Set
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.Set} Set
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Set.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.Set();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.coins && message.coins.length))
                        message.coins = [];
                    message.coins.push($root.coin.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Set message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.Set
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.Set} Set
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Set.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Set message.
         * @function verify
         * @memberof cash.Set
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Set.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.coins != null && message.hasOwnProperty("coins")) {
                if (!Array.isArray(message.coins))
                    return "coins: array expected";
                for (var i = 0; i < message.coins.length; ++i) {
                    var error = $root.coin.Coin.verify(message.coins[i]);
                    if (error)
                        return "coins." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Set message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.Set
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.Set} Set
         */
        Set.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.Set)
                return object;
            var message = new $root.cash.Set();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".cash.Set.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.coins) {
                if (!Array.isArray(object.coins))
                    throw TypeError(".cash.Set.coins: array expected");
                message.coins = [];
                for (var i = 0; i < object.coins.length; ++i) {
                    if (typeof object.coins[i] !== "object")
                        throw TypeError(".cash.Set.coins: object expected");
                    message.coins[i] = $root.coin.Coin.fromObject(object.coins[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Set message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.Set
         * @static
         * @param {cash.Set} message Set
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Set.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.coins = [];
            if (options.defaults)
                object.metadata = null;
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.coins && message.coins.length) {
                object.coins = [];
                for (var j = 0; j < message.coins.length; ++j)
                    object.coins[j] = $root.coin.Coin.toObject(message.coins[j], options);
            }
            return object;
        };

        /**
         * Converts this Set to JSON.
         * @function toJSON
         * @memberof cash.Set
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Set.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Set;
    })();

    cash.SendMsg = (function() {

        /**
         * Properties of a SendMsg.
         * @memberof cash
         * @interface ISendMsg
         * @property {weave.IMetadata|null} [metadata] SendMsg metadata
         * @property {Uint8Array|null} [src] SendMsg src
         * @property {Uint8Array|null} [dest] SendMsg dest
         * @property {coin.ICoin|null} [amount] SendMsg amount
         * @property {string|null} [memo] max length 128 character
         * @property {Uint8Array|null} [ref] max length 64 bytes
         */

        /**
         * Constructs a new SendMsg.
         * @memberof cash
         * @classdesc eg. tx hash
         * @implements ISendMsg
         * @constructor
         * @param {cash.ISendMsg=} [properties] Properties to set
         */
        function SendMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.metadata = null;

        /**
         * SendMsg src.
         * @member {Uint8Array} src
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.src = $util.newBuffer([]);

        /**
         * SendMsg dest.
         * @member {Uint8Array} dest
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.dest = $util.newBuffer([]);

        /**
         * SendMsg amount.
         * @member {coin.ICoin|null|undefined} amount
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.amount = null;

        /**
         * max length 128 character
         * @member {string} memo
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.memo = "";

        /**
         * max length 64 bytes
         * @member {Uint8Array} ref
         * @memberof cash.SendMsg
         * @instance
         */
        SendMsg.prototype.ref = $util.newBuffer([]);

        /**
         * Creates a new SendMsg instance using the specified properties.
         * @function create
         * @memberof cash.SendMsg
         * @static
         * @param {cash.ISendMsg=} [properties] Properties to set
         * @returns {cash.SendMsg} SendMsg instance
         */
        SendMsg.create = function create(properties) {
            return new SendMsg(properties);
        };

        /**
         * Encodes the specified SendMsg message. Does not implicitly {@link cash.SendMsg.verify|verify} messages.
         * @function encode
         * @memberof cash.SendMsg
         * @static
         * @param {cash.ISendMsg} message SendMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.src != null && message.hasOwnProperty("src"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.src);
            if (message.dest != null && message.hasOwnProperty("dest"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.dest);
            if (message.amount != null && message.hasOwnProperty("amount"))
                $root.coin.Coin.encode(message.amount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.memo);
            if (message.ref != null && message.hasOwnProperty("ref"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.ref);
            return writer;
        };

        /**
         * Encodes the specified SendMsg message, length delimited. Does not implicitly {@link cash.SendMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.SendMsg
         * @static
         * @param {cash.ISendMsg} message SendMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendMsg message from the specified reader or buffer.
         * @function decode
         * @memberof cash.SendMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.SendMsg} SendMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.SendMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.src = reader.bytes();
                    break;
                case 3:
                    message.dest = reader.bytes();
                    break;
                case 4:
                    message.amount = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.memo = reader.string();
                    break;
                case 6:
                    message.ref = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.SendMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.SendMsg} SendMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendMsg message.
         * @function verify
         * @memberof cash.SendMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.src != null && message.hasOwnProperty("src"))
                if (!(message.src && typeof message.src.length === "number" || $util.isString(message.src)))
                    return "src: buffer expected";
            if (message.dest != null && message.hasOwnProperty("dest"))
                if (!(message.dest && typeof message.dest.length === "number" || $util.isString(message.dest)))
                    return "dest: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                var error = $root.coin.Coin.verify(message.amount);
                if (error)
                    return "amount." + error;
            }
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.ref != null && message.hasOwnProperty("ref"))
                if (!(message.ref && typeof message.ref.length === "number" || $util.isString(message.ref)))
                    return "ref: buffer expected";
            return null;
        };

        /**
         * Creates a SendMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.SendMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.SendMsg} SendMsg
         */
        SendMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.SendMsg)
                return object;
            var message = new $root.cash.SendMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".cash.SendMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.src != null)
                if (typeof object.src === "string")
                    $util.base64.decode(object.src, message.src = $util.newBuffer($util.base64.length(object.src)), 0);
                else if (object.src.length)
                    message.src = object.src;
            if (object.dest != null)
                if (typeof object.dest === "string")
                    $util.base64.decode(object.dest, message.dest = $util.newBuffer($util.base64.length(object.dest)), 0);
                else if (object.dest.length)
                    message.dest = object.dest;
            if (object.amount != null) {
                if (typeof object.amount !== "object")
                    throw TypeError(".cash.SendMsg.amount: object expected");
                message.amount = $root.coin.Coin.fromObject(object.amount);
            }
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.ref != null)
                if (typeof object.ref === "string")
                    $util.base64.decode(object.ref, message.ref = $util.newBuffer($util.base64.length(object.ref)), 0);
                else if (object.ref.length)
                    message.ref = object.ref;
            return message;
        };

        /**
         * Creates a plain object from a SendMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.SendMsg
         * @static
         * @param {cash.SendMsg} message SendMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.src = "";
                else {
                    object.src = [];
                    if (options.bytes !== Array)
                        object.src = $util.newBuffer(object.src);
                }
                if (options.bytes === String)
                    object.dest = "";
                else {
                    object.dest = [];
                    if (options.bytes !== Array)
                        object.dest = $util.newBuffer(object.dest);
                }
                object.amount = null;
                object.memo = "";
                if (options.bytes === String)
                    object.ref = "";
                else {
                    object.ref = [];
                    if (options.bytes !== Array)
                        object.ref = $util.newBuffer(object.ref);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.src != null && message.hasOwnProperty("src"))
                object.src = options.bytes === String ? $util.base64.encode(message.src, 0, message.src.length) : options.bytes === Array ? Array.prototype.slice.call(message.src) : message.src;
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = options.bytes === String ? $util.base64.encode(message.dest, 0, message.dest.length) : options.bytes === Array ? Array.prototype.slice.call(message.dest) : message.dest;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = $root.coin.Coin.toObject(message.amount, options);
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.ref != null && message.hasOwnProperty("ref"))
                object.ref = options.bytes === String ? $util.base64.encode(message.ref, 0, message.ref.length) : options.bytes === Array ? Array.prototype.slice.call(message.ref) : message.ref;
            return object;
        };

        /**
         * Converts this SendMsg to JSON.
         * @function toJSON
         * @memberof cash.SendMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendMsg;
    })();

    cash.FeeInfo = (function() {

        /**
         * Properties of a FeeInfo.
         * @memberof cash
         * @interface IFeeInfo
         * @property {weave.IMetadata|null} [metadata] FeeInfo metadata
         * @property {Uint8Array|null} [payer] FeeInfo payer
         * @property {coin.ICoin|null} [fees] FeeInfo fees
         */

        /**
         * Constructs a new FeeInfo.
         * @memberof cash
         * @classdesc message processed
         * @implements IFeeInfo
         * @constructor
         * @param {cash.IFeeInfo=} [properties] Properties to set
         */
        function FeeInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeeInfo metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof cash.FeeInfo
         * @instance
         */
        FeeInfo.prototype.metadata = null;

        /**
         * FeeInfo payer.
         * @member {Uint8Array} payer
         * @memberof cash.FeeInfo
         * @instance
         */
        FeeInfo.prototype.payer = $util.newBuffer([]);

        /**
         * FeeInfo fees.
         * @member {coin.ICoin|null|undefined} fees
         * @memberof cash.FeeInfo
         * @instance
         */
        FeeInfo.prototype.fees = null;

        /**
         * Creates a new FeeInfo instance using the specified properties.
         * @function create
         * @memberof cash.FeeInfo
         * @static
         * @param {cash.IFeeInfo=} [properties] Properties to set
         * @returns {cash.FeeInfo} FeeInfo instance
         */
        FeeInfo.create = function create(properties) {
            return new FeeInfo(properties);
        };

        /**
         * Encodes the specified FeeInfo message. Does not implicitly {@link cash.FeeInfo.verify|verify} messages.
         * @function encode
         * @memberof cash.FeeInfo
         * @static
         * @param {cash.IFeeInfo} message FeeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.payer != null && message.hasOwnProperty("payer"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payer);
            if (message.fees != null && message.hasOwnProperty("fees"))
                $root.coin.Coin.encode(message.fees, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeeInfo message, length delimited. Does not implicitly {@link cash.FeeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.FeeInfo
         * @static
         * @param {cash.IFeeInfo} message FeeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof cash.FeeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.FeeInfo} FeeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.FeeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.payer = reader.bytes();
                    break;
                case 3:
                    message.fees = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.FeeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.FeeInfo} FeeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeInfo message.
         * @function verify
         * @memberof cash.FeeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.payer != null && message.hasOwnProperty("payer"))
                if (!(message.payer && typeof message.payer.length === "number" || $util.isString(message.payer)))
                    return "payer: buffer expected";
            if (message.fees != null && message.hasOwnProperty("fees")) {
                var error = $root.coin.Coin.verify(message.fees);
                if (error)
                    return "fees." + error;
            }
            return null;
        };

        /**
         * Creates a FeeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.FeeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.FeeInfo} FeeInfo
         */
        FeeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.FeeInfo)
                return object;
            var message = new $root.cash.FeeInfo();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".cash.FeeInfo.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.payer != null)
                if (typeof object.payer === "string")
                    $util.base64.decode(object.payer, message.payer = $util.newBuffer($util.base64.length(object.payer)), 0);
                else if (object.payer.length)
                    message.payer = object.payer;
            if (object.fees != null) {
                if (typeof object.fees !== "object")
                    throw TypeError(".cash.FeeInfo.fees: object expected");
                message.fees = $root.coin.Coin.fromObject(object.fees);
            }
            return message;
        };

        /**
         * Creates a plain object from a FeeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.FeeInfo
         * @static
         * @param {cash.FeeInfo} message FeeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.payer = "";
                else {
                    object.payer = [];
                    if (options.bytes !== Array)
                        object.payer = $util.newBuffer(object.payer);
                }
                object.fees = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.payer != null && message.hasOwnProperty("payer"))
                object.payer = options.bytes === String ? $util.base64.encode(message.payer, 0, message.payer.length) : options.bytes === Array ? Array.prototype.slice.call(message.payer) : message.payer;
            if (message.fees != null && message.hasOwnProperty("fees"))
                object.fees = $root.coin.Coin.toObject(message.fees, options);
            return object;
        };

        /**
         * Converts this FeeInfo to JSON.
         * @function toJSON
         * @memberof cash.FeeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeInfo;
    })();

    cash.Configuration = (function() {

        /**
         * Properties of a Configuration.
         * @memberof cash
         * @interface IConfiguration
         * @property {Uint8Array|null} [owner] TODO: add schema uint32 here
         * @property {Uint8Array|null} [collectorAddress] Configuration collectorAddress
         * @property {coin.ICoin|null} [minimalFee] Configuration minimalFee
         */

        /**
         * Constructs a new Configuration.
         * @memberof cash
         * @classdesc Represents a Configuration.
         * @implements IConfiguration
         * @constructor
         * @param {cash.IConfiguration=} [properties] Properties to set
         */
        function Configuration(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TODO: add schema uint32 here
         * @member {Uint8Array} owner
         * @memberof cash.Configuration
         * @instance
         */
        Configuration.prototype.owner = $util.newBuffer([]);

        /**
         * Configuration collectorAddress.
         * @member {Uint8Array} collectorAddress
         * @memberof cash.Configuration
         * @instance
         */
        Configuration.prototype.collectorAddress = $util.newBuffer([]);

        /**
         * Configuration minimalFee.
         * @member {coin.ICoin|null|undefined} minimalFee
         * @memberof cash.Configuration
         * @instance
         */
        Configuration.prototype.minimalFee = null;

        /**
         * Creates a new Configuration instance using the specified properties.
         * @function create
         * @memberof cash.Configuration
         * @static
         * @param {cash.IConfiguration=} [properties] Properties to set
         * @returns {cash.Configuration} Configuration instance
         */
        Configuration.create = function create(properties) {
            return new Configuration(properties);
        };

        /**
         * Encodes the specified Configuration message. Does not implicitly {@link cash.Configuration.verify|verify} messages.
         * @function encode
         * @memberof cash.Configuration
         * @static
         * @param {cash.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.owner);
            if (message.collectorAddress != null && message.hasOwnProperty("collectorAddress"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.collectorAddress);
            if (message.minimalFee != null && message.hasOwnProperty("minimalFee"))
                $root.coin.Coin.encode(message.minimalFee, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Configuration message, length delimited. Does not implicitly {@link cash.Configuration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.Configuration
         * @static
         * @param {cash.IConfiguration} message Configuration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Configuration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer.
         * @function decode
         * @memberof cash.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.Configuration();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.owner = reader.bytes();
                    break;
                case 3:
                    message.collectorAddress = reader.bytes();
                    break;
                case 4:
                    message.minimalFee = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Configuration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.Configuration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.Configuration} Configuration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Configuration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Configuration message.
         * @function verify
         * @memberof cash.Configuration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Configuration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                    return "owner: buffer expected";
            if (message.collectorAddress != null && message.hasOwnProperty("collectorAddress"))
                if (!(message.collectorAddress && typeof message.collectorAddress.length === "number" || $util.isString(message.collectorAddress)))
                    return "collectorAddress: buffer expected";
            if (message.minimalFee != null && message.hasOwnProperty("minimalFee")) {
                var error = $root.coin.Coin.verify(message.minimalFee);
                if (error)
                    return "minimalFee." + error;
            }
            return null;
        };

        /**
         * Creates a Configuration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.Configuration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.Configuration} Configuration
         */
        Configuration.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.Configuration)
                return object;
            var message = new $root.cash.Configuration();
            if (object.owner != null)
                if (typeof object.owner === "string")
                    $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                else if (object.owner.length)
                    message.owner = object.owner;
            if (object.collectorAddress != null)
                if (typeof object.collectorAddress === "string")
                    $util.base64.decode(object.collectorAddress, message.collectorAddress = $util.newBuffer($util.base64.length(object.collectorAddress)), 0);
                else if (object.collectorAddress.length)
                    message.collectorAddress = object.collectorAddress;
            if (object.minimalFee != null) {
                if (typeof object.minimalFee !== "object")
                    throw TypeError(".cash.Configuration.minimalFee: object expected");
                message.minimalFee = $root.coin.Coin.fromObject(object.minimalFee);
            }
            return message;
        };

        /**
         * Creates a plain object from a Configuration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.Configuration
         * @static
         * @param {cash.Configuration} message Configuration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Configuration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner = "";
                else {
                    object.owner = [];
                    if (options.bytes !== Array)
                        object.owner = $util.newBuffer(object.owner);
                }
                if (options.bytes === String)
                    object.collectorAddress = "";
                else {
                    object.collectorAddress = [];
                    if (options.bytes !== Array)
                        object.collectorAddress = $util.newBuffer(object.collectorAddress);
                }
                object.minimalFee = null;
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
            if (message.collectorAddress != null && message.hasOwnProperty("collectorAddress"))
                object.collectorAddress = options.bytes === String ? $util.base64.encode(message.collectorAddress, 0, message.collectorAddress.length) : options.bytes === Array ? Array.prototype.slice.call(message.collectorAddress) : message.collectorAddress;
            if (message.minimalFee != null && message.hasOwnProperty("minimalFee"))
                object.minimalFee = $root.coin.Coin.toObject(message.minimalFee, options);
            return object;
        };

        /**
         * Converts this Configuration to JSON.
         * @function toJSON
         * @memberof cash.Configuration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Configuration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Configuration;
    })();

    cash.ConfigurationMsg = (function() {

        /**
         * Properties of a ConfigurationMsg.
         * @memberof cash
         * @interface IConfigurationMsg
         * @property {cash.IConfiguration|null} [patch] TODO: add schema uint32 here
         */

        /**
         * Constructs a new ConfigurationMsg.
         * @memberof cash
         * @classdesc Represents a ConfigurationMsg.
         * @implements IConfigurationMsg
         * @constructor
         * @param {cash.IConfigurationMsg=} [properties] Properties to set
         */
        function ConfigurationMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TODO: add schema uint32 here
         * @member {cash.IConfiguration|null|undefined} patch
         * @memberof cash.ConfigurationMsg
         * @instance
         */
        ConfigurationMsg.prototype.patch = null;

        /**
         * Creates a new ConfigurationMsg instance using the specified properties.
         * @function create
         * @memberof cash.ConfigurationMsg
         * @static
         * @param {cash.IConfigurationMsg=} [properties] Properties to set
         * @returns {cash.ConfigurationMsg} ConfigurationMsg instance
         */
        ConfigurationMsg.create = function create(properties) {
            return new ConfigurationMsg(properties);
        };

        /**
         * Encodes the specified ConfigurationMsg message. Does not implicitly {@link cash.ConfigurationMsg.verify|verify} messages.
         * @function encode
         * @memberof cash.ConfigurationMsg
         * @static
         * @param {cash.IConfigurationMsg} message ConfigurationMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfigurationMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.patch != null && message.hasOwnProperty("patch"))
                $root.cash.Configuration.encode(message.patch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ConfigurationMsg message, length delimited. Does not implicitly {@link cash.ConfigurationMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof cash.ConfigurationMsg
         * @static
         * @param {cash.IConfigurationMsg} message ConfigurationMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfigurationMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConfigurationMsg message from the specified reader or buffer.
         * @function decode
         * @memberof cash.ConfigurationMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {cash.ConfigurationMsg} ConfigurationMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfigurationMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cash.ConfigurationMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.patch = $root.cash.Configuration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConfigurationMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof cash.ConfigurationMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {cash.ConfigurationMsg} ConfigurationMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfigurationMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConfigurationMsg message.
         * @function verify
         * @memberof cash.ConfigurationMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConfigurationMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.patch != null && message.hasOwnProperty("patch")) {
                var error = $root.cash.Configuration.verify(message.patch);
                if (error)
                    return "patch." + error;
            }
            return null;
        };

        /**
         * Creates a ConfigurationMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof cash.ConfigurationMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {cash.ConfigurationMsg} ConfigurationMsg
         */
        ConfigurationMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.cash.ConfigurationMsg)
                return object;
            var message = new $root.cash.ConfigurationMsg();
            if (object.patch != null) {
                if (typeof object.patch !== "object")
                    throw TypeError(".cash.ConfigurationMsg.patch: object expected");
                message.patch = $root.cash.Configuration.fromObject(object.patch);
            }
            return message;
        };

        /**
         * Creates a plain object from a ConfigurationMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof cash.ConfigurationMsg
         * @static
         * @param {cash.ConfigurationMsg} message ConfigurationMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfigurationMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.patch = null;
            if (message.patch != null && message.hasOwnProperty("patch"))
                object.patch = $root.cash.Configuration.toObject(message.patch, options);
            return object;
        };

        /**
         * Converts this ConfigurationMsg to JSON.
         * @function toJSON
         * @memberof cash.ConfigurationMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConfigurationMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConfigurationMsg;
    })();

    return cash;
})();

$root.currency = (function() {

    /**
     * Namespace currency.
     * @exports currency
     * @namespace
     */
    var currency = {};

    currency.TokenInfo = (function() {

        /**
         * Properties of a TokenInfo.
         * @memberof currency
         * @interface ITokenInfo
         * @property {weave.IMetadata|null} [metadata] TokenInfo metadata
         * @property {string|null} [name] TokenInfo name
         */

        /**
         * Constructs a new TokenInfo.
         * @memberof currency
         * @classdesc alternative solution to hardcoding supported currencies information.
         * @implements ITokenInfo
         * @constructor
         * @param {currency.ITokenInfo=} [properties] Properties to set
         */
        function TokenInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TokenInfo metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof currency.TokenInfo
         * @instance
         */
        TokenInfo.prototype.metadata = null;

        /**
         * TokenInfo name.
         * @member {string} name
         * @memberof currency.TokenInfo
         * @instance
         */
        TokenInfo.prototype.name = "";

        /**
         * Creates a new TokenInfo instance using the specified properties.
         * @function create
         * @memberof currency.TokenInfo
         * @static
         * @param {currency.ITokenInfo=} [properties] Properties to set
         * @returns {currency.TokenInfo} TokenInfo instance
         */
        TokenInfo.create = function create(properties) {
            return new TokenInfo(properties);
        };

        /**
         * Encodes the specified TokenInfo message. Does not implicitly {@link currency.TokenInfo.verify|verify} messages.
         * @function encode
         * @memberof currency.TokenInfo
         * @static
         * @param {currency.ITokenInfo} message TokenInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified TokenInfo message, length delimited. Does not implicitly {@link currency.TokenInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof currency.TokenInfo
         * @static
         * @param {currency.ITokenInfo} message TokenInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TokenInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TokenInfo message from the specified reader or buffer.
         * @function decode
         * @memberof currency.TokenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {currency.TokenInfo} TokenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.currency.TokenInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TokenInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof currency.TokenInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {currency.TokenInfo} TokenInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TokenInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TokenInfo message.
         * @function verify
         * @memberof currency.TokenInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TokenInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a TokenInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof currency.TokenInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {currency.TokenInfo} TokenInfo
         */
        TokenInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.currency.TokenInfo)
                return object;
            var message = new $root.currency.TokenInfo();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".currency.TokenInfo.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a TokenInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof currency.TokenInfo
         * @static
         * @param {currency.TokenInfo} message TokenInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TokenInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.name = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this TokenInfo to JSON.
         * @function toJSON
         * @memberof currency.TokenInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TokenInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TokenInfo;
    })();

    currency.NewTokenInfoMsg = (function() {

        /**
         * Properties of a NewTokenInfoMsg.
         * @memberof currency
         * @interface INewTokenInfoMsg
         * @property {weave.IMetadata|null} [metadata] NewTokenInfoMsg metadata
         * @property {string|null} [ticker] NewTokenInfoMsg ticker
         * @property {string|null} [name] NewTokenInfoMsg name
         */

        /**
         * Constructs a new NewTokenInfoMsg.
         * @memberof currency
         * @classdesc be registered only once.
         * @implements INewTokenInfoMsg
         * @constructor
         * @param {currency.INewTokenInfoMsg=} [properties] Properties to set
         */
        function NewTokenInfoMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewTokenInfoMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof currency.NewTokenInfoMsg
         * @instance
         */
        NewTokenInfoMsg.prototype.metadata = null;

        /**
         * NewTokenInfoMsg ticker.
         * @member {string} ticker
         * @memberof currency.NewTokenInfoMsg
         * @instance
         */
        NewTokenInfoMsg.prototype.ticker = "";

        /**
         * NewTokenInfoMsg name.
         * @member {string} name
         * @memberof currency.NewTokenInfoMsg
         * @instance
         */
        NewTokenInfoMsg.prototype.name = "";

        /**
         * Creates a new NewTokenInfoMsg instance using the specified properties.
         * @function create
         * @memberof currency.NewTokenInfoMsg
         * @static
         * @param {currency.INewTokenInfoMsg=} [properties] Properties to set
         * @returns {currency.NewTokenInfoMsg} NewTokenInfoMsg instance
         */
        NewTokenInfoMsg.create = function create(properties) {
            return new NewTokenInfoMsg(properties);
        };

        /**
         * Encodes the specified NewTokenInfoMsg message. Does not implicitly {@link currency.NewTokenInfoMsg.verify|verify} messages.
         * @function encode
         * @memberof currency.NewTokenInfoMsg
         * @static
         * @param {currency.INewTokenInfoMsg} message NewTokenInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewTokenInfoMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ticker);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified NewTokenInfoMsg message, length delimited. Does not implicitly {@link currency.NewTokenInfoMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof currency.NewTokenInfoMsg
         * @static
         * @param {currency.INewTokenInfoMsg} message NewTokenInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewTokenInfoMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewTokenInfoMsg message from the specified reader or buffer.
         * @function decode
         * @memberof currency.NewTokenInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {currency.NewTokenInfoMsg} NewTokenInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewTokenInfoMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.currency.NewTokenInfoMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ticker = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewTokenInfoMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof currency.NewTokenInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {currency.NewTokenInfoMsg} NewTokenInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewTokenInfoMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewTokenInfoMsg message.
         * @function verify
         * @memberof currency.NewTokenInfoMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewTokenInfoMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                if (!$util.isString(message.ticker))
                    return "ticker: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a NewTokenInfoMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof currency.NewTokenInfoMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {currency.NewTokenInfoMsg} NewTokenInfoMsg
         */
        NewTokenInfoMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.currency.NewTokenInfoMsg)
                return object;
            var message = new $root.currency.NewTokenInfoMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".currency.NewTokenInfoMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.ticker != null)
                message.ticker = String(object.ticker);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a NewTokenInfoMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof currency.NewTokenInfoMsg
         * @static
         * @param {currency.NewTokenInfoMsg} message NewTokenInfoMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewTokenInfoMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.ticker = "";
                object.name = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                object.ticker = message.ticker;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this NewTokenInfoMsg to JSON.
         * @function toJSON
         * @memberof currency.NewTokenInfoMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewTokenInfoMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewTokenInfoMsg;
    })();

    return currency;
})();

$root.distribution = (function() {

    /**
     * Namespace distribution.
     * @exports distribution
     * @namespace
     */
    var distribution = {};

    distribution.Revenue = (function() {

        /**
         * Properties of a Revenue.
         * @memberof distribution
         * @interface IRevenue
         * @property {weave.IMetadata|null} [metadata] Revenue metadata
         * @property {Uint8Array|null} [admin] While not enforced it is best to use a multisig contract here.
         * @property {Array.<distribution.IRecipient>|null} [recipients] distributed to. Must be at least one.
         */

        /**
         * Constructs a new Revenue.
         * @memberof distribution
         * @classdesc the owners.
         * @implements IRevenue
         * @constructor
         * @param {distribution.IRevenue=} [properties] Properties to set
         */
        function Revenue(properties) {
            this.recipients = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Revenue metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof distribution.Revenue
         * @instance
         */
        Revenue.prototype.metadata = null;

        /**
         * While not enforced it is best to use a multisig contract here.
         * @member {Uint8Array} admin
         * @memberof distribution.Revenue
         * @instance
         */
        Revenue.prototype.admin = $util.newBuffer([]);

        /**
         * distributed to. Must be at least one.
         * @member {Array.<distribution.IRecipient>} recipients
         * @memberof distribution.Revenue
         * @instance
         */
        Revenue.prototype.recipients = $util.emptyArray;

        /**
         * Creates a new Revenue instance using the specified properties.
         * @function create
         * @memberof distribution.Revenue
         * @static
         * @param {distribution.IRevenue=} [properties] Properties to set
         * @returns {distribution.Revenue} Revenue instance
         */
        Revenue.create = function create(properties) {
            return new Revenue(properties);
        };

        /**
         * Encodes the specified Revenue message. Does not implicitly {@link distribution.Revenue.verify|verify} messages.
         * @function encode
         * @memberof distribution.Revenue
         * @static
         * @param {distribution.IRevenue} message Revenue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Revenue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.admin);
            if (message.recipients != null && message.recipients.length)
                for (var i = 0; i < message.recipients.length; ++i)
                    $root.distribution.Recipient.encode(message.recipients[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Revenue message, length delimited. Does not implicitly {@link distribution.Revenue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.Revenue
         * @static
         * @param {distribution.IRevenue} message Revenue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Revenue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Revenue message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.Revenue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.Revenue} Revenue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Revenue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.Revenue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.admin = reader.bytes();
                    break;
                case 3:
                    if (!(message.recipients && message.recipients.length))
                        message.recipients = [];
                    message.recipients.push($root.distribution.Recipient.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Revenue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.Revenue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.Revenue} Revenue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Revenue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Revenue message.
         * @function verify
         * @memberof distribution.Revenue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Revenue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            if (message.recipients != null && message.hasOwnProperty("recipients")) {
                if (!Array.isArray(message.recipients))
                    return "recipients: array expected";
                for (var i = 0; i < message.recipients.length; ++i) {
                    var error = $root.distribution.Recipient.verify(message.recipients[i]);
                    if (error)
                        return "recipients." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Revenue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.Revenue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.Revenue} Revenue
         */
        Revenue.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.Revenue)
                return object;
            var message = new $root.distribution.Revenue();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".distribution.Revenue.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            if (object.recipients) {
                if (!Array.isArray(object.recipients))
                    throw TypeError(".distribution.Revenue.recipients: array expected");
                message.recipients = [];
                for (var i = 0; i < object.recipients.length; ++i) {
                    if (typeof object.recipients[i] !== "object")
                        throw TypeError(".distribution.Revenue.recipients: object expected");
                    message.recipients[i] = $root.distribution.Recipient.fromObject(object.recipients[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Revenue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.Revenue
         * @static
         * @param {distribution.Revenue} message Revenue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Revenue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.recipients = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            if (message.recipients && message.recipients.length) {
                object.recipients = [];
                for (var j = 0; j < message.recipients.length; ++j)
                    object.recipients[j] = $root.distribution.Recipient.toObject(message.recipients[j], options);
            }
            return object;
        };

        /**
         * Converts this Revenue to JSON.
         * @function toJSON
         * @memberof distribution.Revenue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Revenue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Revenue;
    })();

    distribution.Recipient = (function() {

        /**
         * Properties of a Recipient.
         * @memberof distribution
         * @interface IRecipient
         * @property {Uint8Array|null} [address] of the validators.
         * @property {number|null} [weight] second one.
         */

        /**
         * Constructs a new Recipient.
         * @memberof distribution
         * @classdesc Represents a Recipient.
         * @implements IRecipient
         * @constructor
         * @param {distribution.IRecipient=} [properties] Properties to set
         */
        function Recipient(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * of the validators.
         * @member {Uint8Array} address
         * @memberof distribution.Recipient
         * @instance
         */
        Recipient.prototype.address = $util.newBuffer([]);

        /**
         * second one.
         * @member {number} weight
         * @memberof distribution.Recipient
         * @instance
         */
        Recipient.prototype.weight = 0;

        /**
         * Creates a new Recipient instance using the specified properties.
         * @function create
         * @memberof distribution.Recipient
         * @static
         * @param {distribution.IRecipient=} [properties] Properties to set
         * @returns {distribution.Recipient} Recipient instance
         */
        Recipient.create = function create(properties) {
            return new Recipient(properties);
        };

        /**
         * Encodes the specified Recipient message. Does not implicitly {@link distribution.Recipient.verify|verify} messages.
         * @function encode
         * @memberof distribution.Recipient
         * @static
         * @param {distribution.IRecipient} message Recipient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Recipient.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.weight != null && message.hasOwnProperty("weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.weight);
            return writer;
        };

        /**
         * Encodes the specified Recipient message, length delimited. Does not implicitly {@link distribution.Recipient.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.Recipient
         * @static
         * @param {distribution.IRecipient} message Recipient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Recipient.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Recipient message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.Recipient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.Recipient} Recipient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Recipient.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.Recipient();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.weight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Recipient message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.Recipient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.Recipient} Recipient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Recipient.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Recipient message.
         * @function verify
         * @memberof distribution.Recipient
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Recipient.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight))
                    return "weight: integer expected";
            return null;
        };

        /**
         * Creates a Recipient message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.Recipient
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.Recipient} Recipient
         */
        Recipient.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.Recipient)
                return object;
            var message = new $root.distribution.Recipient();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.weight != null)
                message.weight = object.weight | 0;
            return message;
        };

        /**
         * Creates a plain object from a Recipient message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.Recipient
         * @static
         * @param {distribution.Recipient} message Recipient
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Recipient.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.weight = 0;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = message.weight;
            return object;
        };

        /**
         * Converts this Recipient to JSON.
         * @function toJSON
         * @memberof distribution.Recipient
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Recipient.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Recipient;
    })();

    distribution.NewRevenueMsg = (function() {

        /**
         * Properties of a NewRevenueMsg.
         * @memberof distribution
         * @interface INewRevenueMsg
         * @property {weave.IMetadata|null} [metadata] NewRevenueMsg metadata
         * @property {Uint8Array|null} [admin] While not enforced it is best to use a multisig contract here.
         * @property {Array.<distribution.IRecipient>|null} [recipients] distributed to. Must be at least one.
         */

        /**
         * Constructs a new NewRevenueMsg.
         * @memberof distribution
         * @classdesc NewRevenueMsg is issuing the creation of a new revenue stream instance.
         * @implements INewRevenueMsg
         * @constructor
         * @param {distribution.INewRevenueMsg=} [properties] Properties to set
         */
        function NewRevenueMsg(properties) {
            this.recipients = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewRevenueMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof distribution.NewRevenueMsg
         * @instance
         */
        NewRevenueMsg.prototype.metadata = null;

        /**
         * While not enforced it is best to use a multisig contract here.
         * @member {Uint8Array} admin
         * @memberof distribution.NewRevenueMsg
         * @instance
         */
        NewRevenueMsg.prototype.admin = $util.newBuffer([]);

        /**
         * distributed to. Must be at least one.
         * @member {Array.<distribution.IRecipient>} recipients
         * @memberof distribution.NewRevenueMsg
         * @instance
         */
        NewRevenueMsg.prototype.recipients = $util.emptyArray;

        /**
         * Creates a new NewRevenueMsg instance using the specified properties.
         * @function create
         * @memberof distribution.NewRevenueMsg
         * @static
         * @param {distribution.INewRevenueMsg=} [properties] Properties to set
         * @returns {distribution.NewRevenueMsg} NewRevenueMsg instance
         */
        NewRevenueMsg.create = function create(properties) {
            return new NewRevenueMsg(properties);
        };

        /**
         * Encodes the specified NewRevenueMsg message. Does not implicitly {@link distribution.NewRevenueMsg.verify|verify} messages.
         * @function encode
         * @memberof distribution.NewRevenueMsg
         * @static
         * @param {distribution.INewRevenueMsg} message NewRevenueMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewRevenueMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.admin);
            if (message.recipients != null && message.recipients.length)
                for (var i = 0; i < message.recipients.length; ++i)
                    $root.distribution.Recipient.encode(message.recipients[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NewRevenueMsg message, length delimited. Does not implicitly {@link distribution.NewRevenueMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.NewRevenueMsg
         * @static
         * @param {distribution.INewRevenueMsg} message NewRevenueMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewRevenueMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewRevenueMsg message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.NewRevenueMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.NewRevenueMsg} NewRevenueMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewRevenueMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.NewRevenueMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.admin = reader.bytes();
                    break;
                case 3:
                    if (!(message.recipients && message.recipients.length))
                        message.recipients = [];
                    message.recipients.push($root.distribution.Recipient.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewRevenueMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.NewRevenueMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.NewRevenueMsg} NewRevenueMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewRevenueMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewRevenueMsg message.
         * @function verify
         * @memberof distribution.NewRevenueMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewRevenueMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            if (message.recipients != null && message.hasOwnProperty("recipients")) {
                if (!Array.isArray(message.recipients))
                    return "recipients: array expected";
                for (var i = 0; i < message.recipients.length; ++i) {
                    var error = $root.distribution.Recipient.verify(message.recipients[i]);
                    if (error)
                        return "recipients." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NewRevenueMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.NewRevenueMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.NewRevenueMsg} NewRevenueMsg
         */
        NewRevenueMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.NewRevenueMsg)
                return object;
            var message = new $root.distribution.NewRevenueMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".distribution.NewRevenueMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            if (object.recipients) {
                if (!Array.isArray(object.recipients))
                    throw TypeError(".distribution.NewRevenueMsg.recipients: array expected");
                message.recipients = [];
                for (var i = 0; i < object.recipients.length; ++i) {
                    if (typeof object.recipients[i] !== "object")
                        throw TypeError(".distribution.NewRevenueMsg.recipients: object expected");
                    message.recipients[i] = $root.distribution.Recipient.fromObject(object.recipients[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NewRevenueMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.NewRevenueMsg
         * @static
         * @param {distribution.NewRevenueMsg} message NewRevenueMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewRevenueMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.recipients = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            if (message.recipients && message.recipients.length) {
                object.recipients = [];
                for (var j = 0; j < message.recipients.length; ++j)
                    object.recipients[j] = $root.distribution.Recipient.toObject(message.recipients[j], options);
            }
            return object;
        };

        /**
         * Converts this NewRevenueMsg to JSON.
         * @function toJSON
         * @memberof distribution.NewRevenueMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewRevenueMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewRevenueMsg;
    })();

    distribution.DistributeMsg = (function() {

        /**
         * Properties of a DistributeMsg.
         * @memberof distribution
         * @interface IDistributeMsg
         * @property {weave.IMetadata|null} [metadata] DistributeMsg metadata
         * @property {Uint8Array|null} [revenueId] should be distributed between recipients.
         */

        /**
         * Constructs a new DistributeMsg.
         * @memberof distribution
         * @classdesc signed using admin key.
         * @implements IDistributeMsg
         * @constructor
         * @param {distribution.IDistributeMsg=} [properties] Properties to set
         */
        function DistributeMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DistributeMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof distribution.DistributeMsg
         * @instance
         */
        DistributeMsg.prototype.metadata = null;

        /**
         * should be distributed between recipients.
         * @member {Uint8Array} revenueId
         * @memberof distribution.DistributeMsg
         * @instance
         */
        DistributeMsg.prototype.revenueId = $util.newBuffer([]);

        /**
         * Creates a new DistributeMsg instance using the specified properties.
         * @function create
         * @memberof distribution.DistributeMsg
         * @static
         * @param {distribution.IDistributeMsg=} [properties] Properties to set
         * @returns {distribution.DistributeMsg} DistributeMsg instance
         */
        DistributeMsg.create = function create(properties) {
            return new DistributeMsg(properties);
        };

        /**
         * Encodes the specified DistributeMsg message. Does not implicitly {@link distribution.DistributeMsg.verify|verify} messages.
         * @function encode
         * @memberof distribution.DistributeMsg
         * @static
         * @param {distribution.IDistributeMsg} message DistributeMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DistributeMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.revenueId);
            return writer;
        };

        /**
         * Encodes the specified DistributeMsg message, length delimited. Does not implicitly {@link distribution.DistributeMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.DistributeMsg
         * @static
         * @param {distribution.IDistributeMsg} message DistributeMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DistributeMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DistributeMsg message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.DistributeMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.DistributeMsg} DistributeMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DistributeMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.DistributeMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.revenueId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DistributeMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.DistributeMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.DistributeMsg} DistributeMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DistributeMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DistributeMsg message.
         * @function verify
         * @memberof distribution.DistributeMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DistributeMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                if (!(message.revenueId && typeof message.revenueId.length === "number" || $util.isString(message.revenueId)))
                    return "revenueId: buffer expected";
            return null;
        };

        /**
         * Creates a DistributeMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.DistributeMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.DistributeMsg} DistributeMsg
         */
        DistributeMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.DistributeMsg)
                return object;
            var message = new $root.distribution.DistributeMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".distribution.DistributeMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.revenueId != null)
                if (typeof object.revenueId === "string")
                    $util.base64.decode(object.revenueId, message.revenueId = $util.newBuffer($util.base64.length(object.revenueId)), 0);
                else if (object.revenueId.length)
                    message.revenueId = object.revenueId;
            return message;
        };

        /**
         * Creates a plain object from a DistributeMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.DistributeMsg
         * @static
         * @param {distribution.DistributeMsg} message DistributeMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DistributeMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.revenueId = "";
                else {
                    object.revenueId = [];
                    if (options.bytes !== Array)
                        object.revenueId = $util.newBuffer(object.revenueId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                object.revenueId = options.bytes === String ? $util.base64.encode(message.revenueId, 0, message.revenueId.length) : options.bytes === Array ? Array.prototype.slice.call(message.revenueId) : message.revenueId;
            return object;
        };

        /**
         * Converts this DistributeMsg to JSON.
         * @function toJSON
         * @memberof distribution.DistributeMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DistributeMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DistributeMsg;
    })();

    distribution.ResetRevenueMsg = (function() {

        /**
         * Properties of a ResetRevenueMsg.
         * @memberof distribution
         * @interface IResetRevenueMsg
         * @property {weave.IMetadata|null} [metadata] ResetRevenueMsg metadata
         * @property {Uint8Array|null} [revenueId] Revenue ID reference an ID of a revenue instance that is updated.
         * @property {Array.<distribution.IRecipient>|null} [recipients] distributed to. Must be at least one.
         */

        /**
         * Constructs a new ResetRevenueMsg.
         * @memberof distribution
         * @classdesc collected revenue amount is equal to zero the change is applied.
         * @implements IResetRevenueMsg
         * @constructor
         * @param {distribution.IResetRevenueMsg=} [properties] Properties to set
         */
        function ResetRevenueMsg(properties) {
            this.recipients = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResetRevenueMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof distribution.ResetRevenueMsg
         * @instance
         */
        ResetRevenueMsg.prototype.metadata = null;

        /**
         * Revenue ID reference an ID of a revenue instance that is updated.
         * @member {Uint8Array} revenueId
         * @memberof distribution.ResetRevenueMsg
         * @instance
         */
        ResetRevenueMsg.prototype.revenueId = $util.newBuffer([]);

        /**
         * distributed to. Must be at least one.
         * @member {Array.<distribution.IRecipient>} recipients
         * @memberof distribution.ResetRevenueMsg
         * @instance
         */
        ResetRevenueMsg.prototype.recipients = $util.emptyArray;

        /**
         * Creates a new ResetRevenueMsg instance using the specified properties.
         * @function create
         * @memberof distribution.ResetRevenueMsg
         * @static
         * @param {distribution.IResetRevenueMsg=} [properties] Properties to set
         * @returns {distribution.ResetRevenueMsg} ResetRevenueMsg instance
         */
        ResetRevenueMsg.create = function create(properties) {
            return new ResetRevenueMsg(properties);
        };

        /**
         * Encodes the specified ResetRevenueMsg message. Does not implicitly {@link distribution.ResetRevenueMsg.verify|verify} messages.
         * @function encode
         * @memberof distribution.ResetRevenueMsg
         * @static
         * @param {distribution.IResetRevenueMsg} message ResetRevenueMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetRevenueMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.revenueId);
            if (message.recipients != null && message.recipients.length)
                for (var i = 0; i < message.recipients.length; ++i)
                    $root.distribution.Recipient.encode(message.recipients[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResetRevenueMsg message, length delimited. Does not implicitly {@link distribution.ResetRevenueMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof distribution.ResetRevenueMsg
         * @static
         * @param {distribution.IResetRevenueMsg} message ResetRevenueMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResetRevenueMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResetRevenueMsg message from the specified reader or buffer.
         * @function decode
         * @memberof distribution.ResetRevenueMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {distribution.ResetRevenueMsg} ResetRevenueMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetRevenueMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.distribution.ResetRevenueMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.revenueId = reader.bytes();
                    break;
                case 3:
                    if (!(message.recipients && message.recipients.length))
                        message.recipients = [];
                    message.recipients.push($root.distribution.Recipient.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResetRevenueMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof distribution.ResetRevenueMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {distribution.ResetRevenueMsg} ResetRevenueMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResetRevenueMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResetRevenueMsg message.
         * @function verify
         * @memberof distribution.ResetRevenueMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResetRevenueMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                if (!(message.revenueId && typeof message.revenueId.length === "number" || $util.isString(message.revenueId)))
                    return "revenueId: buffer expected";
            if (message.recipients != null && message.hasOwnProperty("recipients")) {
                if (!Array.isArray(message.recipients))
                    return "recipients: array expected";
                for (var i = 0; i < message.recipients.length; ++i) {
                    var error = $root.distribution.Recipient.verify(message.recipients[i]);
                    if (error)
                        return "recipients." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ResetRevenueMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof distribution.ResetRevenueMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {distribution.ResetRevenueMsg} ResetRevenueMsg
         */
        ResetRevenueMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.distribution.ResetRevenueMsg)
                return object;
            var message = new $root.distribution.ResetRevenueMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".distribution.ResetRevenueMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.revenueId != null)
                if (typeof object.revenueId === "string")
                    $util.base64.decode(object.revenueId, message.revenueId = $util.newBuffer($util.base64.length(object.revenueId)), 0);
                else if (object.revenueId.length)
                    message.revenueId = object.revenueId;
            if (object.recipients) {
                if (!Array.isArray(object.recipients))
                    throw TypeError(".distribution.ResetRevenueMsg.recipients: array expected");
                message.recipients = [];
                for (var i = 0; i < object.recipients.length; ++i) {
                    if (typeof object.recipients[i] !== "object")
                        throw TypeError(".distribution.ResetRevenueMsg.recipients: object expected");
                    message.recipients[i] = $root.distribution.Recipient.fromObject(object.recipients[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ResetRevenueMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof distribution.ResetRevenueMsg
         * @static
         * @param {distribution.ResetRevenueMsg} message ResetRevenueMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResetRevenueMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.recipients = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.revenueId = "";
                else {
                    object.revenueId = [];
                    if (options.bytes !== Array)
                        object.revenueId = $util.newBuffer(object.revenueId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.revenueId != null && message.hasOwnProperty("revenueId"))
                object.revenueId = options.bytes === String ? $util.base64.encode(message.revenueId, 0, message.revenueId.length) : options.bytes === Array ? Array.prototype.slice.call(message.revenueId) : message.revenueId;
            if (message.recipients && message.recipients.length) {
                object.recipients = [];
                for (var j = 0; j < message.recipients.length; ++j)
                    object.recipients[j] = $root.distribution.Recipient.toObject(message.recipients[j], options);
            }
            return object;
        };

        /**
         * Converts this ResetRevenueMsg to JSON.
         * @function toJSON
         * @memberof distribution.ResetRevenueMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResetRevenueMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResetRevenueMsg;
    })();

    return distribution;
})();

$root.escrow = (function() {

    /**
     * Namespace escrow.
     * @exports escrow
     * @namespace
     */
    var escrow = {};

    escrow.Escrow = (function() {

        /**
         * Properties of an Escrow.
         * @memberof escrow
         * @interface IEscrow
         * @property {weave.IMetadata|null} [metadata] Escrow metadata
         * @property {Uint8Array|null} [sender] Escrow sender
         * @property {Uint8Array|null} [arbiter] Escrow arbiter
         * @property {Uint8Array|null} [recipient] Escrow recipient
         * @property {number|Long|null} [timeout] expired: [timeout, infinity)
         * @property {string|null} [memo] max length 128 character
         */

        /**
         * Constructs a new Escrow.
         * @memberof escrow
         * @classdesc an HTLC ;)
         * @implements IEscrow
         * @constructor
         * @param {escrow.IEscrow=} [properties] Properties to set
         */
        function Escrow(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Escrow metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.metadata = null;

        /**
         * Escrow sender.
         * @member {Uint8Array} sender
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.sender = $util.newBuffer([]);

        /**
         * Escrow arbiter.
         * @member {Uint8Array} arbiter
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.arbiter = $util.newBuffer([]);

        /**
         * Escrow recipient.
         * @member {Uint8Array} recipient
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.recipient = $util.newBuffer([]);

        /**
         * expired: [timeout, infinity)
         * @member {number|Long} timeout
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * max length 128 character
         * @member {string} memo
         * @memberof escrow.Escrow
         * @instance
         */
        Escrow.prototype.memo = "";

        /**
         * Creates a new Escrow instance using the specified properties.
         * @function create
         * @memberof escrow.Escrow
         * @static
         * @param {escrow.IEscrow=} [properties] Properties to set
         * @returns {escrow.Escrow} Escrow instance
         */
        Escrow.create = function create(properties) {
            return new Escrow(properties);
        };

        /**
         * Encodes the specified Escrow message. Does not implicitly {@link escrow.Escrow.verify|verify} messages.
         * @function encode
         * @memberof escrow.Escrow
         * @static
         * @param {escrow.IEscrow} message Escrow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Escrow.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sender != null && message.hasOwnProperty("sender"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.sender);
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.arbiter);
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.recipient);
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified Escrow message, length delimited. Does not implicitly {@link escrow.Escrow.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.Escrow
         * @static
         * @param {escrow.IEscrow} message Escrow message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Escrow.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Escrow message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.Escrow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.Escrow} Escrow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Escrow.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.Escrow();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sender = reader.bytes();
                    break;
                case 3:
                    message.arbiter = reader.bytes();
                    break;
                case 4:
                    message.recipient = reader.bytes();
                    break;
                case 5:
                    message.timeout = reader.int64();
                    break;
                case 6:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Escrow message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.Escrow
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.Escrow} Escrow
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Escrow.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Escrow message.
         * @function verify
         * @memberof escrow.Escrow
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Escrow.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.sender != null && message.hasOwnProperty("sender"))
                if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                    return "sender: buffer expected";
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                if (!(message.arbiter && typeof message.arbiter.length === "number" || $util.isString(message.arbiter)))
                    return "arbiter: buffer expected";
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates an Escrow message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.Escrow
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.Escrow} Escrow
         */
        Escrow.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.Escrow)
                return object;
            var message = new $root.escrow.Escrow();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.Escrow.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.sender != null)
                if (typeof object.sender === "string")
                    $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                else if (object.sender.length)
                    message.sender = object.sender;
            if (object.arbiter != null)
                if (typeof object.arbiter === "string")
                    $util.base64.decode(object.arbiter, message.arbiter = $util.newBuffer($util.base64.length(object.arbiter)), 0);
                else if (object.arbiter.length)
                    message.arbiter = object.arbiter;
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from an Escrow message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.Escrow
         * @static
         * @param {escrow.Escrow} message Escrow
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Escrow.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.sender = "";
                else {
                    object.sender = [];
                    if (options.bytes !== Array)
                        object.sender = $util.newBuffer(object.sender);
                }
                if (options.bytes === String)
                    object.arbiter = "";
                else {
                    object.arbiter = [];
                    if (options.bytes !== Array)
                        object.arbiter = $util.newBuffer(object.arbiter);
                }
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.sender != null && message.hasOwnProperty("sender"))
                object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                object.arbiter = options.bytes === String ? $util.base64.encode(message.arbiter, 0, message.arbiter.length) : options.bytes === Array ? Array.prototype.slice.call(message.arbiter) : message.arbiter;
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this Escrow to JSON.
         * @function toJSON
         * @memberof escrow.Escrow
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Escrow.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Escrow;
    })();

    escrow.CreateEscrowMsg = (function() {

        /**
         * Properties of a CreateEscrowMsg.
         * @memberof escrow
         * @interface ICreateEscrowMsg
         * @property {weave.IMetadata|null} [metadata] CreateEscrowMsg metadata
         * @property {Uint8Array|null} [src] CreateEscrowMsg src
         * @property {Uint8Array|null} [arbiter] CreateEscrowMsg arbiter
         * @property {Uint8Array|null} [recipient] CreateEscrowMsg recipient
         * @property {Array.<coin.ICoin>|null} [amount] amount may contain multiple token types
         * @property {number|Long|null} [timeout] Timeout represents wall clock time.
         * @property {string|null} [memo] max length 128 character
         */

        /**
         * Constructs a new CreateEscrowMsg.
         * @memberof escrow
         * @classdesc The rest must be defined
         * @implements ICreateEscrowMsg
         * @constructor
         * @param {escrow.ICreateEscrowMsg=} [properties] Properties to set
         */
        function CreateEscrowMsg(properties) {
            this.amount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateEscrowMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.CreateEscrowMsg
         * @instance
         */
        CreateEscrowMsg.prototype.metadata = null;

        /**
         * CreateEscrowMsg src.
         * @member {Uint8Array} src
         * @memberof escrow.CreateEscrowMsg
         * @instance
         */
        CreateEscrowMsg.prototype.src = $util.newBuffer([]);

        /**
         * CreateEscrowMsg arbiter.
         * @member {Uint8Array} arbiter
         * @memberof escrow.CreateEscrowMsg
         * @instance
         */
        CreateEscrowMsg.prototype.arbiter = $util.newBuffer([]);

        /**
         * CreateEscrowMsg recipient.
         * @member {Uint8Array} recipient
         * @memberof escrow.CreateEscrowMsg
         * @instance
         */
        CreateEscrowMsg.prototype.recipient = $util.newBuffer([]);

        /**
         * amount may contain multiple token types
         * @member {Array.<coin.ICoin>} amount
         * @memberof escrow.CreateEscrowMsg
         * @instance
         */
        CreateEscrowMsg.prototype.amount = $util.emptyArray;

        /**
         * Timeout represents wall clock time.
         * @member {number|Long} timeout
         * @memberof escrow.CreateEscrowMsg
         * @instance
         */
        CreateEscrowMsg.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * max length 128 character
         * @member {string} memo
         * @memberof escrow.CreateEscrowMsg
         * @instance
         */
        CreateEscrowMsg.prototype.memo = "";

        /**
         * Creates a new CreateEscrowMsg instance using the specified properties.
         * @function create
         * @memberof escrow.CreateEscrowMsg
         * @static
         * @param {escrow.ICreateEscrowMsg=} [properties] Properties to set
         * @returns {escrow.CreateEscrowMsg} CreateEscrowMsg instance
         */
        CreateEscrowMsg.create = function create(properties) {
            return new CreateEscrowMsg(properties);
        };

        /**
         * Encodes the specified CreateEscrowMsg message. Does not implicitly {@link escrow.CreateEscrowMsg.verify|verify} messages.
         * @function encode
         * @memberof escrow.CreateEscrowMsg
         * @static
         * @param {escrow.ICreateEscrowMsg} message CreateEscrowMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateEscrowMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.src != null && message.hasOwnProperty("src"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.src);
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.arbiter);
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.recipient);
            if (message.amount != null && message.amount.length)
                for (var i = 0; i < message.amount.length; ++i)
                    $root.coin.Coin.encode(message.amount[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified CreateEscrowMsg message, length delimited. Does not implicitly {@link escrow.CreateEscrowMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.CreateEscrowMsg
         * @static
         * @param {escrow.ICreateEscrowMsg} message CreateEscrowMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateEscrowMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateEscrowMsg message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.CreateEscrowMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.CreateEscrowMsg} CreateEscrowMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateEscrowMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.CreateEscrowMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.src = reader.bytes();
                    break;
                case 3:
                    message.arbiter = reader.bytes();
                    break;
                case 4:
                    message.recipient = reader.bytes();
                    break;
                case 5:
                    if (!(message.amount && message.amount.length))
                        message.amount = [];
                    message.amount.push($root.coin.Coin.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateEscrowMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.CreateEscrowMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.CreateEscrowMsg} CreateEscrowMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateEscrowMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateEscrowMsg message.
         * @function verify
         * @memberof escrow.CreateEscrowMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateEscrowMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.src != null && message.hasOwnProperty("src"))
                if (!(message.src && typeof message.src.length === "number" || $util.isString(message.src)))
                    return "src: buffer expected";
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                if (!(message.arbiter && typeof message.arbiter.length === "number" || $util.isString(message.arbiter)))
                    return "arbiter: buffer expected";
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                if (!Array.isArray(message.amount))
                    return "amount: array expected";
                for (var i = 0; i < message.amount.length; ++i) {
                    var error = $root.coin.Coin.verify(message.amount[i]);
                    if (error)
                        return "amount." + error;
                }
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a CreateEscrowMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.CreateEscrowMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.CreateEscrowMsg} CreateEscrowMsg
         */
        CreateEscrowMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.CreateEscrowMsg)
                return object;
            var message = new $root.escrow.CreateEscrowMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.CreateEscrowMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.src != null)
                if (typeof object.src === "string")
                    $util.base64.decode(object.src, message.src = $util.newBuffer($util.base64.length(object.src)), 0);
                else if (object.src.length)
                    message.src = object.src;
            if (object.arbiter != null)
                if (typeof object.arbiter === "string")
                    $util.base64.decode(object.arbiter, message.arbiter = $util.newBuffer($util.base64.length(object.arbiter)), 0);
                else if (object.arbiter.length)
                    message.arbiter = object.arbiter;
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.amount) {
                if (!Array.isArray(object.amount))
                    throw TypeError(".escrow.CreateEscrowMsg.amount: array expected");
                message.amount = [];
                for (var i = 0; i < object.amount.length; ++i) {
                    if (typeof object.amount[i] !== "object")
                        throw TypeError(".escrow.CreateEscrowMsg.amount: object expected");
                    message.amount[i] = $root.coin.Coin.fromObject(object.amount[i]);
                }
            }
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a CreateEscrowMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.CreateEscrowMsg
         * @static
         * @param {escrow.CreateEscrowMsg} message CreateEscrowMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateEscrowMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.amount = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.src = "";
                else {
                    object.src = [];
                    if (options.bytes !== Array)
                        object.src = $util.newBuffer(object.src);
                }
                if (options.bytes === String)
                    object.arbiter = "";
                else {
                    object.arbiter = [];
                    if (options.bytes !== Array)
                        object.arbiter = $util.newBuffer(object.arbiter);
                }
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.src != null && message.hasOwnProperty("src"))
                object.src = options.bytes === String ? $util.base64.encode(message.src, 0, message.src.length) : options.bytes === Array ? Array.prototype.slice.call(message.src) : message.src;
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                object.arbiter = options.bytes === String ? $util.base64.encode(message.arbiter, 0, message.arbiter.length) : options.bytes === Array ? Array.prototype.slice.call(message.arbiter) : message.arbiter;
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.amount && message.amount.length) {
                object.amount = [];
                for (var j = 0; j < message.amount.length; ++j)
                    object.amount[j] = $root.coin.Coin.toObject(message.amount[j], options);
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this CreateEscrowMsg to JSON.
         * @function toJSON
         * @memberof escrow.CreateEscrowMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateEscrowMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateEscrowMsg;
    })();

    escrow.ReleaseEscrowMsg = (function() {

        /**
         * Properties of a ReleaseEscrowMsg.
         * @memberof escrow
         * @interface IReleaseEscrowMsg
         * @property {weave.IMetadata|null} [metadata] ReleaseEscrowMsg metadata
         * @property {Uint8Array|null} [escrowId] ReleaseEscrowMsg escrowId
         * @property {Array.<coin.ICoin>|null} [amount] ReleaseEscrowMsg amount
         */

        /**
         * Constructs a new ReleaseEscrowMsg.
         * @memberof escrow
         * @classdesc May be a subset of the current balance.
         * @implements IReleaseEscrowMsg
         * @constructor
         * @param {escrow.IReleaseEscrowMsg=} [properties] Properties to set
         */
        function ReleaseEscrowMsg(properties) {
            this.amount = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReleaseEscrowMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.ReleaseEscrowMsg
         * @instance
         */
        ReleaseEscrowMsg.prototype.metadata = null;

        /**
         * ReleaseEscrowMsg escrowId.
         * @member {Uint8Array} escrowId
         * @memberof escrow.ReleaseEscrowMsg
         * @instance
         */
        ReleaseEscrowMsg.prototype.escrowId = $util.newBuffer([]);

        /**
         * ReleaseEscrowMsg amount.
         * @member {Array.<coin.ICoin>} amount
         * @memberof escrow.ReleaseEscrowMsg
         * @instance
         */
        ReleaseEscrowMsg.prototype.amount = $util.emptyArray;

        /**
         * Creates a new ReleaseEscrowMsg instance using the specified properties.
         * @function create
         * @memberof escrow.ReleaseEscrowMsg
         * @static
         * @param {escrow.IReleaseEscrowMsg=} [properties] Properties to set
         * @returns {escrow.ReleaseEscrowMsg} ReleaseEscrowMsg instance
         */
        ReleaseEscrowMsg.create = function create(properties) {
            return new ReleaseEscrowMsg(properties);
        };

        /**
         * Encodes the specified ReleaseEscrowMsg message. Does not implicitly {@link escrow.ReleaseEscrowMsg.verify|verify} messages.
         * @function encode
         * @memberof escrow.ReleaseEscrowMsg
         * @static
         * @param {escrow.IReleaseEscrowMsg} message ReleaseEscrowMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseEscrowMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.escrowId);
            if (message.amount != null && message.amount.length)
                for (var i = 0; i < message.amount.length; ++i)
                    $root.coin.Coin.encode(message.amount[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReleaseEscrowMsg message, length delimited. Does not implicitly {@link escrow.ReleaseEscrowMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.ReleaseEscrowMsg
         * @static
         * @param {escrow.IReleaseEscrowMsg} message ReleaseEscrowMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReleaseEscrowMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReleaseEscrowMsg message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.ReleaseEscrowMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.ReleaseEscrowMsg} ReleaseEscrowMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseEscrowMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.ReleaseEscrowMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.escrowId = reader.bytes();
                    break;
                case 3:
                    if (!(message.amount && message.amount.length))
                        message.amount = [];
                    message.amount.push($root.coin.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReleaseEscrowMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.ReleaseEscrowMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.ReleaseEscrowMsg} ReleaseEscrowMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReleaseEscrowMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReleaseEscrowMsg message.
         * @function verify
         * @memberof escrow.ReleaseEscrowMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReleaseEscrowMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                if (!(message.escrowId && typeof message.escrowId.length === "number" || $util.isString(message.escrowId)))
                    return "escrowId: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                if (!Array.isArray(message.amount))
                    return "amount: array expected";
                for (var i = 0; i < message.amount.length; ++i) {
                    var error = $root.coin.Coin.verify(message.amount[i]);
                    if (error)
                        return "amount." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ReleaseEscrowMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.ReleaseEscrowMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.ReleaseEscrowMsg} ReleaseEscrowMsg
         */
        ReleaseEscrowMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.ReleaseEscrowMsg)
                return object;
            var message = new $root.escrow.ReleaseEscrowMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.ReleaseEscrowMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.escrowId != null)
                if (typeof object.escrowId === "string")
                    $util.base64.decode(object.escrowId, message.escrowId = $util.newBuffer($util.base64.length(object.escrowId)), 0);
                else if (object.escrowId.length)
                    message.escrowId = object.escrowId;
            if (object.amount) {
                if (!Array.isArray(object.amount))
                    throw TypeError(".escrow.ReleaseEscrowMsg.amount: array expected");
                message.amount = [];
                for (var i = 0; i < object.amount.length; ++i) {
                    if (typeof object.amount[i] !== "object")
                        throw TypeError(".escrow.ReleaseEscrowMsg.amount: object expected");
                    message.amount[i] = $root.coin.Coin.fromObject(object.amount[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ReleaseEscrowMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.ReleaseEscrowMsg
         * @static
         * @param {escrow.ReleaseEscrowMsg} message ReleaseEscrowMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReleaseEscrowMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.amount = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.escrowId = "";
                else {
                    object.escrowId = [];
                    if (options.bytes !== Array)
                        object.escrowId = $util.newBuffer(object.escrowId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                object.escrowId = options.bytes === String ? $util.base64.encode(message.escrowId, 0, message.escrowId.length) : options.bytes === Array ? Array.prototype.slice.call(message.escrowId) : message.escrowId;
            if (message.amount && message.amount.length) {
                object.amount = [];
                for (var j = 0; j < message.amount.length; ++j)
                    object.amount[j] = $root.coin.Coin.toObject(message.amount[j], options);
            }
            return object;
        };

        /**
         * Converts this ReleaseEscrowMsg to JSON.
         * @function toJSON
         * @memberof escrow.ReleaseEscrowMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReleaseEscrowMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReleaseEscrowMsg;
    })();

    escrow.ReturnEscrowMsg = (function() {

        /**
         * Properties of a ReturnEscrowMsg.
         * @memberof escrow
         * @interface IReturnEscrowMsg
         * @property {weave.IMetadata|null} [metadata] ReturnEscrowMsg metadata
         * @property {Uint8Array|null} [escrowId] ReturnEscrowMsg escrowId
         */

        /**
         * Constructs a new ReturnEscrowMsg.
         * @memberof escrow
         * @classdesc Must be authorized by the sender or an expired timeout
         * @implements IReturnEscrowMsg
         * @constructor
         * @param {escrow.IReturnEscrowMsg=} [properties] Properties to set
         */
        function ReturnEscrowMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReturnEscrowMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.ReturnEscrowMsg
         * @instance
         */
        ReturnEscrowMsg.prototype.metadata = null;

        /**
         * ReturnEscrowMsg escrowId.
         * @member {Uint8Array} escrowId
         * @memberof escrow.ReturnEscrowMsg
         * @instance
         */
        ReturnEscrowMsg.prototype.escrowId = $util.newBuffer([]);

        /**
         * Creates a new ReturnEscrowMsg instance using the specified properties.
         * @function create
         * @memberof escrow.ReturnEscrowMsg
         * @static
         * @param {escrow.IReturnEscrowMsg=} [properties] Properties to set
         * @returns {escrow.ReturnEscrowMsg} ReturnEscrowMsg instance
         */
        ReturnEscrowMsg.create = function create(properties) {
            return new ReturnEscrowMsg(properties);
        };

        /**
         * Encodes the specified ReturnEscrowMsg message. Does not implicitly {@link escrow.ReturnEscrowMsg.verify|verify} messages.
         * @function encode
         * @memberof escrow.ReturnEscrowMsg
         * @static
         * @param {escrow.IReturnEscrowMsg} message ReturnEscrowMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnEscrowMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.escrowId);
            return writer;
        };

        /**
         * Encodes the specified ReturnEscrowMsg message, length delimited. Does not implicitly {@link escrow.ReturnEscrowMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.ReturnEscrowMsg
         * @static
         * @param {escrow.IReturnEscrowMsg} message ReturnEscrowMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnEscrowMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReturnEscrowMsg message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.ReturnEscrowMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.ReturnEscrowMsg} ReturnEscrowMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnEscrowMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.ReturnEscrowMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.escrowId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReturnEscrowMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.ReturnEscrowMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.ReturnEscrowMsg} ReturnEscrowMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnEscrowMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReturnEscrowMsg message.
         * @function verify
         * @memberof escrow.ReturnEscrowMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReturnEscrowMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                if (!(message.escrowId && typeof message.escrowId.length === "number" || $util.isString(message.escrowId)))
                    return "escrowId: buffer expected";
            return null;
        };

        /**
         * Creates a ReturnEscrowMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.ReturnEscrowMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.ReturnEscrowMsg} ReturnEscrowMsg
         */
        ReturnEscrowMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.ReturnEscrowMsg)
                return object;
            var message = new $root.escrow.ReturnEscrowMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.ReturnEscrowMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.escrowId != null)
                if (typeof object.escrowId === "string")
                    $util.base64.decode(object.escrowId, message.escrowId = $util.newBuffer($util.base64.length(object.escrowId)), 0);
                else if (object.escrowId.length)
                    message.escrowId = object.escrowId;
            return message;
        };

        /**
         * Creates a plain object from a ReturnEscrowMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.ReturnEscrowMsg
         * @static
         * @param {escrow.ReturnEscrowMsg} message ReturnEscrowMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReturnEscrowMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.escrowId = "";
                else {
                    object.escrowId = [];
                    if (options.bytes !== Array)
                        object.escrowId = $util.newBuffer(object.escrowId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                object.escrowId = options.bytes === String ? $util.base64.encode(message.escrowId, 0, message.escrowId.length) : options.bytes === Array ? Array.prototype.slice.call(message.escrowId) : message.escrowId;
            return object;
        };

        /**
         * Converts this ReturnEscrowMsg to JSON.
         * @function toJSON
         * @memberof escrow.ReturnEscrowMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReturnEscrowMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReturnEscrowMsg;
    })();

    escrow.UpdateEscrowPartiesMsg = (function() {

        /**
         * Properties of an UpdateEscrowPartiesMsg.
         * @memberof escrow
         * @interface IUpdateEscrowPartiesMsg
         * @property {weave.IMetadata|null} [metadata] UpdateEscrowPartiesMsg metadata
         * @property {Uint8Array|null} [escrowId] UpdateEscrowPartiesMsg escrowId
         * @property {Uint8Array|null} [sender] UpdateEscrowPartiesMsg sender
         * @property {Uint8Array|null} [arbiter] UpdateEscrowPartiesMsg arbiter
         * @property {Uint8Array|null} [recipient] UpdateEscrowPartiesMsg recipient
         */

        /**
         * Constructs a new UpdateEscrowPartiesMsg.
         * @memberof escrow
         * @classdesc Represents delegating responsibility
         * @implements IUpdateEscrowPartiesMsg
         * @constructor
         * @param {escrow.IUpdateEscrowPartiesMsg=} [properties] Properties to set
         */
        function UpdateEscrowPartiesMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateEscrowPartiesMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @instance
         */
        UpdateEscrowPartiesMsg.prototype.metadata = null;

        /**
         * UpdateEscrowPartiesMsg escrowId.
         * @member {Uint8Array} escrowId
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @instance
         */
        UpdateEscrowPartiesMsg.prototype.escrowId = $util.newBuffer([]);

        /**
         * UpdateEscrowPartiesMsg sender.
         * @member {Uint8Array} sender
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @instance
         */
        UpdateEscrowPartiesMsg.prototype.sender = $util.newBuffer([]);

        /**
         * UpdateEscrowPartiesMsg arbiter.
         * @member {Uint8Array} arbiter
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @instance
         */
        UpdateEscrowPartiesMsg.prototype.arbiter = $util.newBuffer([]);

        /**
         * UpdateEscrowPartiesMsg recipient.
         * @member {Uint8Array} recipient
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @instance
         */
        UpdateEscrowPartiesMsg.prototype.recipient = $util.newBuffer([]);

        /**
         * Creates a new UpdateEscrowPartiesMsg instance using the specified properties.
         * @function create
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @static
         * @param {escrow.IUpdateEscrowPartiesMsg=} [properties] Properties to set
         * @returns {escrow.UpdateEscrowPartiesMsg} UpdateEscrowPartiesMsg instance
         */
        UpdateEscrowPartiesMsg.create = function create(properties) {
            return new UpdateEscrowPartiesMsg(properties);
        };

        /**
         * Encodes the specified UpdateEscrowPartiesMsg message. Does not implicitly {@link escrow.UpdateEscrowPartiesMsg.verify|verify} messages.
         * @function encode
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @static
         * @param {escrow.IUpdateEscrowPartiesMsg} message UpdateEscrowPartiesMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateEscrowPartiesMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.escrowId);
            if (message.sender != null && message.hasOwnProperty("sender"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.sender);
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.arbiter);
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.recipient);
            return writer;
        };

        /**
         * Encodes the specified UpdateEscrowPartiesMsg message, length delimited. Does not implicitly {@link escrow.UpdateEscrowPartiesMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @static
         * @param {escrow.IUpdateEscrowPartiesMsg} message UpdateEscrowPartiesMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateEscrowPartiesMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateEscrowPartiesMsg message from the specified reader or buffer.
         * @function decode
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {escrow.UpdateEscrowPartiesMsg} UpdateEscrowPartiesMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateEscrowPartiesMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.escrow.UpdateEscrowPartiesMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.escrowId = reader.bytes();
                    break;
                case 3:
                    message.sender = reader.bytes();
                    break;
                case 4:
                    message.arbiter = reader.bytes();
                    break;
                case 5:
                    message.recipient = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateEscrowPartiesMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {escrow.UpdateEscrowPartiesMsg} UpdateEscrowPartiesMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateEscrowPartiesMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateEscrowPartiesMsg message.
         * @function verify
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateEscrowPartiesMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                if (!(message.escrowId && typeof message.escrowId.length === "number" || $util.isString(message.escrowId)))
                    return "escrowId: buffer expected";
            if (message.sender != null && message.hasOwnProperty("sender"))
                if (!(message.sender && typeof message.sender.length === "number" || $util.isString(message.sender)))
                    return "sender: buffer expected";
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                if (!(message.arbiter && typeof message.arbiter.length === "number" || $util.isString(message.arbiter)))
                    return "arbiter: buffer expected";
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            return null;
        };

        /**
         * Creates an UpdateEscrowPartiesMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {escrow.UpdateEscrowPartiesMsg} UpdateEscrowPartiesMsg
         */
        UpdateEscrowPartiesMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.escrow.UpdateEscrowPartiesMsg)
                return object;
            var message = new $root.escrow.UpdateEscrowPartiesMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".escrow.UpdateEscrowPartiesMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.escrowId != null)
                if (typeof object.escrowId === "string")
                    $util.base64.decode(object.escrowId, message.escrowId = $util.newBuffer($util.base64.length(object.escrowId)), 0);
                else if (object.escrowId.length)
                    message.escrowId = object.escrowId;
            if (object.sender != null)
                if (typeof object.sender === "string")
                    $util.base64.decode(object.sender, message.sender = $util.newBuffer($util.base64.length(object.sender)), 0);
                else if (object.sender.length)
                    message.sender = object.sender;
            if (object.arbiter != null)
                if (typeof object.arbiter === "string")
                    $util.base64.decode(object.arbiter, message.arbiter = $util.newBuffer($util.base64.length(object.arbiter)), 0);
                else if (object.arbiter.length)
                    message.arbiter = object.arbiter;
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            return message;
        };

        /**
         * Creates a plain object from an UpdateEscrowPartiesMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @static
         * @param {escrow.UpdateEscrowPartiesMsg} message UpdateEscrowPartiesMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateEscrowPartiesMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.escrowId = "";
                else {
                    object.escrowId = [];
                    if (options.bytes !== Array)
                        object.escrowId = $util.newBuffer(object.escrowId);
                }
                if (options.bytes === String)
                    object.sender = "";
                else {
                    object.sender = [];
                    if (options.bytes !== Array)
                        object.sender = $util.newBuffer(object.sender);
                }
                if (options.bytes === String)
                    object.arbiter = "";
                else {
                    object.arbiter = [];
                    if (options.bytes !== Array)
                        object.arbiter = $util.newBuffer(object.arbiter);
                }
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.escrowId != null && message.hasOwnProperty("escrowId"))
                object.escrowId = options.bytes === String ? $util.base64.encode(message.escrowId, 0, message.escrowId.length) : options.bytes === Array ? Array.prototype.slice.call(message.escrowId) : message.escrowId;
            if (message.sender != null && message.hasOwnProperty("sender"))
                object.sender = options.bytes === String ? $util.base64.encode(message.sender, 0, message.sender.length) : options.bytes === Array ? Array.prototype.slice.call(message.sender) : message.sender;
            if (message.arbiter != null && message.hasOwnProperty("arbiter"))
                object.arbiter = options.bytes === String ? $util.base64.encode(message.arbiter, 0, message.arbiter.length) : options.bytes === Array ? Array.prototype.slice.call(message.arbiter) : message.arbiter;
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            return object;
        };

        /**
         * Converts this UpdateEscrowPartiesMsg to JSON.
         * @function toJSON
         * @memberof escrow.UpdateEscrowPartiesMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateEscrowPartiesMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateEscrowPartiesMsg;
    })();

    return escrow;
})();

$root.gov = (function() {

    /**
     * Namespace gov.
     * @exports gov
     * @namespace
     */
    var gov = {};

    gov.Electorate = (function() {

        /**
         * Properties of an Electorate.
         * @memberof gov
         * @interface IElectorate
         * @property {weave.IMetadata|null} [metadata] Electorate metadata
         * @property {number|null} [version] Document version
         * @property {Uint8Array|null} [admin] Admin is the address that is allowed ot modify an existing electorate.
         * @property {string|null} [title] Human readable title.
         * @property {Array.<gov.IElector>|null} [electors] Elector defines a list of all signatures that are allowed to participate in a vote
         * @property {number|Long|null} [totalElectorateWeight] TotalElectorateWeight is the sum of all electors weights.
         * @property {orm.IVersionedIDRef|null} [updateElectionRuleRef] UpdateElectionRuleRef reference the rule to update this electorate.
         */

        /**
         * Constructs a new Electorate.
         * @memberof gov
         * @classdesc and is stored for re-use
         * @implements IElectorate
         * @constructor
         * @param {gov.IElectorate=} [properties] Properties to set
         */
        function Electorate(properties) {
            this.electors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Electorate metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.metadata = null;

        /**
         * Document version
         * @member {number} version
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.version = 0;

        /**
         * Admin is the address that is allowed ot modify an existing electorate.
         * @member {Uint8Array} admin
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.admin = $util.newBuffer([]);

        /**
         * Human readable title.
         * @member {string} title
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.title = "";

        /**
         * Elector defines a list of all signatures that are allowed to participate in a vote
         * @member {Array.<gov.IElector>} electors
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.electors = $util.emptyArray;

        /**
         * TotalElectorateWeight is the sum of all electors weights.
         * @member {number|Long} totalElectorateWeight
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.totalElectorateWeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UpdateElectionRuleRef reference the rule to update this electorate.
         * @member {orm.IVersionedIDRef|null|undefined} updateElectionRuleRef
         * @memberof gov.Electorate
         * @instance
         */
        Electorate.prototype.updateElectionRuleRef = null;

        /**
         * Creates a new Electorate instance using the specified properties.
         * @function create
         * @memberof gov.Electorate
         * @static
         * @param {gov.IElectorate=} [properties] Properties to set
         * @returns {gov.Electorate} Electorate instance
         */
        Electorate.create = function create(properties) {
            return new Electorate(properties);
        };

        /**
         * Encodes the specified Electorate message. Does not implicitly {@link gov.Electorate.verify|verify} messages.
         * @function encode
         * @memberof gov.Electorate
         * @static
         * @param {gov.IElectorate} message Electorate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Electorate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.admin);
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.title);
            if (message.electors != null && message.electors.length)
                for (var i = 0; i < message.electors.length; ++i)
                    $root.gov.Elector.encode(message.electors[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.totalElectorateWeight);
            if (message.updateElectionRuleRef != null && message.hasOwnProperty("updateElectionRuleRef"))
                $root.orm.VersionedIDRef.encode(message.updateElectionRuleRef, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Electorate message, length delimited. Does not implicitly {@link gov.Electorate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Electorate
         * @static
         * @param {gov.IElectorate} message Electorate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Electorate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Electorate message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Electorate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Electorate} Electorate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Electorate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Electorate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.admin = reader.bytes();
                    break;
                case 4:
                    message.title = reader.string();
                    break;
                case 5:
                    if (!(message.electors && message.electors.length))
                        message.electors = [];
                    message.electors.push($root.gov.Elector.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.totalElectorateWeight = reader.uint64();
                    break;
                case 7:
                    message.updateElectionRuleRef = $root.orm.VersionedIDRef.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Electorate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Electorate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Electorate} Electorate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Electorate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Electorate message.
         * @function verify
         * @memberof gov.Electorate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Electorate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.electors != null && message.hasOwnProperty("electors")) {
                if (!Array.isArray(message.electors))
                    return "electors: array expected";
                for (var i = 0; i < message.electors.length; ++i) {
                    var error = $root.gov.Elector.verify(message.electors[i]);
                    if (error)
                        return "electors." + error;
                }
            }
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                if (!$util.isInteger(message.totalElectorateWeight) && !(message.totalElectorateWeight && $util.isInteger(message.totalElectorateWeight.low) && $util.isInteger(message.totalElectorateWeight.high)))
                    return "totalElectorateWeight: integer|Long expected";
            if (message.updateElectionRuleRef != null && message.hasOwnProperty("updateElectionRuleRef")) {
                var error = $root.orm.VersionedIDRef.verify(message.updateElectionRuleRef);
                if (error)
                    return "updateElectionRuleRef." + error;
            }
            return null;
        };

        /**
         * Creates an Electorate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Electorate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Electorate} Electorate
         */
        Electorate.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Electorate)
                return object;
            var message = new $root.gov.Electorate();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.Electorate.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            if (object.title != null)
                message.title = String(object.title);
            if (object.electors) {
                if (!Array.isArray(object.electors))
                    throw TypeError(".gov.Electorate.electors: array expected");
                message.electors = [];
                for (var i = 0; i < object.electors.length; ++i) {
                    if (typeof object.electors[i] !== "object")
                        throw TypeError(".gov.Electorate.electors: object expected");
                    message.electors[i] = $root.gov.Elector.fromObject(object.electors[i]);
                }
            }
            if (object.totalElectorateWeight != null)
                if ($util.Long)
                    (message.totalElectorateWeight = $util.Long.fromValue(object.totalElectorateWeight)).unsigned = true;
                else if (typeof object.totalElectorateWeight === "string")
                    message.totalElectorateWeight = parseInt(object.totalElectorateWeight, 10);
                else if (typeof object.totalElectorateWeight === "number")
                    message.totalElectorateWeight = object.totalElectorateWeight;
                else if (typeof object.totalElectorateWeight === "object")
                    message.totalElectorateWeight = new $util.LongBits(object.totalElectorateWeight.low >>> 0, object.totalElectorateWeight.high >>> 0).toNumber(true);
            if (object.updateElectionRuleRef != null) {
                if (typeof object.updateElectionRuleRef !== "object")
                    throw TypeError(".gov.Electorate.updateElectionRuleRef: object expected");
                message.updateElectionRuleRef = $root.orm.VersionedIDRef.fromObject(object.updateElectionRuleRef);
            }
            return message;
        };

        /**
         * Creates a plain object from an Electorate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Electorate
         * @static
         * @param {gov.Electorate} message Electorate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Electorate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.electors = [];
            if (options.defaults) {
                object.metadata = null;
                object.version = 0;
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
                object.title = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalElectorateWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalElectorateWeight = options.longs === String ? "0" : 0;
                object.updateElectionRuleRef = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.electors && message.electors.length) {
                object.electors = [];
                for (var j = 0; j < message.electors.length; ++j)
                    object.electors[j] = $root.gov.Elector.toObject(message.electors[j], options);
            }
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                if (typeof message.totalElectorateWeight === "number")
                    object.totalElectorateWeight = options.longs === String ? String(message.totalElectorateWeight) : message.totalElectorateWeight;
                else
                    object.totalElectorateWeight = options.longs === String ? $util.Long.prototype.toString.call(message.totalElectorateWeight) : options.longs === Number ? new $util.LongBits(message.totalElectorateWeight.low >>> 0, message.totalElectorateWeight.high >>> 0).toNumber(true) : message.totalElectorateWeight;
            if (message.updateElectionRuleRef != null && message.hasOwnProperty("updateElectionRuleRef"))
                object.updateElectionRuleRef = $root.orm.VersionedIDRef.toObject(message.updateElectionRuleRef, options);
            return object;
        };

        /**
         * Converts this Electorate to JSON.
         * @function toJSON
         * @memberof gov.Electorate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Electorate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Electorate;
    })();

    gov.Elector = (function() {

        /**
         * Properties of an Elector.
         * @memberof gov
         * @interface IElector
         * @property {Uint8Array|null} [address] The address of the voter.
         * @property {number|null} [weight] Weight defines the power of the participants vote. max value is 65535 (2^16-1).
         */

        /**
         * Constructs a new Elector.
         * @memberof gov
         * @classdesc the greater the power of a participant.
         * @implements IElector
         * @constructor
         * @param {gov.IElector=} [properties] Properties to set
         */
        function Elector(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The address of the voter.
         * @member {Uint8Array} address
         * @memberof gov.Elector
         * @instance
         */
        Elector.prototype.address = $util.newBuffer([]);

        /**
         * Weight defines the power of the participants vote. max value is 65535 (2^16-1).
         * @member {number} weight
         * @memberof gov.Elector
         * @instance
         */
        Elector.prototype.weight = 0;

        /**
         * Creates a new Elector instance using the specified properties.
         * @function create
         * @memberof gov.Elector
         * @static
         * @param {gov.IElector=} [properties] Properties to set
         * @returns {gov.Elector} Elector instance
         */
        Elector.create = function create(properties) {
            return new Elector(properties);
        };

        /**
         * Encodes the specified Elector message. Does not implicitly {@link gov.Elector.verify|verify} messages.
         * @function encode
         * @memberof gov.Elector
         * @static
         * @param {gov.IElector} message Elector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Elector.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.weight != null && message.hasOwnProperty("weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.weight);
            return writer;
        };

        /**
         * Encodes the specified Elector message, length delimited. Does not implicitly {@link gov.Elector.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Elector
         * @static
         * @param {gov.IElector} message Elector message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Elector.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Elector message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Elector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Elector} Elector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Elector.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Elector();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.weight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Elector message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Elector
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Elector} Elector
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Elector.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Elector message.
         * @function verify
         * @memberof gov.Elector
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Elector.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight))
                    return "weight: integer expected";
            return null;
        };

        /**
         * Creates an Elector message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Elector
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Elector} Elector
         */
        Elector.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Elector)
                return object;
            var message = new $root.gov.Elector();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.weight != null)
                message.weight = object.weight >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an Elector message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Elector
         * @static
         * @param {gov.Elector} message Elector
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Elector.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.weight = 0;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = message.weight;
            return object;
        };

        /**
         * Converts this Elector to JSON.
         * @function toJSON
         * @memberof gov.Elector
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Elector.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Elector;
    })();

    gov.ElectionRule = (function() {

        /**
         * Properties of an ElectionRule.
         * @memberof gov
         * @interface IElectionRule
         * @property {weave.IMetadata|null} [metadata] ElectionRule metadata
         * @property {number|null} [version] Document version
         * @property {Uint8Array|null} [admin] Admin is the address that is allowed ot modify an existing election rule.
         * @property {string|null} [title] Human readable title.
         * @property {number|null} [votingPeriodHours] Duration how long the voting period will take place.
         * @property {gov.IFraction|null} [threshold] of the eligible voters.
         * @property {gov.IFraction|null} [quorum] of the eligible voters.
         */

        /**
         * Constructs a new ElectionRule.
         * @memberof gov
         * @classdesc Election Rule defines how an election is run. A proposal must be voted upon via a pre-defined ruleset.
         * @implements IElectionRule
         * @constructor
         * @param {gov.IElectionRule=} [properties] Properties to set
         */
        function ElectionRule(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ElectionRule metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.metadata = null;

        /**
         * Document version
         * @member {number} version
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.version = 0;

        /**
         * Admin is the address that is allowed ot modify an existing election rule.
         * @member {Uint8Array} admin
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.admin = $util.newBuffer([]);

        /**
         * Human readable title.
         * @member {string} title
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.title = "";

        /**
         * Duration how long the voting period will take place.
         * @member {number} votingPeriodHours
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.votingPeriodHours = 0;

        /**
         * of the eligible voters.
         * @member {gov.IFraction|null|undefined} threshold
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.threshold = null;

        /**
         * of the eligible voters.
         * @member {gov.IFraction|null|undefined} quorum
         * @memberof gov.ElectionRule
         * @instance
         */
        ElectionRule.prototype.quorum = null;

        /**
         * Creates a new ElectionRule instance using the specified properties.
         * @function create
         * @memberof gov.ElectionRule
         * @static
         * @param {gov.IElectionRule=} [properties] Properties to set
         * @returns {gov.ElectionRule} ElectionRule instance
         */
        ElectionRule.create = function create(properties) {
            return new ElectionRule(properties);
        };

        /**
         * Encodes the specified ElectionRule message. Does not implicitly {@link gov.ElectionRule.verify|verify} messages.
         * @function encode
         * @memberof gov.ElectionRule
         * @static
         * @param {gov.IElectionRule} message ElectionRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ElectionRule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.version);
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.admin);
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.title);
            if (message.votingPeriodHours != null && message.hasOwnProperty("votingPeriodHours"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.votingPeriodHours);
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                $root.gov.Fraction.encode(message.threshold, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                $root.gov.Fraction.encode(message.quorum, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ElectionRule message, length delimited. Does not implicitly {@link gov.ElectionRule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.ElectionRule
         * @static
         * @param {gov.IElectionRule} message ElectionRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ElectionRule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ElectionRule message from the specified reader or buffer.
         * @function decode
         * @memberof gov.ElectionRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.ElectionRule} ElectionRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ElectionRule.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.ElectionRule();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.version = reader.uint32();
                    break;
                case 3:
                    message.admin = reader.bytes();
                    break;
                case 4:
                    message.title = reader.string();
                    break;
                case 5:
                    message.votingPeriodHours = reader.uint32();
                    break;
                case 6:
                    message.threshold = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.quorum = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ElectionRule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.ElectionRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.ElectionRule} ElectionRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ElectionRule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ElectionRule message.
         * @function verify
         * @memberof gov.ElectionRule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ElectionRule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (!(message.admin && typeof message.admin.length === "number" || $util.isString(message.admin)))
                    return "admin: buffer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.votingPeriodHours != null && message.hasOwnProperty("votingPeriodHours"))
                if (!$util.isInteger(message.votingPeriodHours))
                    return "votingPeriodHours: integer expected";
            if (message.threshold != null && message.hasOwnProperty("threshold")) {
                var error = $root.gov.Fraction.verify(message.threshold);
                if (error)
                    return "threshold." + error;
            }
            if (message.quorum != null && message.hasOwnProperty("quorum")) {
                var error = $root.gov.Fraction.verify(message.quorum);
                if (error)
                    return "quorum." + error;
            }
            return null;
        };

        /**
         * Creates an ElectionRule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.ElectionRule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.ElectionRule} ElectionRule
         */
        ElectionRule.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.ElectionRule)
                return object;
            var message = new $root.gov.ElectionRule();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.ElectionRule.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.version != null)
                message.version = object.version >>> 0;
            if (object.admin != null)
                if (typeof object.admin === "string")
                    $util.base64.decode(object.admin, message.admin = $util.newBuffer($util.base64.length(object.admin)), 0);
                else if (object.admin.length)
                    message.admin = object.admin;
            if (object.title != null)
                message.title = String(object.title);
            if (object.votingPeriodHours != null)
                message.votingPeriodHours = object.votingPeriodHours >>> 0;
            if (object.threshold != null) {
                if (typeof object.threshold !== "object")
                    throw TypeError(".gov.ElectionRule.threshold: object expected");
                message.threshold = $root.gov.Fraction.fromObject(object.threshold);
            }
            if (object.quorum != null) {
                if (typeof object.quorum !== "object")
                    throw TypeError(".gov.ElectionRule.quorum: object expected");
                message.quorum = $root.gov.Fraction.fromObject(object.quorum);
            }
            return message;
        };

        /**
         * Creates a plain object from an ElectionRule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.ElectionRule
         * @static
         * @param {gov.ElectionRule} message ElectionRule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ElectionRule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.version = 0;
                if (options.bytes === String)
                    object.admin = "";
                else {
                    object.admin = [];
                    if (options.bytes !== Array)
                        object.admin = $util.newBuffer(object.admin);
                }
                object.title = "";
                object.votingPeriodHours = 0;
                object.threshold = null;
                object.quorum = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = options.bytes === String ? $util.base64.encode(message.admin, 0, message.admin.length) : options.bytes === Array ? Array.prototype.slice.call(message.admin) : message.admin;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.votingPeriodHours != null && message.hasOwnProperty("votingPeriodHours"))
                object.votingPeriodHours = message.votingPeriodHours;
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                object.threshold = $root.gov.Fraction.toObject(message.threshold, options);
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                object.quorum = $root.gov.Fraction.toObject(message.quorum, options);
            return object;
        };

        /**
         * Converts this ElectionRule to JSON.
         * @function toJSON
         * @memberof gov.ElectionRule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ElectionRule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ElectionRule;
    })();

    gov.Fraction = (function() {

        /**
         * Properties of a Fraction.
         * @memberof gov
         * @interface IFraction
         * @property {number|null} [numerator] The top number in a fraction.
         * @property {number|null} [denominator] The bottom number
         */

        /**
         * Constructs a new Fraction.
         * @memberof gov
         * @classdesc Valid range of the fraction is 0.5 to 1.
         * @implements IFraction
         * @constructor
         * @param {gov.IFraction=} [properties] Properties to set
         */
        function Fraction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The top number in a fraction.
         * @member {number} numerator
         * @memberof gov.Fraction
         * @instance
         */
        Fraction.prototype.numerator = 0;

        /**
         * The bottom number
         * @member {number} denominator
         * @memberof gov.Fraction
         * @instance
         */
        Fraction.prototype.denominator = 0;

        /**
         * Creates a new Fraction instance using the specified properties.
         * @function create
         * @memberof gov.Fraction
         * @static
         * @param {gov.IFraction=} [properties] Properties to set
         * @returns {gov.Fraction} Fraction instance
         */
        Fraction.create = function create(properties) {
            return new Fraction(properties);
        };

        /**
         * Encodes the specified Fraction message. Does not implicitly {@link gov.Fraction.verify|verify} messages.
         * @function encode
         * @memberof gov.Fraction
         * @static
         * @param {gov.IFraction} message Fraction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fraction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.numerator != null && message.hasOwnProperty("numerator"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.numerator);
            if (message.denominator != null && message.hasOwnProperty("denominator"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.denominator);
            return writer;
        };

        /**
         * Encodes the specified Fraction message, length delimited. Does not implicitly {@link gov.Fraction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Fraction
         * @static
         * @param {gov.IFraction} message Fraction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fraction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Fraction message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Fraction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Fraction} Fraction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fraction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Fraction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.numerator = reader.uint32();
                    break;
                case 2:
                    message.denominator = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Fraction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Fraction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Fraction} Fraction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fraction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Fraction message.
         * @function verify
         * @memberof gov.Fraction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fraction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.numerator != null && message.hasOwnProperty("numerator"))
                if (!$util.isInteger(message.numerator))
                    return "numerator: integer expected";
            if (message.denominator != null && message.hasOwnProperty("denominator"))
                if (!$util.isInteger(message.denominator))
                    return "denominator: integer expected";
            return null;
        };

        /**
         * Creates a Fraction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Fraction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Fraction} Fraction
         */
        Fraction.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Fraction)
                return object;
            var message = new $root.gov.Fraction();
            if (object.numerator != null)
                message.numerator = object.numerator >>> 0;
            if (object.denominator != null)
                message.denominator = object.denominator >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Fraction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Fraction
         * @static
         * @param {gov.Fraction} message Fraction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fraction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.numerator = 0;
                object.denominator = 0;
            }
            if (message.numerator != null && message.hasOwnProperty("numerator"))
                object.numerator = message.numerator;
            if (message.denominator != null && message.hasOwnProperty("denominator"))
                object.denominator = message.denominator;
            return object;
        };

        /**
         * Converts this Fraction to JSON.
         * @function toJSON
         * @memberof gov.Fraction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fraction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Fraction;
    })();

    gov.TextProposalPayload = (function() {

        /**
         * Properties of a TextProposalPayload.
         * @memberof gov
         * @interface ITextProposalPayload
         */

        /**
         * Constructs a new TextProposalPayload.
         * @memberof gov
         * @classdesc A text form proposal for an on-chain governance process.
         * @implements ITextProposalPayload
         * @constructor
         * @param {gov.ITextProposalPayload=} [properties] Properties to set
         */
        function TextProposalPayload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new TextProposalPayload instance using the specified properties.
         * @function create
         * @memberof gov.TextProposalPayload
         * @static
         * @param {gov.ITextProposalPayload=} [properties] Properties to set
         * @returns {gov.TextProposalPayload} TextProposalPayload instance
         */
        TextProposalPayload.create = function create(properties) {
            return new TextProposalPayload(properties);
        };

        /**
         * Encodes the specified TextProposalPayload message. Does not implicitly {@link gov.TextProposalPayload.verify|verify} messages.
         * @function encode
         * @memberof gov.TextProposalPayload
         * @static
         * @param {gov.ITextProposalPayload} message TextProposalPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextProposalPayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified TextProposalPayload message, length delimited. Does not implicitly {@link gov.TextProposalPayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.TextProposalPayload
         * @static
         * @param {gov.ITextProposalPayload} message TextProposalPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextProposalPayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TextProposalPayload message from the specified reader or buffer.
         * @function decode
         * @memberof gov.TextProposalPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.TextProposalPayload} TextProposalPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextProposalPayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.TextProposalPayload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TextProposalPayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.TextProposalPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.TextProposalPayload} TextProposalPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextProposalPayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TextProposalPayload message.
         * @function verify
         * @memberof gov.TextProposalPayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TextProposalPayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a TextProposalPayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.TextProposalPayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.TextProposalPayload} TextProposalPayload
         */
        TextProposalPayload.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.TextProposalPayload)
                return object;
            return new $root.gov.TextProposalPayload();
        };

        /**
         * Creates a plain object from a TextProposalPayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.TextProposalPayload
         * @static
         * @param {gov.TextProposalPayload} message TextProposalPayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TextProposalPayload.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this TextProposalPayload to JSON.
         * @function toJSON
         * @memberof gov.TextProposalPayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TextProposalPayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TextProposalPayload;
    })();

    gov.ElectorateUpdatePayload = (function() {

        /**
         * Properties of an ElectorateUpdatePayload.
         * @memberof gov
         * @interface IElectorateUpdatePayload
         * @property {Array.<gov.IElector>|null} [diffElectors] with weight=0.
         */

        /**
         * Constructs a new ElectorateUpdatePayload.
         * @memberof gov
         * @classdesc Represents an ElectorateUpdatePayload.
         * @implements IElectorateUpdatePayload
         * @constructor
         * @param {gov.IElectorateUpdatePayload=} [properties] Properties to set
         */
        function ElectorateUpdatePayload(properties) {
            this.diffElectors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * with weight=0.
         * @member {Array.<gov.IElector>} diffElectors
         * @memberof gov.ElectorateUpdatePayload
         * @instance
         */
        ElectorateUpdatePayload.prototype.diffElectors = $util.emptyArray;

        /**
         * Creates a new ElectorateUpdatePayload instance using the specified properties.
         * @function create
         * @memberof gov.ElectorateUpdatePayload
         * @static
         * @param {gov.IElectorateUpdatePayload=} [properties] Properties to set
         * @returns {gov.ElectorateUpdatePayload} ElectorateUpdatePayload instance
         */
        ElectorateUpdatePayload.create = function create(properties) {
            return new ElectorateUpdatePayload(properties);
        };

        /**
         * Encodes the specified ElectorateUpdatePayload message. Does not implicitly {@link gov.ElectorateUpdatePayload.verify|verify} messages.
         * @function encode
         * @memberof gov.ElectorateUpdatePayload
         * @static
         * @param {gov.IElectorateUpdatePayload} message ElectorateUpdatePayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ElectorateUpdatePayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.diffElectors != null && message.diffElectors.length)
                for (var i = 0; i < message.diffElectors.length; ++i)
                    $root.gov.Elector.encode(message.diffElectors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ElectorateUpdatePayload message, length delimited. Does not implicitly {@link gov.ElectorateUpdatePayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.ElectorateUpdatePayload
         * @static
         * @param {gov.IElectorateUpdatePayload} message ElectorateUpdatePayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ElectorateUpdatePayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ElectorateUpdatePayload message from the specified reader or buffer.
         * @function decode
         * @memberof gov.ElectorateUpdatePayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.ElectorateUpdatePayload} ElectorateUpdatePayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ElectorateUpdatePayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.ElectorateUpdatePayload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.diffElectors && message.diffElectors.length))
                        message.diffElectors = [];
                    message.diffElectors.push($root.gov.Elector.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ElectorateUpdatePayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.ElectorateUpdatePayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.ElectorateUpdatePayload} ElectorateUpdatePayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ElectorateUpdatePayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ElectorateUpdatePayload message.
         * @function verify
         * @memberof gov.ElectorateUpdatePayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ElectorateUpdatePayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.diffElectors != null && message.hasOwnProperty("diffElectors")) {
                if (!Array.isArray(message.diffElectors))
                    return "diffElectors: array expected";
                for (var i = 0; i < message.diffElectors.length; ++i) {
                    var error = $root.gov.Elector.verify(message.diffElectors[i]);
                    if (error)
                        return "diffElectors." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ElectorateUpdatePayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.ElectorateUpdatePayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.ElectorateUpdatePayload} ElectorateUpdatePayload
         */
        ElectorateUpdatePayload.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.ElectorateUpdatePayload)
                return object;
            var message = new $root.gov.ElectorateUpdatePayload();
            if (object.diffElectors) {
                if (!Array.isArray(object.diffElectors))
                    throw TypeError(".gov.ElectorateUpdatePayload.diffElectors: array expected");
                message.diffElectors = [];
                for (var i = 0; i < object.diffElectors.length; ++i) {
                    if (typeof object.diffElectors[i] !== "object")
                        throw TypeError(".gov.ElectorateUpdatePayload.diffElectors: object expected");
                    message.diffElectors[i] = $root.gov.Elector.fromObject(object.diffElectors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ElectorateUpdatePayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.ElectorateUpdatePayload
         * @static
         * @param {gov.ElectorateUpdatePayload} message ElectorateUpdatePayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ElectorateUpdatePayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.diffElectors = [];
            if (message.diffElectors && message.diffElectors.length) {
                object.diffElectors = [];
                for (var j = 0; j < message.diffElectors.length; ++j)
                    object.diffElectors[j] = $root.gov.Elector.toObject(message.diffElectors[j], options);
            }
            return object;
        };

        /**
         * Converts this ElectorateUpdatePayload to JSON.
         * @function toJSON
         * @memberof gov.ElectorateUpdatePayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ElectorateUpdatePayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ElectorateUpdatePayload;
    })();

    gov.Proposal = (function() {

        /**
         * Properties of a Proposal.
         * @memberof gov
         * @interface IProposal
         * @property {weave.IMetadata|null} [metadata] Proposal metadata
         * @property {string|null} [title] Human readable title.
         * @property {string|null} [description] Description of the proposal in text form.
         * @property {orm.IVersionedIDRef|null} [electionRuleRef] ElectionRuleRef is a reference to the election rule
         * @property {orm.IVersionedIDRef|null} [electorateRef] Reference to the electorate to define the group of possible voters.
         * @property {number|Long|null} [votingStartTime] to this start time.
         * @property {number|Long|null} [votingEndTime] to be included in the election.
         * @property {number|Long|null} [submissionTime] Unix timestamp of the block where the proposal was added to the chain.
         * @property {Uint8Array|null} [author] Address of the author who created the proposal. If not set explicit on creation it will default to the main signer.
         * @property {gov.ITallyResult|null} [voteState] Result of the election. Contains intermediate tally results while voting period is open.
         * @property {gov.Proposal.Status|null} [status] Status represents the high level position in the life cycle of the proposal. Initial value is submitted.
         * @property {gov.Proposal.Result|null} [result] Result is the final result based on the votes and election rule. Initial value is Undefined.
         * @property {gov.Proposal.Type|null} [type] Proposal type
         * @property {gov.ITextProposalPayload|null} [textDetails] Proposal textDetails
         * @property {gov.IElectorateUpdatePayload|null} [electorateUpdateDetails] Proposal electorateUpdateDetails
         */

        /**
         * Constructs a new Proposal.
         * @memberof gov
         * @classdesc A generic proposal for an on-chain governance process.
         * @implements IProposal
         * @constructor
         * @param {gov.IProposal=} [properties] Properties to set
         */
        function Proposal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Proposal metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.metadata = null;

        /**
         * Human readable title.
         * @member {string} title
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.title = "";

        /**
         * Description of the proposal in text form.
         * @member {string} description
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.description = "";

        /**
         * ElectionRuleRef is a reference to the election rule
         * @member {orm.IVersionedIDRef|null|undefined} electionRuleRef
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.electionRuleRef = null;

        /**
         * Reference to the electorate to define the group of possible voters.
         * @member {orm.IVersionedIDRef|null|undefined} electorateRef
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.electorateRef = null;

        /**
         * to this start time.
         * @member {number|Long} votingStartTime
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.votingStartTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * to be included in the election.
         * @member {number|Long} votingEndTime
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.votingEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Unix timestamp of the block where the proposal was added to the chain.
         * @member {number|Long} submissionTime
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.submissionTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Address of the author who created the proposal. If not set explicit on creation it will default to the main signer.
         * @member {Uint8Array} author
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.author = $util.newBuffer([]);

        /**
         * Result of the election. Contains intermediate tally results while voting period is open.
         * @member {gov.ITallyResult|null|undefined} voteState
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.voteState = null;

        /**
         * Status represents the high level position in the life cycle of the proposal. Initial value is submitted.
         * @member {gov.Proposal.Status} status
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.status = 0;

        /**
         * Result is the final result based on the votes and election rule. Initial value is Undefined.
         * @member {gov.Proposal.Result} result
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.result = 0;

        /**
         * Proposal type.
         * @member {gov.Proposal.Type} type
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.type = 0;

        /**
         * Proposal textDetails.
         * @member {gov.ITextProposalPayload|null|undefined} textDetails
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.textDetails = null;

        /**
         * Proposal electorateUpdateDetails.
         * @member {gov.IElectorateUpdatePayload|null|undefined} electorateUpdateDetails
         * @memberof gov.Proposal
         * @instance
         */
        Proposal.prototype.electorateUpdateDetails = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * details
         * @member {"textDetails"|"electorateUpdateDetails"|undefined} details
         * @memberof gov.Proposal
         * @instance
         */
        Object.defineProperty(Proposal.prototype, "details", {
            get: $util.oneOfGetter($oneOfFields = ["textDetails", "electorateUpdateDetails"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Proposal instance using the specified properties.
         * @function create
         * @memberof gov.Proposal
         * @static
         * @param {gov.IProposal=} [properties] Properties to set
         * @returns {gov.Proposal} Proposal instance
         */
        Proposal.create = function create(properties) {
            return new Proposal(properties);
        };

        /**
         * Encodes the specified Proposal message. Does not implicitly {@link gov.Proposal.verify|verify} messages.
         * @function encode
         * @memberof gov.Proposal
         * @static
         * @param {gov.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
            if (message.electionRuleRef != null && message.hasOwnProperty("electionRuleRef"))
                $root.orm.VersionedIDRef.encode(message.electionRuleRef, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.electorateRef != null && message.hasOwnProperty("electorateRef"))
                $root.orm.VersionedIDRef.encode(message.electorateRef, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.votingStartTime != null && message.hasOwnProperty("votingStartTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.votingStartTime);
            if (message.votingEndTime != null && message.hasOwnProperty("votingEndTime"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.votingEndTime);
            if (message.submissionTime != null && message.hasOwnProperty("submissionTime"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.submissionTime);
            if (message.author != null && message.hasOwnProperty("author"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.author);
            if (message.voteState != null && message.hasOwnProperty("voteState"))
                $root.gov.TallyResult.encode(message.voteState, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.status);
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.result);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.type);
            if (message.textDetails != null && message.hasOwnProperty("textDetails"))
                $root.gov.TextProposalPayload.encode(message.textDetails, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
            if (message.electorateUpdateDetails != null && message.hasOwnProperty("electorateUpdateDetails"))
                $root.gov.ElectorateUpdatePayload.encode(message.electorateUpdateDetails, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Proposal message, length delimited. Does not implicitly {@link gov.Proposal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Proposal
         * @static
         * @param {gov.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Proposal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.electionRuleRef = $root.orm.VersionedIDRef.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.electorateRef = $root.orm.VersionedIDRef.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.votingStartTime = reader.int64();
                    break;
                case 7:
                    message.votingEndTime = reader.int64();
                    break;
                case 8:
                    message.submissionTime = reader.int64();
                    break;
                case 9:
                    message.author = reader.bytes();
                    break;
                case 10:
                    message.voteState = $root.gov.TallyResult.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.status = reader.int32();
                    break;
                case 12:
                    message.result = reader.int32();
                    break;
                case 13:
                    message.type = reader.int32();
                    break;
                case 50:
                    message.textDetails = $root.gov.TextProposalPayload.decode(reader, reader.uint32());
                    break;
                case 51:
                    message.electorateUpdateDetails = $root.gov.ElectorateUpdatePayload.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Proposal message.
         * @function verify
         * @memberof gov.Proposal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Proposal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.electionRuleRef != null && message.hasOwnProperty("electionRuleRef")) {
                var error = $root.orm.VersionedIDRef.verify(message.electionRuleRef);
                if (error)
                    return "electionRuleRef." + error;
            }
            if (message.electorateRef != null && message.hasOwnProperty("electorateRef")) {
                var error = $root.orm.VersionedIDRef.verify(message.electorateRef);
                if (error)
                    return "electorateRef." + error;
            }
            if (message.votingStartTime != null && message.hasOwnProperty("votingStartTime"))
                if (!$util.isInteger(message.votingStartTime) && !(message.votingStartTime && $util.isInteger(message.votingStartTime.low) && $util.isInteger(message.votingStartTime.high)))
                    return "votingStartTime: integer|Long expected";
            if (message.votingEndTime != null && message.hasOwnProperty("votingEndTime"))
                if (!$util.isInteger(message.votingEndTime) && !(message.votingEndTime && $util.isInteger(message.votingEndTime.low) && $util.isInteger(message.votingEndTime.high)))
                    return "votingEndTime: integer|Long expected";
            if (message.submissionTime != null && message.hasOwnProperty("submissionTime"))
                if (!$util.isInteger(message.submissionTime) && !(message.submissionTime && $util.isInteger(message.submissionTime.low) && $util.isInteger(message.submissionTime.high)))
                    return "submissionTime: integer|Long expected";
            if (message.author != null && message.hasOwnProperty("author"))
                if (!(message.author && typeof message.author.length === "number" || $util.isString(message.author)))
                    return "author: buffer expected";
            if (message.voteState != null && message.hasOwnProperty("voteState")) {
                var error = $root.gov.TallyResult.verify(message.voteState);
                if (error)
                    return "voteState." + error;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.textDetails != null && message.hasOwnProperty("textDetails")) {
                properties.details = 1;
                {
                    var error = $root.gov.TextProposalPayload.verify(message.textDetails);
                    if (error)
                        return "textDetails." + error;
                }
            }
            if (message.electorateUpdateDetails != null && message.hasOwnProperty("electorateUpdateDetails")) {
                if (properties.details === 1)
                    return "details: multiple values";
                properties.details = 1;
                {
                    var error = $root.gov.ElectorateUpdatePayload.verify(message.electorateUpdateDetails);
                    if (error)
                        return "electorateUpdateDetails." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Proposal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Proposal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Proposal} Proposal
         */
        Proposal.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Proposal)
                return object;
            var message = new $root.gov.Proposal();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.Proposal.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.title != null)
                message.title = String(object.title);
            if (object.description != null)
                message.description = String(object.description);
            if (object.electionRuleRef != null) {
                if (typeof object.electionRuleRef !== "object")
                    throw TypeError(".gov.Proposal.electionRuleRef: object expected");
                message.electionRuleRef = $root.orm.VersionedIDRef.fromObject(object.electionRuleRef);
            }
            if (object.electorateRef != null) {
                if (typeof object.electorateRef !== "object")
                    throw TypeError(".gov.Proposal.electorateRef: object expected");
                message.electorateRef = $root.orm.VersionedIDRef.fromObject(object.electorateRef);
            }
            if (object.votingStartTime != null)
                if ($util.Long)
                    (message.votingStartTime = $util.Long.fromValue(object.votingStartTime)).unsigned = false;
                else if (typeof object.votingStartTime === "string")
                    message.votingStartTime = parseInt(object.votingStartTime, 10);
                else if (typeof object.votingStartTime === "number")
                    message.votingStartTime = object.votingStartTime;
                else if (typeof object.votingStartTime === "object")
                    message.votingStartTime = new $util.LongBits(object.votingStartTime.low >>> 0, object.votingStartTime.high >>> 0).toNumber();
            if (object.votingEndTime != null)
                if ($util.Long)
                    (message.votingEndTime = $util.Long.fromValue(object.votingEndTime)).unsigned = false;
                else if (typeof object.votingEndTime === "string")
                    message.votingEndTime = parseInt(object.votingEndTime, 10);
                else if (typeof object.votingEndTime === "number")
                    message.votingEndTime = object.votingEndTime;
                else if (typeof object.votingEndTime === "object")
                    message.votingEndTime = new $util.LongBits(object.votingEndTime.low >>> 0, object.votingEndTime.high >>> 0).toNumber();
            if (object.submissionTime != null)
                if ($util.Long)
                    (message.submissionTime = $util.Long.fromValue(object.submissionTime)).unsigned = false;
                else if (typeof object.submissionTime === "string")
                    message.submissionTime = parseInt(object.submissionTime, 10);
                else if (typeof object.submissionTime === "number")
                    message.submissionTime = object.submissionTime;
                else if (typeof object.submissionTime === "object")
                    message.submissionTime = new $util.LongBits(object.submissionTime.low >>> 0, object.submissionTime.high >>> 0).toNumber();
            if (object.author != null)
                if (typeof object.author === "string")
                    $util.base64.decode(object.author, message.author = $util.newBuffer($util.base64.length(object.author)), 0);
                else if (object.author.length)
                    message.author = object.author;
            if (object.voteState != null) {
                if (typeof object.voteState !== "object")
                    throw TypeError(".gov.Proposal.voteState: object expected");
                message.voteState = $root.gov.TallyResult.fromObject(object.voteState);
            }
            switch (object.status) {
            case "PROPOSAL_STATUS_INVALID":
            case 0:
                message.status = 0;
                break;
            case "PROPOSAL_STATUS_SUBMITTED":
            case 1:
                message.status = 1;
                break;
            case "PROPOSAL_STATUS_CLOSED":
            case 2:
                message.status = 2;
                break;
            case "PROPOSAL_STATUS_WITHDRAWN":
            case 3:
                message.status = 3;
                break;
            }
            switch (object.result) {
            case "PROPOSAL_RESULT_INVALID":
            case 0:
                message.result = 0;
                break;
            case "PROPOSAL_RESULT_UNDEFINED":
            case 1:
                message.result = 1;
                break;
            case "PROPOSAL_RESULT_ACCEPTED":
            case 2:
                message.result = 2;
                break;
            case "PROPOSAL_RESULT_REJECTED":
            case 3:
                message.result = 3;
                break;
            }
            switch (object.type) {
            case "PROPOSAL_TYPE_INVALID":
            case 0:
                message.type = 0;
                break;
            case "PROPOSAL_TYPE_TEXT":
            case 1:
                message.type = 1;
                break;
            case "PROPOSAL_TYPE_UPDATE_ELECTORATE":
            case 2:
                message.type = 2;
                break;
            }
            if (object.textDetails != null) {
                if (typeof object.textDetails !== "object")
                    throw TypeError(".gov.Proposal.textDetails: object expected");
                message.textDetails = $root.gov.TextProposalPayload.fromObject(object.textDetails);
            }
            if (object.electorateUpdateDetails != null) {
                if (typeof object.electorateUpdateDetails !== "object")
                    throw TypeError(".gov.Proposal.electorateUpdateDetails: object expected");
                message.electorateUpdateDetails = $root.gov.ElectorateUpdatePayload.fromObject(object.electorateUpdateDetails);
            }
            return message;
        };

        /**
         * Creates a plain object from a Proposal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Proposal
         * @static
         * @param {gov.Proposal} message Proposal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Proposal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.title = "";
                object.description = "";
                object.electionRuleRef = null;
                object.electorateRef = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.votingStartTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.votingStartTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.votingEndTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.votingEndTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.submissionTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.submissionTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.author = "";
                else {
                    object.author = [];
                    if (options.bytes !== Array)
                        object.author = $util.newBuffer(object.author);
                }
                object.voteState = null;
                object.status = options.enums === String ? "PROPOSAL_STATUS_INVALID" : 0;
                object.result = options.enums === String ? "PROPOSAL_RESULT_INVALID" : 0;
                object.type = options.enums === String ? "PROPOSAL_TYPE_INVALID" : 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.electionRuleRef != null && message.hasOwnProperty("electionRuleRef"))
                object.electionRuleRef = $root.orm.VersionedIDRef.toObject(message.electionRuleRef, options);
            if (message.electorateRef != null && message.hasOwnProperty("electorateRef"))
                object.electorateRef = $root.orm.VersionedIDRef.toObject(message.electorateRef, options);
            if (message.votingStartTime != null && message.hasOwnProperty("votingStartTime"))
                if (typeof message.votingStartTime === "number")
                    object.votingStartTime = options.longs === String ? String(message.votingStartTime) : message.votingStartTime;
                else
                    object.votingStartTime = options.longs === String ? $util.Long.prototype.toString.call(message.votingStartTime) : options.longs === Number ? new $util.LongBits(message.votingStartTime.low >>> 0, message.votingStartTime.high >>> 0).toNumber() : message.votingStartTime;
            if (message.votingEndTime != null && message.hasOwnProperty("votingEndTime"))
                if (typeof message.votingEndTime === "number")
                    object.votingEndTime = options.longs === String ? String(message.votingEndTime) : message.votingEndTime;
                else
                    object.votingEndTime = options.longs === String ? $util.Long.prototype.toString.call(message.votingEndTime) : options.longs === Number ? new $util.LongBits(message.votingEndTime.low >>> 0, message.votingEndTime.high >>> 0).toNumber() : message.votingEndTime;
            if (message.submissionTime != null && message.hasOwnProperty("submissionTime"))
                if (typeof message.submissionTime === "number")
                    object.submissionTime = options.longs === String ? String(message.submissionTime) : message.submissionTime;
                else
                    object.submissionTime = options.longs === String ? $util.Long.prototype.toString.call(message.submissionTime) : options.longs === Number ? new $util.LongBits(message.submissionTime.low >>> 0, message.submissionTime.high >>> 0).toNumber() : message.submissionTime;
            if (message.author != null && message.hasOwnProperty("author"))
                object.author = options.bytes === String ? $util.base64.encode(message.author, 0, message.author.length) : options.bytes === Array ? Array.prototype.slice.call(message.author) : message.author;
            if (message.voteState != null && message.hasOwnProperty("voteState"))
                object.voteState = $root.gov.TallyResult.toObject(message.voteState, options);
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.gov.Proposal.Status[message.status] : message.status;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.gov.Proposal.Result[message.result] : message.result;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.gov.Proposal.Type[message.type] : message.type;
            if (message.textDetails != null && message.hasOwnProperty("textDetails")) {
                object.textDetails = $root.gov.TextProposalPayload.toObject(message.textDetails, options);
                if (options.oneofs)
                    object.details = "textDetails";
            }
            if (message.electorateUpdateDetails != null && message.hasOwnProperty("electorateUpdateDetails")) {
                object.electorateUpdateDetails = $root.gov.ElectorateUpdatePayload.toObject(message.electorateUpdateDetails, options);
                if (options.oneofs)
                    object.details = "electorateUpdateDetails";
            }
            return object;
        };

        /**
         * Converts this Proposal to JSON.
         * @function toJSON
         * @memberof gov.Proposal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Proposal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name gov.Proposal.Status
         * @enum {string}
         * @property {number} PROPOSAL_STATUS_INVALID=0 An empty value is invalid and not allowed
         * @property {number} PROPOSAL_STATUS_SUBMITTED=1 Initial status of a proposal when persisted.
         * @property {number} PROPOSAL_STATUS_CLOSED=2 Final status of a proposal when the tally was executed
         * @property {number} PROPOSAL_STATUS_WITHDRAWN=3 is Withdrawn.
         */
        Proposal.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PROPOSAL_STATUS_INVALID"] = 0;
            values[valuesById[1] = "PROPOSAL_STATUS_SUBMITTED"] = 1;
            values[valuesById[2] = "PROPOSAL_STATUS_CLOSED"] = 2;
            values[valuesById[3] = "PROPOSAL_STATUS_WITHDRAWN"] = 3;
            return values;
        })();

        /**
         * Result enum.
         * @name gov.Proposal.Result
         * @enum {string}
         * @property {number} PROPOSAL_RESULT_INVALID=0 An empty value is invalid and not allowed
         * @property {number} PROPOSAL_RESULT_UNDEFINED=1 Until a final tally has happened the status is undefined
         * @property {number} PROPOSAL_RESULT_ACCEPTED=2 Final result of the tally
         * @property {number} PROPOSAL_RESULT_REJECTED=3 Final result of the tally
         */
        Proposal.Result = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PROPOSAL_RESULT_INVALID"] = 0;
            values[valuesById[1] = "PROPOSAL_RESULT_UNDEFINED"] = 1;
            values[valuesById[2] = "PROPOSAL_RESULT_ACCEPTED"] = 2;
            values[valuesById[3] = "PROPOSAL_RESULT_REJECTED"] = 3;
            return values;
        })();

        /**
         * Type enum.
         * @name gov.Proposal.Type
         * @enum {string}
         * @property {number} PROPOSAL_TYPE_INVALID=0 None is invalid and not allowed
         * @property {number} PROPOSAL_TYPE_TEXT=1 Text
         * @property {number} PROPOSAL_TYPE_UPDATE_ELECTORATE=2 UpdateElectorate
         */
        Proposal.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PROPOSAL_TYPE_INVALID"] = 0;
            values[valuesById[1] = "PROPOSAL_TYPE_TEXT"] = 1;
            values[valuesById[2] = "PROPOSAL_TYPE_UPDATE_ELECTORATE"] = 2;
            return values;
        })();

        return Proposal;
    })();

    gov.TallyResult = (function() {

        /**
         * Properties of a TallyResult.
         * @memberof gov
         * @interface ITallyResult
         * @property {number|Long|null} [totalYes] TotalYes is the sum of weights of all the voters that approved the proposal
         * @property {number|Long|null} [totalNo] TotalNo is the sum of weights of all the voters that rejected the proposal
         * @property {number|Long|null} [totalAbstain] TotalAbstain is the sum of weights of all the voters that voted abstain
         * @property {number|Long|null} [totalElectorateWeight] TotalElectorateWeight is the sum of all weights in the electorate.
         * @property {gov.IFraction|null} [quorum] Quorum when set is the fraction of the total electorate weight that must be exceeded by total votes weight.
         * @property {gov.IFraction|null} [threshold] The base value is either the total electorate weight or the sum of Yes/No weights when a quorum is defined.
         */

        /**
         * Constructs a new TallyResult.
         * @memberof gov
         * @classdesc TallyResult contains sums of the votes and all data for the final result.
         * @implements ITallyResult
         * @constructor
         * @param {gov.ITallyResult=} [properties] Properties to set
         */
        function TallyResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TotalYes is the sum of weights of all the voters that approved the proposal
         * @member {number|Long} totalYes
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.totalYes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TotalNo is the sum of weights of all the voters that rejected the proposal
         * @member {number|Long} totalNo
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.totalNo = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TotalAbstain is the sum of weights of all the voters that voted abstain
         * @member {number|Long} totalAbstain
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.totalAbstain = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * TotalElectorateWeight is the sum of all weights in the electorate.
         * @member {number|Long} totalElectorateWeight
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.totalElectorateWeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Quorum when set is the fraction of the total electorate weight that must be exceeded by total votes weight.
         * @member {gov.IFraction|null|undefined} quorum
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.quorum = null;

        /**
         * The base value is either the total electorate weight or the sum of Yes/No weights when a quorum is defined.
         * @member {gov.IFraction|null|undefined} threshold
         * @memberof gov.TallyResult
         * @instance
         */
        TallyResult.prototype.threshold = null;

        /**
         * Creates a new TallyResult instance using the specified properties.
         * @function create
         * @memberof gov.TallyResult
         * @static
         * @param {gov.ITallyResult=} [properties] Properties to set
         * @returns {gov.TallyResult} TallyResult instance
         */
        TallyResult.create = function create(properties) {
            return new TallyResult(properties);
        };

        /**
         * Encodes the specified TallyResult message. Does not implicitly {@link gov.TallyResult.verify|verify} messages.
         * @function encode
         * @memberof gov.TallyResult
         * @static
         * @param {gov.ITallyResult} message TallyResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TallyResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalYes != null && message.hasOwnProperty("totalYes"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.totalYes);
            if (message.totalNo != null && message.hasOwnProperty("totalNo"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.totalNo);
            if (message.totalAbstain != null && message.hasOwnProperty("totalAbstain"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.totalAbstain);
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.totalElectorateWeight);
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                $root.gov.Fraction.encode(message.quorum, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                $root.gov.Fraction.encode(message.threshold, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TallyResult message, length delimited. Does not implicitly {@link gov.TallyResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.TallyResult
         * @static
         * @param {gov.ITallyResult} message TallyResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TallyResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TallyResult message from the specified reader or buffer.
         * @function decode
         * @memberof gov.TallyResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.TallyResult} TallyResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TallyResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.TallyResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalYes = reader.uint64();
                    break;
                case 2:
                    message.totalNo = reader.uint64();
                    break;
                case 3:
                    message.totalAbstain = reader.uint64();
                    break;
                case 4:
                    message.totalElectorateWeight = reader.uint64();
                    break;
                case 5:
                    message.quorum = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.threshold = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TallyResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.TallyResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.TallyResult} TallyResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TallyResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TallyResult message.
         * @function verify
         * @memberof gov.TallyResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TallyResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalYes != null && message.hasOwnProperty("totalYes"))
                if (!$util.isInteger(message.totalYes) && !(message.totalYes && $util.isInteger(message.totalYes.low) && $util.isInteger(message.totalYes.high)))
                    return "totalYes: integer|Long expected";
            if (message.totalNo != null && message.hasOwnProperty("totalNo"))
                if (!$util.isInteger(message.totalNo) && !(message.totalNo && $util.isInteger(message.totalNo.low) && $util.isInteger(message.totalNo.high)))
                    return "totalNo: integer|Long expected";
            if (message.totalAbstain != null && message.hasOwnProperty("totalAbstain"))
                if (!$util.isInteger(message.totalAbstain) && !(message.totalAbstain && $util.isInteger(message.totalAbstain.low) && $util.isInteger(message.totalAbstain.high)))
                    return "totalAbstain: integer|Long expected";
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                if (!$util.isInteger(message.totalElectorateWeight) && !(message.totalElectorateWeight && $util.isInteger(message.totalElectorateWeight.low) && $util.isInteger(message.totalElectorateWeight.high)))
                    return "totalElectorateWeight: integer|Long expected";
            if (message.quorum != null && message.hasOwnProperty("quorum")) {
                var error = $root.gov.Fraction.verify(message.quorum);
                if (error)
                    return "quorum." + error;
            }
            if (message.threshold != null && message.hasOwnProperty("threshold")) {
                var error = $root.gov.Fraction.verify(message.threshold);
                if (error)
                    return "threshold." + error;
            }
            return null;
        };

        /**
         * Creates a TallyResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.TallyResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.TallyResult} TallyResult
         */
        TallyResult.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.TallyResult)
                return object;
            var message = new $root.gov.TallyResult();
            if (object.totalYes != null)
                if ($util.Long)
                    (message.totalYes = $util.Long.fromValue(object.totalYes)).unsigned = true;
                else if (typeof object.totalYes === "string")
                    message.totalYes = parseInt(object.totalYes, 10);
                else if (typeof object.totalYes === "number")
                    message.totalYes = object.totalYes;
                else if (typeof object.totalYes === "object")
                    message.totalYes = new $util.LongBits(object.totalYes.low >>> 0, object.totalYes.high >>> 0).toNumber(true);
            if (object.totalNo != null)
                if ($util.Long)
                    (message.totalNo = $util.Long.fromValue(object.totalNo)).unsigned = true;
                else if (typeof object.totalNo === "string")
                    message.totalNo = parseInt(object.totalNo, 10);
                else if (typeof object.totalNo === "number")
                    message.totalNo = object.totalNo;
                else if (typeof object.totalNo === "object")
                    message.totalNo = new $util.LongBits(object.totalNo.low >>> 0, object.totalNo.high >>> 0).toNumber(true);
            if (object.totalAbstain != null)
                if ($util.Long)
                    (message.totalAbstain = $util.Long.fromValue(object.totalAbstain)).unsigned = true;
                else if (typeof object.totalAbstain === "string")
                    message.totalAbstain = parseInt(object.totalAbstain, 10);
                else if (typeof object.totalAbstain === "number")
                    message.totalAbstain = object.totalAbstain;
                else if (typeof object.totalAbstain === "object")
                    message.totalAbstain = new $util.LongBits(object.totalAbstain.low >>> 0, object.totalAbstain.high >>> 0).toNumber(true);
            if (object.totalElectorateWeight != null)
                if ($util.Long)
                    (message.totalElectorateWeight = $util.Long.fromValue(object.totalElectorateWeight)).unsigned = true;
                else if (typeof object.totalElectorateWeight === "string")
                    message.totalElectorateWeight = parseInt(object.totalElectorateWeight, 10);
                else if (typeof object.totalElectorateWeight === "number")
                    message.totalElectorateWeight = object.totalElectorateWeight;
                else if (typeof object.totalElectorateWeight === "object")
                    message.totalElectorateWeight = new $util.LongBits(object.totalElectorateWeight.low >>> 0, object.totalElectorateWeight.high >>> 0).toNumber(true);
            if (object.quorum != null) {
                if (typeof object.quorum !== "object")
                    throw TypeError(".gov.TallyResult.quorum: object expected");
                message.quorum = $root.gov.Fraction.fromObject(object.quorum);
            }
            if (object.threshold != null) {
                if (typeof object.threshold !== "object")
                    throw TypeError(".gov.TallyResult.threshold: object expected");
                message.threshold = $root.gov.Fraction.fromObject(object.threshold);
            }
            return message;
        };

        /**
         * Creates a plain object from a TallyResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.TallyResult
         * @static
         * @param {gov.TallyResult} message TallyResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TallyResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalYes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalYes = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalNo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalNo = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalAbstain = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalAbstain = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.totalElectorateWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalElectorateWeight = options.longs === String ? "0" : 0;
                object.quorum = null;
                object.threshold = null;
            }
            if (message.totalYes != null && message.hasOwnProperty("totalYes"))
                if (typeof message.totalYes === "number")
                    object.totalYes = options.longs === String ? String(message.totalYes) : message.totalYes;
                else
                    object.totalYes = options.longs === String ? $util.Long.prototype.toString.call(message.totalYes) : options.longs === Number ? new $util.LongBits(message.totalYes.low >>> 0, message.totalYes.high >>> 0).toNumber(true) : message.totalYes;
            if (message.totalNo != null && message.hasOwnProperty("totalNo"))
                if (typeof message.totalNo === "number")
                    object.totalNo = options.longs === String ? String(message.totalNo) : message.totalNo;
                else
                    object.totalNo = options.longs === String ? $util.Long.prototype.toString.call(message.totalNo) : options.longs === Number ? new $util.LongBits(message.totalNo.low >>> 0, message.totalNo.high >>> 0).toNumber(true) : message.totalNo;
            if (message.totalAbstain != null && message.hasOwnProperty("totalAbstain"))
                if (typeof message.totalAbstain === "number")
                    object.totalAbstain = options.longs === String ? String(message.totalAbstain) : message.totalAbstain;
                else
                    object.totalAbstain = options.longs === String ? $util.Long.prototype.toString.call(message.totalAbstain) : options.longs === Number ? new $util.LongBits(message.totalAbstain.low >>> 0, message.totalAbstain.high >>> 0).toNumber(true) : message.totalAbstain;
            if (message.totalElectorateWeight != null && message.hasOwnProperty("totalElectorateWeight"))
                if (typeof message.totalElectorateWeight === "number")
                    object.totalElectorateWeight = options.longs === String ? String(message.totalElectorateWeight) : message.totalElectorateWeight;
                else
                    object.totalElectorateWeight = options.longs === String ? $util.Long.prototype.toString.call(message.totalElectorateWeight) : options.longs === Number ? new $util.LongBits(message.totalElectorateWeight.low >>> 0, message.totalElectorateWeight.high >>> 0).toNumber(true) : message.totalElectorateWeight;
            if (message.quorum != null && message.hasOwnProperty("quorum"))
                object.quorum = $root.gov.Fraction.toObject(message.quorum, options);
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                object.threshold = $root.gov.Fraction.toObject(message.threshold, options);
            return object;
        };

        /**
         * Converts this TallyResult to JSON.
         * @function toJSON
         * @memberof gov.TallyResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TallyResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TallyResult;
    })();

    gov.Vote = (function() {

        /**
         * Properties of a Vote.
         * @memberof gov
         * @interface IVote
         * @property {weave.IMetadata|null} [metadata] Vote metadata
         * @property {gov.IElector|null} [elector] Elector is who voted
         * @property {gov.VoteOption|null} [voted] VoteOption is what they voted
         */

        /**
         * Constructs a new Vote.
         * @memberof gov
         * @classdesc Vote combines the elector and their voted option to archive them. The proposalID and address is stored within the key.
         * @implements IVote
         * @constructor
         * @param {gov.IVote=} [properties] Properties to set
         */
        function Vote(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vote metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.Vote
         * @instance
         */
        Vote.prototype.metadata = null;

        /**
         * Elector is who voted
         * @member {gov.IElector|null|undefined} elector
         * @memberof gov.Vote
         * @instance
         */
        Vote.prototype.elector = null;

        /**
         * VoteOption is what they voted
         * @member {gov.VoteOption} voted
         * @memberof gov.Vote
         * @instance
         */
        Vote.prototype.voted = 0;

        /**
         * Creates a new Vote instance using the specified properties.
         * @function create
         * @memberof gov.Vote
         * @static
         * @param {gov.IVote=} [properties] Properties to set
         * @returns {gov.Vote} Vote instance
         */
        Vote.create = function create(properties) {
            return new Vote(properties);
        };

        /**
         * Encodes the specified Vote message. Does not implicitly {@link gov.Vote.verify|verify} messages.
         * @function encode
         * @memberof gov.Vote
         * @static
         * @param {gov.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.elector != null && message.hasOwnProperty("elector"))
                $root.gov.Elector.encode(message.elector, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.voted != null && message.hasOwnProperty("voted"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.voted);
            return writer;
        };

        /**
         * Encodes the specified Vote message, length delimited. Does not implicitly {@link gov.Vote.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.Vote
         * @static
         * @param {gov.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vote message from the specified reader or buffer.
         * @function decode
         * @memberof gov.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.Vote();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.elector = $root.gov.Elector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.voted = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vote message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vote message.
         * @function verify
         * @memberof gov.Vote
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vote.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.elector != null && message.hasOwnProperty("elector")) {
                var error = $root.gov.Elector.verify(message.elector);
                if (error)
                    return "elector." + error;
            }
            if (message.voted != null && message.hasOwnProperty("voted"))
                switch (message.voted) {
                default:
                    return "voted: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Vote message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.Vote
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.Vote} Vote
         */
        Vote.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.Vote)
                return object;
            var message = new $root.gov.Vote();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.Vote.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.elector != null) {
                if (typeof object.elector !== "object")
                    throw TypeError(".gov.Vote.elector: object expected");
                message.elector = $root.gov.Elector.fromObject(object.elector);
            }
            switch (object.voted) {
            case "VOTE_OPTION_INVALID":
            case 0:
                message.voted = 0;
                break;
            case "VOTE_OPTION_YES":
            case 1:
                message.voted = 1;
                break;
            case "VOTE_OPTION_NO":
            case 2:
                message.voted = 2;
                break;
            case "VOTE_OPTION_ABSTAIN":
            case 3:
                message.voted = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Vote message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.Vote
         * @static
         * @param {gov.Vote} message Vote
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vote.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.elector = null;
                object.voted = options.enums === String ? "VOTE_OPTION_INVALID" : 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.elector != null && message.hasOwnProperty("elector"))
                object.elector = $root.gov.Elector.toObject(message.elector, options);
            if (message.voted != null && message.hasOwnProperty("voted"))
                object.voted = options.enums === String ? $root.gov.VoteOption[message.voted] : message.voted;
            return object;
        };

        /**
         * Converts this Vote to JSON.
         * @function toJSON
         * @memberof gov.Vote
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vote.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Vote;
    })();

    gov.CreateTextProposalMsg = (function() {

        /**
         * Properties of a CreateTextProposalMsg.
         * @memberof gov
         * @interface ICreateTextProposalMsg
         * @property {weave.IMetadata|null} [metadata] CreateTextProposalMsg metadata
         * @property {string|null} [title] Human readable title. Must match `^[a-zA-Z0-9 _.-]{4,128}$`
         * @property {string|null} [description] Human readable description with 3 to 5000 chars.
         * @property {Uint8Array|null} [electionRuleId] ElectionRuleID is a reference to the election rule
         * @property {Uint8Array|null} [electorateId] ElectorateID is the reference to the electorate to define the group of possible voters.
         * @property {number|Long|null} [startTime] Unix timestamp when the proposal starts. Must be in the future.
         * @property {Uint8Array|null} [author] When not set it will default to the main signer.
         */

        /**
         * Constructs a new CreateTextProposalMsg.
         * @memberof gov
         * @classdesc CreateTextProposalMsg creates a new governance proposal.
         * @implements ICreateTextProposalMsg
         * @constructor
         * @param {gov.ICreateTextProposalMsg=} [properties] Properties to set
         */
        function CreateTextProposalMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateTextProposalMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.CreateTextProposalMsg
         * @instance
         */
        CreateTextProposalMsg.prototype.metadata = null;

        /**
         * Human readable title. Must match `^[a-zA-Z0-9 _.-]{4,128}$`
         * @member {string} title
         * @memberof gov.CreateTextProposalMsg
         * @instance
         */
        CreateTextProposalMsg.prototype.title = "";

        /**
         * Human readable description with 3 to 5000 chars.
         * @member {string} description
         * @memberof gov.CreateTextProposalMsg
         * @instance
         */
        CreateTextProposalMsg.prototype.description = "";

        /**
         * ElectionRuleID is a reference to the election rule
         * @member {Uint8Array} electionRuleId
         * @memberof gov.CreateTextProposalMsg
         * @instance
         */
        CreateTextProposalMsg.prototype.electionRuleId = $util.newBuffer([]);

        /**
         * ElectorateID is the reference to the electorate to define the group of possible voters.
         * @member {Uint8Array} electorateId
         * @memberof gov.CreateTextProposalMsg
         * @instance
         */
        CreateTextProposalMsg.prototype.electorateId = $util.newBuffer([]);

        /**
         * Unix timestamp when the proposal starts. Must be in the future.
         * @member {number|Long} startTime
         * @memberof gov.CreateTextProposalMsg
         * @instance
         */
        CreateTextProposalMsg.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * When not set it will default to the main signer.
         * @member {Uint8Array} author
         * @memberof gov.CreateTextProposalMsg
         * @instance
         */
        CreateTextProposalMsg.prototype.author = $util.newBuffer([]);

        /**
         * Creates a new CreateTextProposalMsg instance using the specified properties.
         * @function create
         * @memberof gov.CreateTextProposalMsg
         * @static
         * @param {gov.ICreateTextProposalMsg=} [properties] Properties to set
         * @returns {gov.CreateTextProposalMsg} CreateTextProposalMsg instance
         */
        CreateTextProposalMsg.create = function create(properties) {
            return new CreateTextProposalMsg(properties);
        };

        /**
         * Encodes the specified CreateTextProposalMsg message. Does not implicitly {@link gov.CreateTextProposalMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.CreateTextProposalMsg
         * @static
         * @param {gov.ICreateTextProposalMsg} message CreateTextProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTextProposalMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.electionRuleId);
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.electorateId);
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.startTime);
            if (message.author != null && message.hasOwnProperty("author"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.author);
            return writer;
        };

        /**
         * Encodes the specified CreateTextProposalMsg message, length delimited. Does not implicitly {@link gov.CreateTextProposalMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.CreateTextProposalMsg
         * @static
         * @param {gov.ICreateTextProposalMsg} message CreateTextProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateTextProposalMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateTextProposalMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.CreateTextProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.CreateTextProposalMsg} CreateTextProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTextProposalMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.CreateTextProposalMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.electionRuleId = reader.bytes();
                    break;
                case 5:
                    message.electorateId = reader.bytes();
                    break;
                case 6:
                    message.startTime = reader.int64();
                    break;
                case 7:
                    message.author = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateTextProposalMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.CreateTextProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.CreateTextProposalMsg} CreateTextProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateTextProposalMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateTextProposalMsg message.
         * @function verify
         * @memberof gov.CreateTextProposalMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateTextProposalMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                if (!(message.electionRuleId && typeof message.electionRuleId.length === "number" || $util.isString(message.electionRuleId)))
                    return "electionRuleId: buffer expected";
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                if (!(message.electorateId && typeof message.electorateId.length === "number" || $util.isString(message.electorateId)))
                    return "electorateId: buffer expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.author != null && message.hasOwnProperty("author"))
                if (!(message.author && typeof message.author.length === "number" || $util.isString(message.author)))
                    return "author: buffer expected";
            return null;
        };

        /**
         * Creates a CreateTextProposalMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.CreateTextProposalMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.CreateTextProposalMsg} CreateTextProposalMsg
         */
        CreateTextProposalMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.CreateTextProposalMsg)
                return object;
            var message = new $root.gov.CreateTextProposalMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.CreateTextProposalMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.title != null)
                message.title = String(object.title);
            if (object.description != null)
                message.description = String(object.description);
            if (object.electionRuleId != null)
                if (typeof object.electionRuleId === "string")
                    $util.base64.decode(object.electionRuleId, message.electionRuleId = $util.newBuffer($util.base64.length(object.electionRuleId)), 0);
                else if (object.electionRuleId.length)
                    message.electionRuleId = object.electionRuleId;
            if (object.electorateId != null)
                if (typeof object.electorateId === "string")
                    $util.base64.decode(object.electorateId, message.electorateId = $util.newBuffer($util.base64.length(object.electorateId)), 0);
                else if (object.electorateId.length)
                    message.electorateId = object.electorateId;
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.author != null)
                if (typeof object.author === "string")
                    $util.base64.decode(object.author, message.author = $util.newBuffer($util.base64.length(object.author)), 0);
                else if (object.author.length)
                    message.author = object.author;
            return message;
        };

        /**
         * Creates a plain object from a CreateTextProposalMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.CreateTextProposalMsg
         * @static
         * @param {gov.CreateTextProposalMsg} message CreateTextProposalMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateTextProposalMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.title = "";
                object.description = "";
                if (options.bytes === String)
                    object.electionRuleId = "";
                else {
                    object.electionRuleId = [];
                    if (options.bytes !== Array)
                        object.electionRuleId = $util.newBuffer(object.electionRuleId);
                }
                if (options.bytes === String)
                    object.electorateId = "";
                else {
                    object.electorateId = [];
                    if (options.bytes !== Array)
                        object.electorateId = $util.newBuffer(object.electorateId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.author = "";
                else {
                    object.author = [];
                    if (options.bytes !== Array)
                        object.author = $util.newBuffer(object.author);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                object.electionRuleId = options.bytes === String ? $util.base64.encode(message.electionRuleId, 0, message.electionRuleId.length) : options.bytes === Array ? Array.prototype.slice.call(message.electionRuleId) : message.electionRuleId;
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                object.electorateId = options.bytes === String ? $util.base64.encode(message.electorateId, 0, message.electorateId.length) : options.bytes === Array ? Array.prototype.slice.call(message.electorateId) : message.electorateId;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.author != null && message.hasOwnProperty("author"))
                object.author = options.bytes === String ? $util.base64.encode(message.author, 0, message.author.length) : options.bytes === Array ? Array.prototype.slice.call(message.author) : message.author;
            return object;
        };

        /**
         * Converts this CreateTextProposalMsg to JSON.
         * @function toJSON
         * @memberof gov.CreateTextProposalMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateTextProposalMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateTextProposalMsg;
    })();

    gov.CreateElectorateUpdateProposalMsg = (function() {

        /**
         * Properties of a CreateElectorateUpdateProposalMsg.
         * @memberof gov
         * @interface ICreateElectorateUpdateProposalMsg
         * @property {weave.IMetadata|null} [metadata] CreateElectorateUpdateProposalMsg metadata
         * @property {string|null} [title] Human readable title. Must match `^[a-zA-Z0-9 _.-]{4,128}$`
         * @property {string|null} [description] Human readable description with 3 to 5000 chars.
         * @property {Uint8Array|null} [electorateId] ElectorateID is the reference to the electorate that defines the group of possible voters.
         * @property {number|Long|null} [startTime] Unix timestamp when the proposal starts. Must be in the future.
         * @property {Uint8Array|null} [author] When not set it will default to the main signer.
         * @property {Array.<gov.IElector>|null} [diffElectors] with weight=0.
         */

        /**
         * Constructs a new CreateElectorateUpdateProposalMsg.
         * @memberof gov
         * @classdesc CreateElectorateUpdateProposalMsg creates a new governance proposal to update an electorate.
         * @implements ICreateElectorateUpdateProposalMsg
         * @constructor
         * @param {gov.ICreateElectorateUpdateProposalMsg=} [properties] Properties to set
         */
        function CreateElectorateUpdateProposalMsg(properties) {
            this.diffElectors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateElectorateUpdateProposalMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @instance
         */
        CreateElectorateUpdateProposalMsg.prototype.metadata = null;

        /**
         * Human readable title. Must match `^[a-zA-Z0-9 _.-]{4,128}$`
         * @member {string} title
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @instance
         */
        CreateElectorateUpdateProposalMsg.prototype.title = "";

        /**
         * Human readable description with 3 to 5000 chars.
         * @member {string} description
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @instance
         */
        CreateElectorateUpdateProposalMsg.prototype.description = "";

        /**
         * ElectorateID is the reference to the electorate that defines the group of possible voters.
         * @member {Uint8Array} electorateId
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @instance
         */
        CreateElectorateUpdateProposalMsg.prototype.electorateId = $util.newBuffer([]);

        /**
         * Unix timestamp when the proposal starts. Must be in the future.
         * @member {number|Long} startTime
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @instance
         */
        CreateElectorateUpdateProposalMsg.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * When not set it will default to the main signer.
         * @member {Uint8Array} author
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @instance
         */
        CreateElectorateUpdateProposalMsg.prototype.author = $util.newBuffer([]);

        /**
         * with weight=0.
         * @member {Array.<gov.IElector>} diffElectors
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @instance
         */
        CreateElectorateUpdateProposalMsg.prototype.diffElectors = $util.emptyArray;

        /**
         * Creates a new CreateElectorateUpdateProposalMsg instance using the specified properties.
         * @function create
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @static
         * @param {gov.ICreateElectorateUpdateProposalMsg=} [properties] Properties to set
         * @returns {gov.CreateElectorateUpdateProposalMsg} CreateElectorateUpdateProposalMsg instance
         */
        CreateElectorateUpdateProposalMsg.create = function create(properties) {
            return new CreateElectorateUpdateProposalMsg(properties);
        };

        /**
         * Encodes the specified CreateElectorateUpdateProposalMsg message. Does not implicitly {@link gov.CreateElectorateUpdateProposalMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @static
         * @param {gov.ICreateElectorateUpdateProposalMsg} message CreateElectorateUpdateProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateElectorateUpdateProposalMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.title != null && message.hasOwnProperty("title"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.electorateId);
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.startTime);
            if (message.author != null && message.hasOwnProperty("author"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.author);
            if (message.diffElectors != null && message.diffElectors.length)
                for (var i = 0; i < message.diffElectors.length; ++i)
                    $root.gov.Elector.encode(message.diffElectors[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateElectorateUpdateProposalMsg message, length delimited. Does not implicitly {@link gov.CreateElectorateUpdateProposalMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @static
         * @param {gov.ICreateElectorateUpdateProposalMsg} message CreateElectorateUpdateProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateElectorateUpdateProposalMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateElectorateUpdateProposalMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.CreateElectorateUpdateProposalMsg} CreateElectorateUpdateProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateElectorateUpdateProposalMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.CreateElectorateUpdateProposalMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.electorateId = reader.bytes();
                    break;
                case 5:
                    message.startTime = reader.int64();
                    break;
                case 6:
                    message.author = reader.bytes();
                    break;
                case 7:
                    if (!(message.diffElectors && message.diffElectors.length))
                        message.diffElectors = [];
                    message.diffElectors.push($root.gov.Elector.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateElectorateUpdateProposalMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.CreateElectorateUpdateProposalMsg} CreateElectorateUpdateProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateElectorateUpdateProposalMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateElectorateUpdateProposalMsg message.
         * @function verify
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateElectorateUpdateProposalMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                if (!(message.electorateId && typeof message.electorateId.length === "number" || $util.isString(message.electorateId)))
                    return "electorateId: buffer expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.author != null && message.hasOwnProperty("author"))
                if (!(message.author && typeof message.author.length === "number" || $util.isString(message.author)))
                    return "author: buffer expected";
            if (message.diffElectors != null && message.hasOwnProperty("diffElectors")) {
                if (!Array.isArray(message.diffElectors))
                    return "diffElectors: array expected";
                for (var i = 0; i < message.diffElectors.length; ++i) {
                    var error = $root.gov.Elector.verify(message.diffElectors[i]);
                    if (error)
                        return "diffElectors." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CreateElectorateUpdateProposalMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.CreateElectorateUpdateProposalMsg} CreateElectorateUpdateProposalMsg
         */
        CreateElectorateUpdateProposalMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.CreateElectorateUpdateProposalMsg)
                return object;
            var message = new $root.gov.CreateElectorateUpdateProposalMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.CreateElectorateUpdateProposalMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.title != null)
                message.title = String(object.title);
            if (object.description != null)
                message.description = String(object.description);
            if (object.electorateId != null)
                if (typeof object.electorateId === "string")
                    $util.base64.decode(object.electorateId, message.electorateId = $util.newBuffer($util.base64.length(object.electorateId)), 0);
                else if (object.electorateId.length)
                    message.electorateId = object.electorateId;
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = false;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber();
            if (object.author != null)
                if (typeof object.author === "string")
                    $util.base64.decode(object.author, message.author = $util.newBuffer($util.base64.length(object.author)), 0);
                else if (object.author.length)
                    message.author = object.author;
            if (object.diffElectors) {
                if (!Array.isArray(object.diffElectors))
                    throw TypeError(".gov.CreateElectorateUpdateProposalMsg.diffElectors: array expected");
                message.diffElectors = [];
                for (var i = 0; i < object.diffElectors.length; ++i) {
                    if (typeof object.diffElectors[i] !== "object")
                        throw TypeError(".gov.CreateElectorateUpdateProposalMsg.diffElectors: object expected");
                    message.diffElectors[i] = $root.gov.Elector.fromObject(object.diffElectors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateElectorateUpdateProposalMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @static
         * @param {gov.CreateElectorateUpdateProposalMsg} message CreateElectorateUpdateProposalMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateElectorateUpdateProposalMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.diffElectors = [];
            if (options.defaults) {
                object.metadata = null;
                object.title = "";
                object.description = "";
                if (options.bytes === String)
                    object.electorateId = "";
                else {
                    object.electorateId = [];
                    if (options.bytes !== Array)
                        object.electorateId = $util.newBuffer(object.electorateId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.author = "";
                else {
                    object.author = [];
                    if (options.bytes !== Array)
                        object.author = $util.newBuffer(object.author);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                object.electorateId = options.bytes === String ? $util.base64.encode(message.electorateId, 0, message.electorateId.length) : options.bytes === Array ? Array.prototype.slice.call(message.electorateId) : message.electorateId;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber() : message.startTime;
            if (message.author != null && message.hasOwnProperty("author"))
                object.author = options.bytes === String ? $util.base64.encode(message.author, 0, message.author.length) : options.bytes === Array ? Array.prototype.slice.call(message.author) : message.author;
            if (message.diffElectors && message.diffElectors.length) {
                object.diffElectors = [];
                for (var j = 0; j < message.diffElectors.length; ++j)
                    object.diffElectors[j] = $root.gov.Elector.toObject(message.diffElectors[j], options);
            }
            return object;
        };

        /**
         * Converts this CreateElectorateUpdateProposalMsg to JSON.
         * @function toJSON
         * @memberof gov.CreateElectorateUpdateProposalMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateElectorateUpdateProposalMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateElectorateUpdateProposalMsg;
    })();

    gov.DeleteProposalMsg = (function() {

        /**
         * Properties of a DeleteProposalMsg.
         * @memberof gov
         * @interface IDeleteProposalMsg
         * @property {weave.IMetadata|null} [metadata] DeleteProposalMsg metadata
         * @property {Uint8Array|null} [id] ID is the unique identifier of the proposal to delete
         */

        /**
         * Constructs a new DeleteProposalMsg.
         * @memberof gov
         * @classdesc DeleteProposalMsg deletes a governance proposal.
         * @implements IDeleteProposalMsg
         * @constructor
         * @param {gov.IDeleteProposalMsg=} [properties] Properties to set
         */
        function DeleteProposalMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteProposalMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.DeleteProposalMsg
         * @instance
         */
        DeleteProposalMsg.prototype.metadata = null;

        /**
         * ID is the unique identifier of the proposal to delete
         * @member {Uint8Array} id
         * @memberof gov.DeleteProposalMsg
         * @instance
         */
        DeleteProposalMsg.prototype.id = $util.newBuffer([]);

        /**
         * Creates a new DeleteProposalMsg instance using the specified properties.
         * @function create
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {gov.IDeleteProposalMsg=} [properties] Properties to set
         * @returns {gov.DeleteProposalMsg} DeleteProposalMsg instance
         */
        DeleteProposalMsg.create = function create(properties) {
            return new DeleteProposalMsg(properties);
        };

        /**
         * Encodes the specified DeleteProposalMsg message. Does not implicitly {@link gov.DeleteProposalMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {gov.IDeleteProposalMsg} message DeleteProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteProposalMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id);
            return writer;
        };

        /**
         * Encodes the specified DeleteProposalMsg message, length delimited. Does not implicitly {@link gov.DeleteProposalMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {gov.IDeleteProposalMsg} message DeleteProposalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteProposalMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteProposalMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.DeleteProposalMsg} DeleteProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteProposalMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.DeleteProposalMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteProposalMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.DeleteProposalMsg} DeleteProposalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteProposalMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteProposalMsg message.
         * @function verify
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteProposalMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            return null;
        };

        /**
         * Creates a DeleteProposalMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.DeleteProposalMsg} DeleteProposalMsg
         */
        DeleteProposalMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.DeleteProposalMsg)
                return object;
            var message = new $root.gov.DeleteProposalMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.DeleteProposalMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            return message;
        };

        /**
         * Creates a plain object from a DeleteProposalMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.DeleteProposalMsg
         * @static
         * @param {gov.DeleteProposalMsg} message DeleteProposalMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteProposalMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            return object;
        };

        /**
         * Converts this DeleteProposalMsg to JSON.
         * @function toJSON
         * @memberof gov.DeleteProposalMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteProposalMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteProposalMsg;
    })();

    /**
     * VoteOptions define possible values for a vote including the INVALID default.
     * @name gov.VoteOption
     * @enum {string}
     * @property {number} VOTE_OPTION_INVALID=0 VOTE_OPTION_INVALID value
     * @property {number} VOTE_OPTION_YES=1 VOTE_OPTION_YES value
     * @property {number} VOTE_OPTION_NO=2 VOTE_OPTION_NO value
     * @property {number} VOTE_OPTION_ABSTAIN=3 VOTE_OPTION_ABSTAIN value
     */
    gov.VoteOption = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VOTE_OPTION_INVALID"] = 0;
        values[valuesById[1] = "VOTE_OPTION_YES"] = 1;
        values[valuesById[2] = "VOTE_OPTION_NO"] = 2;
        values[valuesById[3] = "VOTE_OPTION_ABSTAIN"] = 3;
        return values;
    })();

    gov.VoteMsg = (function() {

        /**
         * Properties of a VoteMsg.
         * @memberof gov
         * @interface IVoteMsg
         * @property {weave.IMetadata|null} [metadata] VoteMsg metadata
         * @property {Uint8Array|null} [proposalId] The unique id of the proposal.
         * @property {Uint8Array|null} [voter] must be included in the electorate for a valid vote.
         * @property {gov.VoteOption|null} [selected] Option for the vote. Must be Yes, No or Abstain for a valid vote.
         */

        /**
         * Constructs a new VoteMsg.
         * @memberof gov
         * @classdesc VoteMsg is the way to express a voice and participate in an election of a proposal on chain.
         * @implements IVoteMsg
         * @constructor
         * @param {gov.IVoteMsg=} [properties] Properties to set
         */
        function VoteMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VoteMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.VoteMsg
         * @instance
         */
        VoteMsg.prototype.metadata = null;

        /**
         * The unique id of the proposal.
         * @member {Uint8Array} proposalId
         * @memberof gov.VoteMsg
         * @instance
         */
        VoteMsg.prototype.proposalId = $util.newBuffer([]);

        /**
         * must be included in the electorate for a valid vote.
         * @member {Uint8Array} voter
         * @memberof gov.VoteMsg
         * @instance
         */
        VoteMsg.prototype.voter = $util.newBuffer([]);

        /**
         * Option for the vote. Must be Yes, No or Abstain for a valid vote.
         * @member {gov.VoteOption} selected
         * @memberof gov.VoteMsg
         * @instance
         */
        VoteMsg.prototype.selected = 0;

        /**
         * Creates a new VoteMsg instance using the specified properties.
         * @function create
         * @memberof gov.VoteMsg
         * @static
         * @param {gov.IVoteMsg=} [properties] Properties to set
         * @returns {gov.VoteMsg} VoteMsg instance
         */
        VoteMsg.create = function create(properties) {
            return new VoteMsg(properties);
        };

        /**
         * Encodes the specified VoteMsg message. Does not implicitly {@link gov.VoteMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.VoteMsg
         * @static
         * @param {gov.IVoteMsg} message VoteMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.proposalId);
            if (message.voter != null && message.hasOwnProperty("voter"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.voter);
            if (message.selected != null && message.hasOwnProperty("selected"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.selected);
            return writer;
        };

        /**
         * Encodes the specified VoteMsg message, length delimited. Does not implicitly {@link gov.VoteMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.VoteMsg
         * @static
         * @param {gov.IVoteMsg} message VoteMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VoteMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.VoteMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.VoteMsg} VoteMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.VoteMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proposalId = reader.bytes();
                    break;
                case 3:
                    message.voter = reader.bytes();
                    break;
                case 4:
                    message.selected = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VoteMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.VoteMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.VoteMsg} VoteMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VoteMsg message.
         * @function verify
         * @memberof gov.VoteMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VoteMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!(message.proposalId && typeof message.proposalId.length === "number" || $util.isString(message.proposalId)))
                    return "proposalId: buffer expected";
            if (message.voter != null && message.hasOwnProperty("voter"))
                if (!(message.voter && typeof message.voter.length === "number" || $util.isString(message.voter)))
                    return "voter: buffer expected";
            if (message.selected != null && message.hasOwnProperty("selected"))
                switch (message.selected) {
                default:
                    return "selected: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a VoteMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.VoteMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.VoteMsg} VoteMsg
         */
        VoteMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.VoteMsg)
                return object;
            var message = new $root.gov.VoteMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.VoteMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.proposalId != null)
                if (typeof object.proposalId === "string")
                    $util.base64.decode(object.proposalId, message.proposalId = $util.newBuffer($util.base64.length(object.proposalId)), 0);
                else if (object.proposalId.length)
                    message.proposalId = object.proposalId;
            if (object.voter != null)
                if (typeof object.voter === "string")
                    $util.base64.decode(object.voter, message.voter = $util.newBuffer($util.base64.length(object.voter)), 0);
                else if (object.voter.length)
                    message.voter = object.voter;
            switch (object.selected) {
            case "VOTE_OPTION_INVALID":
            case 0:
                message.selected = 0;
                break;
            case "VOTE_OPTION_YES":
            case 1:
                message.selected = 1;
                break;
            case "VOTE_OPTION_NO":
            case 2:
                message.selected = 2;
                break;
            case "VOTE_OPTION_ABSTAIN":
            case 3:
                message.selected = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a VoteMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.VoteMsg
         * @static
         * @param {gov.VoteMsg} message VoteMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VoteMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.proposalId = "";
                else {
                    object.proposalId = [];
                    if (options.bytes !== Array)
                        object.proposalId = $util.newBuffer(object.proposalId);
                }
                if (options.bytes === String)
                    object.voter = "";
                else {
                    object.voter = [];
                    if (options.bytes !== Array)
                        object.voter = $util.newBuffer(object.voter);
                }
                object.selected = options.enums === String ? "VOTE_OPTION_INVALID" : 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                object.proposalId = options.bytes === String ? $util.base64.encode(message.proposalId, 0, message.proposalId.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposalId) : message.proposalId;
            if (message.voter != null && message.hasOwnProperty("voter"))
                object.voter = options.bytes === String ? $util.base64.encode(message.voter, 0, message.voter.length) : options.bytes === Array ? Array.prototype.slice.call(message.voter) : message.voter;
            if (message.selected != null && message.hasOwnProperty("selected"))
                object.selected = options.enums === String ? $root.gov.VoteOption[message.selected] : message.selected;
            return object;
        };

        /**
         * Converts this VoteMsg to JSON.
         * @function toJSON
         * @memberof gov.VoteMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VoteMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VoteMsg;
    })();

    gov.TallyMsg = (function() {

        /**
         * Properties of a TallyMsg.
         * @memberof gov
         * @interface ITallyMsg
         * @property {weave.IMetadata|null} [metadata] TallyMsg metadata
         * @property {Uint8Array|null} [proposalId] ProposalID is UUID of the proposal to close.
         */

        /**
         * Constructs a new TallyMsg.
         * @memberof gov
         * @classdesc A final tally can be execute only once. A second submission will fail with an invalid state error.
         * @implements ITallyMsg
         * @constructor
         * @param {gov.ITallyMsg=} [properties] Properties to set
         */
        function TallyMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TallyMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.TallyMsg
         * @instance
         */
        TallyMsg.prototype.metadata = null;

        /**
         * ProposalID is UUID of the proposal to close.
         * @member {Uint8Array} proposalId
         * @memberof gov.TallyMsg
         * @instance
         */
        TallyMsg.prototype.proposalId = $util.newBuffer([]);

        /**
         * Creates a new TallyMsg instance using the specified properties.
         * @function create
         * @memberof gov.TallyMsg
         * @static
         * @param {gov.ITallyMsg=} [properties] Properties to set
         * @returns {gov.TallyMsg} TallyMsg instance
         */
        TallyMsg.create = function create(properties) {
            return new TallyMsg(properties);
        };

        /**
         * Encodes the specified TallyMsg message. Does not implicitly {@link gov.TallyMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.TallyMsg
         * @static
         * @param {gov.ITallyMsg} message TallyMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TallyMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.proposalId);
            return writer;
        };

        /**
         * Encodes the specified TallyMsg message, length delimited. Does not implicitly {@link gov.TallyMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.TallyMsg
         * @static
         * @param {gov.ITallyMsg} message TallyMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TallyMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TallyMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.TallyMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.TallyMsg} TallyMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TallyMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.TallyMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.proposalId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TallyMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.TallyMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.TallyMsg} TallyMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TallyMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TallyMsg message.
         * @function verify
         * @memberof gov.TallyMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TallyMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                if (!(message.proposalId && typeof message.proposalId.length === "number" || $util.isString(message.proposalId)))
                    return "proposalId: buffer expected";
            return null;
        };

        /**
         * Creates a TallyMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.TallyMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.TallyMsg} TallyMsg
         */
        TallyMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.TallyMsg)
                return object;
            var message = new $root.gov.TallyMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.TallyMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.proposalId != null)
                if (typeof object.proposalId === "string")
                    $util.base64.decode(object.proposalId, message.proposalId = $util.newBuffer($util.base64.length(object.proposalId)), 0);
                else if (object.proposalId.length)
                    message.proposalId = object.proposalId;
            return message;
        };

        /**
         * Creates a plain object from a TallyMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.TallyMsg
         * @static
         * @param {gov.TallyMsg} message TallyMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TallyMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.proposalId = "";
                else {
                    object.proposalId = [];
                    if (options.bytes !== Array)
                        object.proposalId = $util.newBuffer(object.proposalId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.proposalId != null && message.hasOwnProperty("proposalId"))
                object.proposalId = options.bytes === String ? $util.base64.encode(message.proposalId, 0, message.proposalId.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposalId) : message.proposalId;
            return object;
        };

        /**
         * Converts this TallyMsg to JSON.
         * @function toJSON
         * @memberof gov.TallyMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TallyMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TallyMsg;
    })();

    gov.UpdateElectorateMsg = (function() {

        /**
         * Properties of an UpdateElectorateMsg.
         * @memberof gov
         * @interface IUpdateElectorateMsg
         * @property {weave.IMetadata|null} [metadata] UpdateElectorateMsg metadata
         * @property {Uint8Array|null} [electorateId] ElectorateID is the reference to the electorate that defines the group of possible voters.
         * @property {Array.<gov.IElector>|null} [diffElectors] with weight=0.
         */

        /**
         * Constructs a new UpdateElectorateMsg.
         * @memberof gov
         * @classdesc Represents an UpdateElectorateMsg.
         * @implements IUpdateElectorateMsg
         * @constructor
         * @param {gov.IUpdateElectorateMsg=} [properties] Properties to set
         */
        function UpdateElectorateMsg(properties) {
            this.diffElectors = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateElectorateMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.UpdateElectorateMsg
         * @instance
         */
        UpdateElectorateMsg.prototype.metadata = null;

        /**
         * ElectorateID is the reference to the electorate that defines the group of possible voters.
         * @member {Uint8Array} electorateId
         * @memberof gov.UpdateElectorateMsg
         * @instance
         */
        UpdateElectorateMsg.prototype.electorateId = $util.newBuffer([]);

        /**
         * with weight=0.
         * @member {Array.<gov.IElector>} diffElectors
         * @memberof gov.UpdateElectorateMsg
         * @instance
         */
        UpdateElectorateMsg.prototype.diffElectors = $util.emptyArray;

        /**
         * Creates a new UpdateElectorateMsg instance using the specified properties.
         * @function create
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {gov.IUpdateElectorateMsg=} [properties] Properties to set
         * @returns {gov.UpdateElectorateMsg} UpdateElectorateMsg instance
         */
        UpdateElectorateMsg.create = function create(properties) {
            return new UpdateElectorateMsg(properties);
        };

        /**
         * Encodes the specified UpdateElectorateMsg message. Does not implicitly {@link gov.UpdateElectorateMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {gov.IUpdateElectorateMsg} message UpdateElectorateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateElectorateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.electorateId);
            if (message.diffElectors != null && message.diffElectors.length)
                for (var i = 0; i < message.diffElectors.length; ++i)
                    $root.gov.Elector.encode(message.diffElectors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateElectorateMsg message, length delimited. Does not implicitly {@link gov.UpdateElectorateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {gov.IUpdateElectorateMsg} message UpdateElectorateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateElectorateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateElectorateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.UpdateElectorateMsg} UpdateElectorateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateElectorateMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.UpdateElectorateMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.electorateId = reader.bytes();
                    break;
                case 3:
                    if (!(message.diffElectors && message.diffElectors.length))
                        message.diffElectors = [];
                    message.diffElectors.push($root.gov.Elector.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateElectorateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.UpdateElectorateMsg} UpdateElectorateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateElectorateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateElectorateMsg message.
         * @function verify
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateElectorateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                if (!(message.electorateId && typeof message.electorateId.length === "number" || $util.isString(message.electorateId)))
                    return "electorateId: buffer expected";
            if (message.diffElectors != null && message.hasOwnProperty("diffElectors")) {
                if (!Array.isArray(message.diffElectors))
                    return "diffElectors: array expected";
                for (var i = 0; i < message.diffElectors.length; ++i) {
                    var error = $root.gov.Elector.verify(message.diffElectors[i]);
                    if (error)
                        return "diffElectors." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UpdateElectorateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.UpdateElectorateMsg} UpdateElectorateMsg
         */
        UpdateElectorateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.UpdateElectorateMsg)
                return object;
            var message = new $root.gov.UpdateElectorateMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.UpdateElectorateMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.electorateId != null)
                if (typeof object.electorateId === "string")
                    $util.base64.decode(object.electorateId, message.electorateId = $util.newBuffer($util.base64.length(object.electorateId)), 0);
                else if (object.electorateId.length)
                    message.electorateId = object.electorateId;
            if (object.diffElectors) {
                if (!Array.isArray(object.diffElectors))
                    throw TypeError(".gov.UpdateElectorateMsg.diffElectors: array expected");
                message.diffElectors = [];
                for (var i = 0; i < object.diffElectors.length; ++i) {
                    if (typeof object.diffElectors[i] !== "object")
                        throw TypeError(".gov.UpdateElectorateMsg.diffElectors: object expected");
                    message.diffElectors[i] = $root.gov.Elector.fromObject(object.diffElectors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateElectorateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.UpdateElectorateMsg
         * @static
         * @param {gov.UpdateElectorateMsg} message UpdateElectorateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateElectorateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.diffElectors = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.electorateId = "";
                else {
                    object.electorateId = [];
                    if (options.bytes !== Array)
                        object.electorateId = $util.newBuffer(object.electorateId);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.electorateId != null && message.hasOwnProperty("electorateId"))
                object.electorateId = options.bytes === String ? $util.base64.encode(message.electorateId, 0, message.electorateId.length) : options.bytes === Array ? Array.prototype.slice.call(message.electorateId) : message.electorateId;
            if (message.diffElectors && message.diffElectors.length) {
                object.diffElectors = [];
                for (var j = 0; j < message.diffElectors.length; ++j)
                    object.diffElectors[j] = $root.gov.Elector.toObject(message.diffElectors[j], options);
            }
            return object;
        };

        /**
         * Converts this UpdateElectorateMsg to JSON.
         * @function toJSON
         * @memberof gov.UpdateElectorateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateElectorateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateElectorateMsg;
    })();

    gov.UpdateElectionRuleMsg = (function() {

        /**
         * Properties of an UpdateElectionRuleMsg.
         * @memberof gov
         * @interface IUpdateElectionRuleMsg
         * @property {weave.IMetadata|null} [metadata] UpdateElectionRuleMsg metadata
         * @property {Uint8Array|null} [electionRuleId] ElectionRuleID is a reference to the election rule
         * @property {number|null} [votingPeriodHours] Duration how long the voting period will take place.
         * @property {gov.IFraction|null} [threshold] of the eligible voters.
         */

        /**
         * Constructs a new UpdateElectionRuleMsg.
         * @memberof gov
         * @classdesc Represents an UpdateElectionRuleMsg.
         * @implements IUpdateElectionRuleMsg
         * @constructor
         * @param {gov.IUpdateElectionRuleMsg=} [properties] Properties to set
         */
        function UpdateElectionRuleMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateElectionRuleMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         */
        UpdateElectionRuleMsg.prototype.metadata = null;

        /**
         * ElectionRuleID is a reference to the election rule
         * @member {Uint8Array} electionRuleId
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         */
        UpdateElectionRuleMsg.prototype.electionRuleId = $util.newBuffer([]);

        /**
         * Duration how long the voting period will take place.
         * @member {number} votingPeriodHours
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         */
        UpdateElectionRuleMsg.prototype.votingPeriodHours = 0;

        /**
         * of the eligible voters.
         * @member {gov.IFraction|null|undefined} threshold
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         */
        UpdateElectionRuleMsg.prototype.threshold = null;

        /**
         * Creates a new UpdateElectionRuleMsg instance using the specified properties.
         * @function create
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {gov.IUpdateElectionRuleMsg=} [properties] Properties to set
         * @returns {gov.UpdateElectionRuleMsg} UpdateElectionRuleMsg instance
         */
        UpdateElectionRuleMsg.create = function create(properties) {
            return new UpdateElectionRuleMsg(properties);
        };

        /**
         * Encodes the specified UpdateElectionRuleMsg message. Does not implicitly {@link gov.UpdateElectionRuleMsg.verify|verify} messages.
         * @function encode
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {gov.IUpdateElectionRuleMsg} message UpdateElectionRuleMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateElectionRuleMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.electionRuleId);
            if (message.votingPeriodHours != null && message.hasOwnProperty("votingPeriodHours"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.votingPeriodHours);
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                $root.gov.Fraction.encode(message.threshold, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateElectionRuleMsg message, length delimited. Does not implicitly {@link gov.UpdateElectionRuleMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {gov.IUpdateElectionRuleMsg} message UpdateElectionRuleMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateElectionRuleMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateElectionRuleMsg message from the specified reader or buffer.
         * @function decode
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {gov.UpdateElectionRuleMsg} UpdateElectionRuleMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateElectionRuleMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.gov.UpdateElectionRuleMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.electionRuleId = reader.bytes();
                    break;
                case 3:
                    message.votingPeriodHours = reader.uint32();
                    break;
                case 4:
                    message.threshold = $root.gov.Fraction.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateElectionRuleMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {gov.UpdateElectionRuleMsg} UpdateElectionRuleMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateElectionRuleMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateElectionRuleMsg message.
         * @function verify
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateElectionRuleMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                if (!(message.electionRuleId && typeof message.electionRuleId.length === "number" || $util.isString(message.electionRuleId)))
                    return "electionRuleId: buffer expected";
            if (message.votingPeriodHours != null && message.hasOwnProperty("votingPeriodHours"))
                if (!$util.isInteger(message.votingPeriodHours))
                    return "votingPeriodHours: integer expected";
            if (message.threshold != null && message.hasOwnProperty("threshold")) {
                var error = $root.gov.Fraction.verify(message.threshold);
                if (error)
                    return "threshold." + error;
            }
            return null;
        };

        /**
         * Creates an UpdateElectionRuleMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {gov.UpdateElectionRuleMsg} UpdateElectionRuleMsg
         */
        UpdateElectionRuleMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.gov.UpdateElectionRuleMsg)
                return object;
            var message = new $root.gov.UpdateElectionRuleMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".gov.UpdateElectionRuleMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.electionRuleId != null)
                if (typeof object.electionRuleId === "string")
                    $util.base64.decode(object.electionRuleId, message.electionRuleId = $util.newBuffer($util.base64.length(object.electionRuleId)), 0);
                else if (object.electionRuleId.length)
                    message.electionRuleId = object.electionRuleId;
            if (object.votingPeriodHours != null)
                message.votingPeriodHours = object.votingPeriodHours >>> 0;
            if (object.threshold != null) {
                if (typeof object.threshold !== "object")
                    throw TypeError(".gov.UpdateElectionRuleMsg.threshold: object expected");
                message.threshold = $root.gov.Fraction.fromObject(object.threshold);
            }
            return message;
        };

        /**
         * Creates a plain object from an UpdateElectionRuleMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof gov.UpdateElectionRuleMsg
         * @static
         * @param {gov.UpdateElectionRuleMsg} message UpdateElectionRuleMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateElectionRuleMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.electionRuleId = "";
                else {
                    object.electionRuleId = [];
                    if (options.bytes !== Array)
                        object.electionRuleId = $util.newBuffer(object.electionRuleId);
                }
                object.votingPeriodHours = 0;
                object.threshold = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.electionRuleId != null && message.hasOwnProperty("electionRuleId"))
                object.electionRuleId = options.bytes === String ? $util.base64.encode(message.electionRuleId, 0, message.electionRuleId.length) : options.bytes === Array ? Array.prototype.slice.call(message.electionRuleId) : message.electionRuleId;
            if (message.votingPeriodHours != null && message.hasOwnProperty("votingPeriodHours"))
                object.votingPeriodHours = message.votingPeriodHours;
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                object.threshold = $root.gov.Fraction.toObject(message.threshold, options);
            return object;
        };

        /**
         * Converts this UpdateElectionRuleMsg to JSON.
         * @function toJSON
         * @memberof gov.UpdateElectionRuleMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateElectionRuleMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateElectionRuleMsg;
    })();

    return gov;
})();

$root.msgfee = (function() {

    /**
     * Namespace msgfee.
     * @exports msgfee
     * @namespace
     */
    var msgfee = {};

    msgfee.MsgFee = (function() {

        /**
         * Properties of a MsgFee.
         * @memberof msgfee
         * @interface IMsgFee
         * @property {weave.IMetadata|null} [metadata] MsgFee metadata
         * @property {string|null} [msgPath] MsgFee msgPath
         * @property {coin.ICoin|null} [fee] MsgFee fee
         */

        /**
         * Constructs a new MsgFee.
         * @memberof msgfee
         * @classdesc the message to be processed.
         * @implements IMsgFee
         * @constructor
         * @param {msgfee.IMsgFee=} [properties] Properties to set
         */
        function MsgFee(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgFee metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof msgfee.MsgFee
         * @instance
         */
        MsgFee.prototype.metadata = null;

        /**
         * MsgFee msgPath.
         * @member {string} msgPath
         * @memberof msgfee.MsgFee
         * @instance
         */
        MsgFee.prototype.msgPath = "";

        /**
         * MsgFee fee.
         * @member {coin.ICoin|null|undefined} fee
         * @memberof msgfee.MsgFee
         * @instance
         */
        MsgFee.prototype.fee = null;

        /**
         * Creates a new MsgFee instance using the specified properties.
         * @function create
         * @memberof msgfee.MsgFee
         * @static
         * @param {msgfee.IMsgFee=} [properties] Properties to set
         * @returns {msgfee.MsgFee} MsgFee instance
         */
        MsgFee.create = function create(properties) {
            return new MsgFee(properties);
        };

        /**
         * Encodes the specified MsgFee message. Does not implicitly {@link msgfee.MsgFee.verify|verify} messages.
         * @function encode
         * @memberof msgfee.MsgFee
         * @static
         * @param {msgfee.IMsgFee} message MsgFee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgFee.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.msgPath != null && message.hasOwnProperty("msgPath"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.msgPath);
            if (message.fee != null && message.hasOwnProperty("fee"))
                $root.coin.Coin.encode(message.fee, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MsgFee message, length delimited. Does not implicitly {@link msgfee.MsgFee.verify|verify} messages.
         * @function encodeDelimited
         * @memberof msgfee.MsgFee
         * @static
         * @param {msgfee.IMsgFee} message MsgFee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgFee.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgFee message from the specified reader or buffer.
         * @function decode
         * @memberof msgfee.MsgFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {msgfee.MsgFee} MsgFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgFee.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.msgfee.MsgFee();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.msgPath = reader.string();
                    break;
                case 3:
                    message.fee = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgFee message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof msgfee.MsgFee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {msgfee.MsgFee} MsgFee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgFee.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgFee message.
         * @function verify
         * @memberof msgfee.MsgFee
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgFee.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.msgPath != null && message.hasOwnProperty("msgPath"))
                if (!$util.isString(message.msgPath))
                    return "msgPath: string expected";
            if (message.fee != null && message.hasOwnProperty("fee")) {
                var error = $root.coin.Coin.verify(message.fee);
                if (error)
                    return "fee." + error;
            }
            return null;
        };

        /**
         * Creates a MsgFee message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof msgfee.MsgFee
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {msgfee.MsgFee} MsgFee
         */
        MsgFee.fromObject = function fromObject(object) {
            if (object instanceof $root.msgfee.MsgFee)
                return object;
            var message = new $root.msgfee.MsgFee();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".msgfee.MsgFee.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.msgPath != null)
                message.msgPath = String(object.msgPath);
            if (object.fee != null) {
                if (typeof object.fee !== "object")
                    throw TypeError(".msgfee.MsgFee.fee: object expected");
                message.fee = $root.coin.Coin.fromObject(object.fee);
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgFee message. Also converts values to other types if specified.
         * @function toObject
         * @memberof msgfee.MsgFee
         * @static
         * @param {msgfee.MsgFee} message MsgFee
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgFee.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.msgPath = "";
                object.fee = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.msgPath != null && message.hasOwnProperty("msgPath"))
                object.msgPath = message.msgPath;
            if (message.fee != null && message.hasOwnProperty("fee"))
                object.fee = $root.coin.Coin.toObject(message.fee, options);
            return object;
        };

        /**
         * Converts this MsgFee to JSON.
         * @function toJSON
         * @memberof msgfee.MsgFee
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgFee.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MsgFee;
    })();

    return msgfee;
})();

$root.multisig = (function() {

    /**
     * Namespace multisig.
     * @exports multisig
     * @namespace
     */
    var multisig = {};

    multisig.Contract = (function() {

        /**
         * Properties of a Contract.
         * @memberof multisig
         * @interface IContract
         * @property {weave.IMetadata|null} [metadata] Contract metadata
         * @property {Array.<multisig.IParticipant>|null} [participants] contract.
         * @property {number|null} [activationThreshold] computed as the sum of weights of all participating signatures.
         * @property {number|null} [adminThreshold] computed as the sum of weights of all participating signatures.
         */

        /**
         * Constructs a new Contract.
         * @memberof multisig
         * @classdesc Represents a Contract.
         * @implements IContract
         * @constructor
         * @param {multisig.IContract=} [properties] Properties to set
         */
        function Contract(properties) {
            this.participants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Contract metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof multisig.Contract
         * @instance
         */
        Contract.prototype.metadata = null;

        /**
         * contract.
         * @member {Array.<multisig.IParticipant>} participants
         * @memberof multisig.Contract
         * @instance
         */
        Contract.prototype.participants = $util.emptyArray;

        /**
         * computed as the sum of weights of all participating signatures.
         * @member {number} activationThreshold
         * @memberof multisig.Contract
         * @instance
         */
        Contract.prototype.activationThreshold = 0;

        /**
         * computed as the sum of weights of all participating signatures.
         * @member {number} adminThreshold
         * @memberof multisig.Contract
         * @instance
         */
        Contract.prototype.adminThreshold = 0;

        /**
         * Creates a new Contract instance using the specified properties.
         * @function create
         * @memberof multisig.Contract
         * @static
         * @param {multisig.IContract=} [properties] Properties to set
         * @returns {multisig.Contract} Contract instance
         */
        Contract.create = function create(properties) {
            return new Contract(properties);
        };

        /**
         * Encodes the specified Contract message. Does not implicitly {@link multisig.Contract.verify|verify} messages.
         * @function encode
         * @memberof multisig.Contract
         * @static
         * @param {multisig.IContract} message Contract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.participants != null && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    $root.multisig.Participant.encode(message.participants[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.activationThreshold);
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.adminThreshold);
            return writer;
        };

        /**
         * Encodes the specified Contract message, length delimited. Does not implicitly {@link multisig.Contract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof multisig.Contract
         * @static
         * @param {multisig.IContract} message Contract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Contract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Contract message from the specified reader or buffer.
         * @function decode
         * @memberof multisig.Contract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {multisig.Contract} Contract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.multisig.Contract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push($root.multisig.Participant.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.activationThreshold = reader.uint32();
                    break;
                case 4:
                    message.adminThreshold = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Contract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof multisig.Contract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {multisig.Contract} Contract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Contract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Contract message.
         * @function verify
         * @memberof multisig.Contract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Contract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.participants != null && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i) {
                    var error = $root.multisig.Participant.verify(message.participants[i]);
                    if (error)
                        return "participants." + error;
                }
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                if (!$util.isInteger(message.activationThreshold))
                    return "activationThreshold: integer expected";
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                if (!$util.isInteger(message.adminThreshold))
                    return "adminThreshold: integer expected";
            return null;
        };

        /**
         * Creates a Contract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof multisig.Contract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {multisig.Contract} Contract
         */
        Contract.fromObject = function fromObject(object) {
            if (object instanceof $root.multisig.Contract)
                return object;
            var message = new $root.multisig.Contract();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".multisig.Contract.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".multisig.Contract.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i) {
                    if (typeof object.participants[i] !== "object")
                        throw TypeError(".multisig.Contract.participants: object expected");
                    message.participants[i] = $root.multisig.Participant.fromObject(object.participants[i]);
                }
            }
            if (object.activationThreshold != null)
                message.activationThreshold = object.activationThreshold >>> 0;
            if (object.adminThreshold != null)
                message.adminThreshold = object.adminThreshold >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Contract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof multisig.Contract
         * @static
         * @param {multisig.Contract} message Contract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Contract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.participants = [];
            if (options.defaults) {
                object.metadata = null;
                object.activationThreshold = 0;
                object.adminThreshold = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = $root.multisig.Participant.toObject(message.participants[j], options);
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                object.activationThreshold = message.activationThreshold;
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                object.adminThreshold = message.adminThreshold;
            return object;
        };

        /**
         * Converts this Contract to JSON.
         * @function toJSON
         * @memberof multisig.Contract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Contract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Contract;
    })();

    multisig.Participant = (function() {

        /**
         * Properties of a Participant.
         * @memberof multisig
         * @interface IParticipant
         * @property {Uint8Array|null} [signature] Participant signature
         * @property {number|null} [weight] Participant weight
         */

        /**
         * Constructs a new Participant.
         * @memberof multisig
         * @classdesc the greater the power of a signature.
         * @implements IParticipant
         * @constructor
         * @param {multisig.IParticipant=} [properties] Properties to set
         */
        function Participant(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Participant signature.
         * @member {Uint8Array} signature
         * @memberof multisig.Participant
         * @instance
         */
        Participant.prototype.signature = $util.newBuffer([]);

        /**
         * Participant weight.
         * @member {number} weight
         * @memberof multisig.Participant
         * @instance
         */
        Participant.prototype.weight = 0;

        /**
         * Creates a new Participant instance using the specified properties.
         * @function create
         * @memberof multisig.Participant
         * @static
         * @param {multisig.IParticipant=} [properties] Properties to set
         * @returns {multisig.Participant} Participant instance
         */
        Participant.create = function create(properties) {
            return new Participant(properties);
        };

        /**
         * Encodes the specified Participant message. Does not implicitly {@link multisig.Participant.verify|verify} messages.
         * @function encode
         * @memberof multisig.Participant
         * @static
         * @param {multisig.IParticipant} message Participant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Participant.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.signature);
            if (message.weight != null && message.hasOwnProperty("weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.weight);
            return writer;
        };

        /**
         * Encodes the specified Participant message, length delimited. Does not implicitly {@link multisig.Participant.verify|verify} messages.
         * @function encodeDelimited
         * @memberof multisig.Participant
         * @static
         * @param {multisig.IParticipant} message Participant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Participant.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Participant message from the specified reader or buffer.
         * @function decode
         * @memberof multisig.Participant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {multisig.Participant} Participant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Participant.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.multisig.Participant();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signature = reader.bytes();
                    break;
                case 2:
                    message.weight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Participant message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof multisig.Participant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {multisig.Participant} Participant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Participant.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Participant message.
         * @function verify
         * @memberof multisig.Participant
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Participant.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight))
                    return "weight: integer expected";
            return null;
        };

        /**
         * Creates a Participant message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof multisig.Participant
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {multisig.Participant} Participant
         */
        Participant.fromObject = function fromObject(object) {
            if (object instanceof $root.multisig.Participant)
                return object;
            var message = new $root.multisig.Participant();
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            if (object.weight != null)
                message.weight = object.weight >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Participant message. Also converts values to other types if specified.
         * @function toObject
         * @memberof multisig.Participant
         * @static
         * @param {multisig.Participant} message Participant
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Participant.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
                object.weight = 0;
            }
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = message.weight;
            return object;
        };

        /**
         * Converts this Participant to JSON.
         * @function toJSON
         * @memberof multisig.Participant
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Participant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Participant;
    })();

    multisig.CreateContractMsg = (function() {

        /**
         * Properties of a CreateContractMsg.
         * @memberof multisig
         * @interface ICreateContractMsg
         * @property {weave.IMetadata|null} [metadata] CreateContractMsg metadata
         * @property {Array.<multisig.IParticipant>|null} [participants] CreateContractMsg participants
         * @property {number|null} [activationThreshold] CreateContractMsg activationThreshold
         * @property {number|null} [adminThreshold] CreateContractMsg adminThreshold
         */

        /**
         * Constructs a new CreateContractMsg.
         * @memberof multisig
         * @classdesc Represents a CreateContractMsg.
         * @implements ICreateContractMsg
         * @constructor
         * @param {multisig.ICreateContractMsg=} [properties] Properties to set
         */
        function CreateContractMsg(properties) {
            this.participants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateContractMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof multisig.CreateContractMsg
         * @instance
         */
        CreateContractMsg.prototype.metadata = null;

        /**
         * CreateContractMsg participants.
         * @member {Array.<multisig.IParticipant>} participants
         * @memberof multisig.CreateContractMsg
         * @instance
         */
        CreateContractMsg.prototype.participants = $util.emptyArray;

        /**
         * CreateContractMsg activationThreshold.
         * @member {number} activationThreshold
         * @memberof multisig.CreateContractMsg
         * @instance
         */
        CreateContractMsg.prototype.activationThreshold = 0;

        /**
         * CreateContractMsg adminThreshold.
         * @member {number} adminThreshold
         * @memberof multisig.CreateContractMsg
         * @instance
         */
        CreateContractMsg.prototype.adminThreshold = 0;

        /**
         * Creates a new CreateContractMsg instance using the specified properties.
         * @function create
         * @memberof multisig.CreateContractMsg
         * @static
         * @param {multisig.ICreateContractMsg=} [properties] Properties to set
         * @returns {multisig.CreateContractMsg} CreateContractMsg instance
         */
        CreateContractMsg.create = function create(properties) {
            return new CreateContractMsg(properties);
        };

        /**
         * Encodes the specified CreateContractMsg message. Does not implicitly {@link multisig.CreateContractMsg.verify|verify} messages.
         * @function encode
         * @memberof multisig.CreateContractMsg
         * @static
         * @param {multisig.ICreateContractMsg} message CreateContractMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateContractMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.participants != null && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    $root.multisig.Participant.encode(message.participants[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.activationThreshold);
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.adminThreshold);
            return writer;
        };

        /**
         * Encodes the specified CreateContractMsg message, length delimited. Does not implicitly {@link multisig.CreateContractMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof multisig.CreateContractMsg
         * @static
         * @param {multisig.ICreateContractMsg} message CreateContractMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateContractMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateContractMsg message from the specified reader or buffer.
         * @function decode
         * @memberof multisig.CreateContractMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {multisig.CreateContractMsg} CreateContractMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateContractMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.multisig.CreateContractMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push($root.multisig.Participant.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.activationThreshold = reader.uint32();
                    break;
                case 4:
                    message.adminThreshold = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateContractMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof multisig.CreateContractMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {multisig.CreateContractMsg} CreateContractMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateContractMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateContractMsg message.
         * @function verify
         * @memberof multisig.CreateContractMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateContractMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.participants != null && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i) {
                    var error = $root.multisig.Participant.verify(message.participants[i]);
                    if (error)
                        return "participants." + error;
                }
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                if (!$util.isInteger(message.activationThreshold))
                    return "activationThreshold: integer expected";
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                if (!$util.isInteger(message.adminThreshold))
                    return "adminThreshold: integer expected";
            return null;
        };

        /**
         * Creates a CreateContractMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof multisig.CreateContractMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {multisig.CreateContractMsg} CreateContractMsg
         */
        CreateContractMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.multisig.CreateContractMsg)
                return object;
            var message = new $root.multisig.CreateContractMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".multisig.CreateContractMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".multisig.CreateContractMsg.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i) {
                    if (typeof object.participants[i] !== "object")
                        throw TypeError(".multisig.CreateContractMsg.participants: object expected");
                    message.participants[i] = $root.multisig.Participant.fromObject(object.participants[i]);
                }
            }
            if (object.activationThreshold != null)
                message.activationThreshold = object.activationThreshold >>> 0;
            if (object.adminThreshold != null)
                message.adminThreshold = object.adminThreshold >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a CreateContractMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof multisig.CreateContractMsg
         * @static
         * @param {multisig.CreateContractMsg} message CreateContractMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateContractMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.participants = [];
            if (options.defaults) {
                object.metadata = null;
                object.activationThreshold = 0;
                object.adminThreshold = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = $root.multisig.Participant.toObject(message.participants[j], options);
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                object.activationThreshold = message.activationThreshold;
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                object.adminThreshold = message.adminThreshold;
            return object;
        };

        /**
         * Converts this CreateContractMsg to JSON.
         * @function toJSON
         * @memberof multisig.CreateContractMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateContractMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateContractMsg;
    })();

    multisig.UpdateContractMsg = (function() {

        /**
         * Properties of an UpdateContractMsg.
         * @memberof multisig
         * @interface IUpdateContractMsg
         * @property {weave.IMetadata|null} [metadata] UpdateContractMsg metadata
         * @property {Uint8Array|null} [contractId] UpdateContractMsg contractId
         * @property {Array.<multisig.IParticipant>|null} [participants] UpdateContractMsg participants
         * @property {number|null} [activationThreshold] UpdateContractMsg activationThreshold
         * @property {number|null} [adminThreshold] UpdateContractMsg adminThreshold
         */

        /**
         * Constructs a new UpdateContractMsg.
         * @memberof multisig
         * @classdesc Represents an UpdateContractMsg.
         * @implements IUpdateContractMsg
         * @constructor
         * @param {multisig.IUpdateContractMsg=} [properties] Properties to set
         */
        function UpdateContractMsg(properties) {
            this.participants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateContractMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof multisig.UpdateContractMsg
         * @instance
         */
        UpdateContractMsg.prototype.metadata = null;

        /**
         * UpdateContractMsg contractId.
         * @member {Uint8Array} contractId
         * @memberof multisig.UpdateContractMsg
         * @instance
         */
        UpdateContractMsg.prototype.contractId = $util.newBuffer([]);

        /**
         * UpdateContractMsg participants.
         * @member {Array.<multisig.IParticipant>} participants
         * @memberof multisig.UpdateContractMsg
         * @instance
         */
        UpdateContractMsg.prototype.participants = $util.emptyArray;

        /**
         * UpdateContractMsg activationThreshold.
         * @member {number} activationThreshold
         * @memberof multisig.UpdateContractMsg
         * @instance
         */
        UpdateContractMsg.prototype.activationThreshold = 0;

        /**
         * UpdateContractMsg adminThreshold.
         * @member {number} adminThreshold
         * @memberof multisig.UpdateContractMsg
         * @instance
         */
        UpdateContractMsg.prototype.adminThreshold = 0;

        /**
         * Creates a new UpdateContractMsg instance using the specified properties.
         * @function create
         * @memberof multisig.UpdateContractMsg
         * @static
         * @param {multisig.IUpdateContractMsg=} [properties] Properties to set
         * @returns {multisig.UpdateContractMsg} UpdateContractMsg instance
         */
        UpdateContractMsg.create = function create(properties) {
            return new UpdateContractMsg(properties);
        };

        /**
         * Encodes the specified UpdateContractMsg message. Does not implicitly {@link multisig.UpdateContractMsg.verify|verify} messages.
         * @function encode
         * @memberof multisig.UpdateContractMsg
         * @static
         * @param {multisig.IUpdateContractMsg} message UpdateContractMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateContractMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contractId);
            if (message.participants != null && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    $root.multisig.Participant.encode(message.participants[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.activationThreshold);
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.adminThreshold);
            return writer;
        };

        /**
         * Encodes the specified UpdateContractMsg message, length delimited. Does not implicitly {@link multisig.UpdateContractMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof multisig.UpdateContractMsg
         * @static
         * @param {multisig.IUpdateContractMsg} message UpdateContractMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateContractMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateContractMsg message from the specified reader or buffer.
         * @function decode
         * @memberof multisig.UpdateContractMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {multisig.UpdateContractMsg} UpdateContractMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateContractMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.multisig.UpdateContractMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.contractId = reader.bytes();
                    break;
                case 3:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push($root.multisig.Participant.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.activationThreshold = reader.uint32();
                    break;
                case 5:
                    message.adminThreshold = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateContractMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof multisig.UpdateContractMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {multisig.UpdateContractMsg} UpdateContractMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateContractMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateContractMsg message.
         * @function verify
         * @memberof multisig.UpdateContractMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateContractMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                if (!(message.contractId && typeof message.contractId.length === "number" || $util.isString(message.contractId)))
                    return "contractId: buffer expected";
            if (message.participants != null && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i) {
                    var error = $root.multisig.Participant.verify(message.participants[i]);
                    if (error)
                        return "participants." + error;
                }
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                if (!$util.isInteger(message.activationThreshold))
                    return "activationThreshold: integer expected";
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                if (!$util.isInteger(message.adminThreshold))
                    return "adminThreshold: integer expected";
            return null;
        };

        /**
         * Creates an UpdateContractMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof multisig.UpdateContractMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {multisig.UpdateContractMsg} UpdateContractMsg
         */
        UpdateContractMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.multisig.UpdateContractMsg)
                return object;
            var message = new $root.multisig.UpdateContractMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".multisig.UpdateContractMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.contractId != null)
                if (typeof object.contractId === "string")
                    $util.base64.decode(object.contractId, message.contractId = $util.newBuffer($util.base64.length(object.contractId)), 0);
                else if (object.contractId.length)
                    message.contractId = object.contractId;
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".multisig.UpdateContractMsg.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i) {
                    if (typeof object.participants[i] !== "object")
                        throw TypeError(".multisig.UpdateContractMsg.participants: object expected");
                    message.participants[i] = $root.multisig.Participant.fromObject(object.participants[i]);
                }
            }
            if (object.activationThreshold != null)
                message.activationThreshold = object.activationThreshold >>> 0;
            if (object.adminThreshold != null)
                message.adminThreshold = object.adminThreshold >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an UpdateContractMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof multisig.UpdateContractMsg
         * @static
         * @param {multisig.UpdateContractMsg} message UpdateContractMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateContractMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.participants = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.contractId = "";
                else {
                    object.contractId = [];
                    if (options.bytes !== Array)
                        object.contractId = $util.newBuffer(object.contractId);
                }
                object.activationThreshold = 0;
                object.adminThreshold = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.contractId != null && message.hasOwnProperty("contractId"))
                object.contractId = options.bytes === String ? $util.base64.encode(message.contractId, 0, message.contractId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contractId) : message.contractId;
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = $root.multisig.Participant.toObject(message.participants[j], options);
            }
            if (message.activationThreshold != null && message.hasOwnProperty("activationThreshold"))
                object.activationThreshold = message.activationThreshold;
            if (message.adminThreshold != null && message.hasOwnProperty("adminThreshold"))
                object.adminThreshold = message.adminThreshold;
            return object;
        };

        /**
         * Converts this UpdateContractMsg to JSON.
         * @function toJSON
         * @memberof multisig.UpdateContractMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateContractMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateContractMsg;
    })();

    return multisig;
})();

$root.namecoin = (function() {

    /**
     * Namespace namecoin.
     * @exports namecoin
     * @namespace
     */
    var namecoin = {};

    namecoin.Wallet = (function() {

        /**
         * Properties of a Wallet.
         * @memberof namecoin
         * @interface IWallet
         * @property {weave.IMetadata|null} [metadata] Wallet metadata
         * @property {Array.<coin.ICoin>|null} [coins] Wallet coins
         * @property {string|null} [name] Wallet name
         */

        /**
         * Constructs a new Wallet.
         * @memberof namecoin
         * @classdesc Wallet has a name and a set of coins
         * @implements IWallet
         * @constructor
         * @param {namecoin.IWallet=} [properties] Properties to set
         */
        function Wallet(properties) {
            this.coins = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Wallet metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof namecoin.Wallet
         * @instance
         */
        Wallet.prototype.metadata = null;

        /**
         * Wallet coins.
         * @member {Array.<coin.ICoin>} coins
         * @memberof namecoin.Wallet
         * @instance
         */
        Wallet.prototype.coins = $util.emptyArray;

        /**
         * Wallet name.
         * @member {string} name
         * @memberof namecoin.Wallet
         * @instance
         */
        Wallet.prototype.name = "";

        /**
         * Creates a new Wallet instance using the specified properties.
         * @function create
         * @memberof namecoin.Wallet
         * @static
         * @param {namecoin.IWallet=} [properties] Properties to set
         * @returns {namecoin.Wallet} Wallet instance
         */
        Wallet.create = function create(properties) {
            return new Wallet(properties);
        };

        /**
         * Encodes the specified Wallet message. Does not implicitly {@link namecoin.Wallet.verify|verify} messages.
         * @function encode
         * @memberof namecoin.Wallet
         * @static
         * @param {namecoin.IWallet} message Wallet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wallet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.coins != null && message.coins.length)
                for (var i = 0; i < message.coins.length; ++i)
                    $root.coin.Coin.encode(message.coins[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Wallet message, length delimited. Does not implicitly {@link namecoin.Wallet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof namecoin.Wallet
         * @static
         * @param {namecoin.IWallet} message Wallet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wallet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Wallet message from the specified reader or buffer.
         * @function decode
         * @memberof namecoin.Wallet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {namecoin.Wallet} Wallet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wallet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.namecoin.Wallet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.coins && message.coins.length))
                        message.coins = [];
                    message.coins.push($root.coin.Coin.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Wallet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof namecoin.Wallet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {namecoin.Wallet} Wallet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wallet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Wallet message.
         * @function verify
         * @memberof namecoin.Wallet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Wallet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.coins != null && message.hasOwnProperty("coins")) {
                if (!Array.isArray(message.coins))
                    return "coins: array expected";
                for (var i = 0; i < message.coins.length; ++i) {
                    var error = $root.coin.Coin.verify(message.coins[i]);
                    if (error)
                        return "coins." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Wallet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof namecoin.Wallet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {namecoin.Wallet} Wallet
         */
        Wallet.fromObject = function fromObject(object) {
            if (object instanceof $root.namecoin.Wallet)
                return object;
            var message = new $root.namecoin.Wallet();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".namecoin.Wallet.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.coins) {
                if (!Array.isArray(object.coins))
                    throw TypeError(".namecoin.Wallet.coins: array expected");
                message.coins = [];
                for (var i = 0; i < object.coins.length; ++i) {
                    if (typeof object.coins[i] !== "object")
                        throw TypeError(".namecoin.Wallet.coins: object expected");
                    message.coins[i] = $root.coin.Coin.fromObject(object.coins[i]);
                }
            }
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Wallet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof namecoin.Wallet
         * @static
         * @param {namecoin.Wallet} message Wallet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Wallet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.coins = [];
            if (options.defaults) {
                object.metadata = null;
                object.name = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.coins && message.coins.length) {
                object.coins = [];
                for (var j = 0; j < message.coins.length; ++j)
                    object.coins[j] = $root.coin.Coin.toObject(message.coins[j], options);
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Wallet to JSON.
         * @function toJSON
         * @memberof namecoin.Wallet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Wallet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Wallet;
    })();

    namecoin.Token = (function() {

        /**
         * Properties of a Token.
         * @memberof namecoin
         * @interface IToken
         * @property {weave.IMetadata|null} [metadata] Token metadata
         * @property {string|null} [name] Token name
         * @property {number|null} [sigFigs] Token sigFigs
         */

        /**
         * Constructs a new Token.
         * @memberof namecoin
         * @classdesc Token contains information about a registered currency
         * @implements IToken
         * @constructor
         * @param {namecoin.IToken=} [properties] Properties to set
         */
        function Token(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Token metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof namecoin.Token
         * @instance
         */
        Token.prototype.metadata = null;

        /**
         * Token name.
         * @member {string} name
         * @memberof namecoin.Token
         * @instance
         */
        Token.prototype.name = "";

        /**
         * Token sigFigs.
         * @member {number} sigFigs
         * @memberof namecoin.Token
         * @instance
         */
        Token.prototype.sigFigs = 0;

        /**
         * Creates a new Token instance using the specified properties.
         * @function create
         * @memberof namecoin.Token
         * @static
         * @param {namecoin.IToken=} [properties] Properties to set
         * @returns {namecoin.Token} Token instance
         */
        Token.create = function create(properties) {
            return new Token(properties);
        };

        /**
         * Encodes the specified Token message. Does not implicitly {@link namecoin.Token.verify|verify} messages.
         * @function encode
         * @memberof namecoin.Token
         * @static
         * @param {namecoin.IToken} message Token message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Token.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.sigFigs != null && message.hasOwnProperty("sigFigs"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sigFigs);
            return writer;
        };

        /**
         * Encodes the specified Token message, length delimited. Does not implicitly {@link namecoin.Token.verify|verify} messages.
         * @function encodeDelimited
         * @memberof namecoin.Token
         * @static
         * @param {namecoin.IToken} message Token message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Token.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Token message from the specified reader or buffer.
         * @function decode
         * @memberof namecoin.Token
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {namecoin.Token} Token
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Token.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.namecoin.Token();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.sigFigs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Token message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof namecoin.Token
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {namecoin.Token} Token
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Token.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Token message.
         * @function verify
         * @memberof namecoin.Token
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Token.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.sigFigs != null && message.hasOwnProperty("sigFigs"))
                if (!$util.isInteger(message.sigFigs))
                    return "sigFigs: integer expected";
            return null;
        };

        /**
         * Creates a Token message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof namecoin.Token
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {namecoin.Token} Token
         */
        Token.fromObject = function fromObject(object) {
            if (object instanceof $root.namecoin.Token)
                return object;
            var message = new $root.namecoin.Token();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".namecoin.Token.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.sigFigs != null)
                message.sigFigs = object.sigFigs | 0;
            return message;
        };

        /**
         * Creates a plain object from a Token message. Also converts values to other types if specified.
         * @function toObject
         * @memberof namecoin.Token
         * @static
         * @param {namecoin.Token} message Token
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Token.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.name = "";
                object.sigFigs = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.sigFigs != null && message.hasOwnProperty("sigFigs"))
                object.sigFigs = message.sigFigs;
            return object;
        };

        /**
         * Converts this Token to JSON.
         * @function toJSON
         * @memberof namecoin.Token
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Token.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Token;
    })();

    namecoin.NewTokenMsg = (function() {

        /**
         * Properties of a NewTokenMsg.
         * @memberof namecoin
         * @interface INewTokenMsg
         * @property {weave.IMetadata|null} [metadata] NewTokenMsg metadata
         * @property {string|null} [ticker] NewTokenMsg ticker
         * @property {string|null} [name] NewTokenMsg name
         * @property {number|null} [sigFigs] NewTokenMsg sigFigs
         */

        /**
         * Constructs a new NewTokenMsg.
         * @memberof namecoin
         * @classdesc and should be limited to privledged users.
         * @implements INewTokenMsg
         * @constructor
         * @param {namecoin.INewTokenMsg=} [properties] Properties to set
         */
        function NewTokenMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewTokenMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof namecoin.NewTokenMsg
         * @instance
         */
        NewTokenMsg.prototype.metadata = null;

        /**
         * NewTokenMsg ticker.
         * @member {string} ticker
         * @memberof namecoin.NewTokenMsg
         * @instance
         */
        NewTokenMsg.prototype.ticker = "";

        /**
         * NewTokenMsg name.
         * @member {string} name
         * @memberof namecoin.NewTokenMsg
         * @instance
         */
        NewTokenMsg.prototype.name = "";

        /**
         * NewTokenMsg sigFigs.
         * @member {number} sigFigs
         * @memberof namecoin.NewTokenMsg
         * @instance
         */
        NewTokenMsg.prototype.sigFigs = 0;

        /**
         * Creates a new NewTokenMsg instance using the specified properties.
         * @function create
         * @memberof namecoin.NewTokenMsg
         * @static
         * @param {namecoin.INewTokenMsg=} [properties] Properties to set
         * @returns {namecoin.NewTokenMsg} NewTokenMsg instance
         */
        NewTokenMsg.create = function create(properties) {
            return new NewTokenMsg(properties);
        };

        /**
         * Encodes the specified NewTokenMsg message. Does not implicitly {@link namecoin.NewTokenMsg.verify|verify} messages.
         * @function encode
         * @memberof namecoin.NewTokenMsg
         * @static
         * @param {namecoin.INewTokenMsg} message NewTokenMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewTokenMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ticker);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.sigFigs != null && message.hasOwnProperty("sigFigs"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.sigFigs);
            return writer;
        };

        /**
         * Encodes the specified NewTokenMsg message, length delimited. Does not implicitly {@link namecoin.NewTokenMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof namecoin.NewTokenMsg
         * @static
         * @param {namecoin.INewTokenMsg} message NewTokenMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewTokenMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewTokenMsg message from the specified reader or buffer.
         * @function decode
         * @memberof namecoin.NewTokenMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {namecoin.NewTokenMsg} NewTokenMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewTokenMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.namecoin.NewTokenMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ticker = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.sigFigs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewTokenMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof namecoin.NewTokenMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {namecoin.NewTokenMsg} NewTokenMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewTokenMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewTokenMsg message.
         * @function verify
         * @memberof namecoin.NewTokenMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewTokenMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                if (!$util.isString(message.ticker))
                    return "ticker: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.sigFigs != null && message.hasOwnProperty("sigFigs"))
                if (!$util.isInteger(message.sigFigs))
                    return "sigFigs: integer expected";
            return null;
        };

        /**
         * Creates a NewTokenMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof namecoin.NewTokenMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {namecoin.NewTokenMsg} NewTokenMsg
         */
        NewTokenMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.namecoin.NewTokenMsg)
                return object;
            var message = new $root.namecoin.NewTokenMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".namecoin.NewTokenMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.ticker != null)
                message.ticker = String(object.ticker);
            if (object.name != null)
                message.name = String(object.name);
            if (object.sigFigs != null)
                message.sigFigs = object.sigFigs | 0;
            return message;
        };

        /**
         * Creates a plain object from a NewTokenMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof namecoin.NewTokenMsg
         * @static
         * @param {namecoin.NewTokenMsg} message NewTokenMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewTokenMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.ticker = "";
                object.name = "";
                object.sigFigs = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.ticker != null && message.hasOwnProperty("ticker"))
                object.ticker = message.ticker;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.sigFigs != null && message.hasOwnProperty("sigFigs"))
                object.sigFigs = message.sigFigs;
            return object;
        };

        /**
         * Converts this NewTokenMsg to JSON.
         * @function toJSON
         * @memberof namecoin.NewTokenMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewTokenMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewTokenMsg;
    })();

    namecoin.SetWalletNameMsg = (function() {

        /**
         * Properties of a SetWalletNameMsg.
         * @memberof namecoin
         * @interface ISetWalletNameMsg
         * @property {weave.IMetadata|null} [metadata] SetWalletNameMsg metadata
         * @property {Uint8Array|null} [address] SetWalletNameMsg address
         * @property {string|null} [name] SetWalletNameMsg name
         */

        /**
         * Constructs a new SetWalletNameMsg.
         * @memberof namecoin
         * @classdesc wallet. Can only be performed if the wallet name is empty.
         * @implements ISetWalletNameMsg
         * @constructor
         * @param {namecoin.ISetWalletNameMsg=} [properties] Properties to set
         */
        function SetWalletNameMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetWalletNameMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof namecoin.SetWalletNameMsg
         * @instance
         */
        SetWalletNameMsg.prototype.metadata = null;

        /**
         * SetWalletNameMsg address.
         * @member {Uint8Array} address
         * @memberof namecoin.SetWalletNameMsg
         * @instance
         */
        SetWalletNameMsg.prototype.address = $util.newBuffer([]);

        /**
         * SetWalletNameMsg name.
         * @member {string} name
         * @memberof namecoin.SetWalletNameMsg
         * @instance
         */
        SetWalletNameMsg.prototype.name = "";

        /**
         * Creates a new SetWalletNameMsg instance using the specified properties.
         * @function create
         * @memberof namecoin.SetWalletNameMsg
         * @static
         * @param {namecoin.ISetWalletNameMsg=} [properties] Properties to set
         * @returns {namecoin.SetWalletNameMsg} SetWalletNameMsg instance
         */
        SetWalletNameMsg.create = function create(properties) {
            return new SetWalletNameMsg(properties);
        };

        /**
         * Encodes the specified SetWalletNameMsg message. Does not implicitly {@link namecoin.SetWalletNameMsg.verify|verify} messages.
         * @function encode
         * @memberof namecoin.SetWalletNameMsg
         * @static
         * @param {namecoin.ISetWalletNameMsg} message SetWalletNameMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetWalletNameMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.address);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified SetWalletNameMsg message, length delimited. Does not implicitly {@link namecoin.SetWalletNameMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof namecoin.SetWalletNameMsg
         * @static
         * @param {namecoin.ISetWalletNameMsg} message SetWalletNameMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetWalletNameMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetWalletNameMsg message from the specified reader or buffer.
         * @function decode
         * @memberof namecoin.SetWalletNameMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {namecoin.SetWalletNameMsg} SetWalletNameMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetWalletNameMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.namecoin.SetWalletNameMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.address = reader.bytes();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetWalletNameMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof namecoin.SetWalletNameMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {namecoin.SetWalletNameMsg} SetWalletNameMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetWalletNameMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetWalletNameMsg message.
         * @function verify
         * @memberof namecoin.SetWalletNameMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetWalletNameMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a SetWalletNameMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof namecoin.SetWalletNameMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {namecoin.SetWalletNameMsg} SetWalletNameMsg
         */
        SetWalletNameMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.namecoin.SetWalletNameMsg)
                return object;
            var message = new $root.namecoin.SetWalletNameMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".namecoin.SetWalletNameMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a SetWalletNameMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof namecoin.SetWalletNameMsg
         * @static
         * @param {namecoin.SetWalletNameMsg} message SetWalletNameMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetWalletNameMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.name = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this SetWalletNameMsg to JSON.
         * @function toJSON
         * @memberof namecoin.SetWalletNameMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetWalletNameMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetWalletNameMsg;
    })();

    return namecoin;
})();

$root.nft = (function() {

    /**
     * Namespace nft.
     * @exports nft
     * @namespace
     */
    var nft = {};

    nft.NonFungibleToken = (function() {

        /**
         * Properties of a NonFungibleToken.
         * @memberof nft
         * @interface INonFungibleToken
         * @property {weave.IMetadata|null} [metadata] NonFungibleToken metadata
         * @property {Uint8Array|null} [id] ID is the address of this token.
         * @property {Uint8Array|null} [owner] Owner is the address of the token owner.
         * @property {Array.<nft.IActionApprovals>|null} [actionApprovals] succeed, all action approvals validation must pass.
         */

        /**
         * Constructs a new NonFungibleToken.
         * @memberof nft
         * @classdesc implementation. Usually it is the first attirbute called `base`.
         * @implements INonFungibleToken
         * @constructor
         * @param {nft.INonFungibleToken=} [properties] Properties to set
         */
        function NonFungibleToken(properties) {
            this.actionApprovals = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NonFungibleToken metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof nft.NonFungibleToken
         * @instance
         */
        NonFungibleToken.prototype.metadata = null;

        /**
         * ID is the address of this token.
         * @member {Uint8Array} id
         * @memberof nft.NonFungibleToken
         * @instance
         */
        NonFungibleToken.prototype.id = $util.newBuffer([]);

        /**
         * Owner is the address of the token owner.
         * @member {Uint8Array} owner
         * @memberof nft.NonFungibleToken
         * @instance
         */
        NonFungibleToken.prototype.owner = $util.newBuffer([]);

        /**
         * succeed, all action approvals validation must pass.
         * @member {Array.<nft.IActionApprovals>} actionApprovals
         * @memberof nft.NonFungibleToken
         * @instance
         */
        NonFungibleToken.prototype.actionApprovals = $util.emptyArray;

        /**
         * Creates a new NonFungibleToken instance using the specified properties.
         * @function create
         * @memberof nft.NonFungibleToken
         * @static
         * @param {nft.INonFungibleToken=} [properties] Properties to set
         * @returns {nft.NonFungibleToken} NonFungibleToken instance
         */
        NonFungibleToken.create = function create(properties) {
            return new NonFungibleToken(properties);
        };

        /**
         * Encodes the specified NonFungibleToken message. Does not implicitly {@link nft.NonFungibleToken.verify|verify} messages.
         * @function encode
         * @memberof nft.NonFungibleToken
         * @static
         * @param {nft.INonFungibleToken} message NonFungibleToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NonFungibleToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id);
            if (message.owner != null && message.hasOwnProperty("owner"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.owner);
            if (message.actionApprovals != null && message.actionApprovals.length)
                for (var i = 0; i < message.actionApprovals.length; ++i)
                    $root.nft.ActionApprovals.encode(message.actionApprovals[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NonFungibleToken message, length delimited. Does not implicitly {@link nft.NonFungibleToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nft.NonFungibleToken
         * @static
         * @param {nft.INonFungibleToken} message NonFungibleToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NonFungibleToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NonFungibleToken message from the specified reader or buffer.
         * @function decode
         * @memberof nft.NonFungibleToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nft.NonFungibleToken} NonFungibleToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NonFungibleToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nft.NonFungibleToken();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.bytes();
                    break;
                case 3:
                    message.owner = reader.bytes();
                    break;
                case 4:
                    if (!(message.actionApprovals && message.actionApprovals.length))
                        message.actionApprovals = [];
                    message.actionApprovals.push($root.nft.ActionApprovals.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NonFungibleToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nft.NonFungibleToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nft.NonFungibleToken} NonFungibleToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NonFungibleToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NonFungibleToken message.
         * @function verify
         * @memberof nft.NonFungibleToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NonFungibleToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                    return "owner: buffer expected";
            if (message.actionApprovals != null && message.hasOwnProperty("actionApprovals")) {
                if (!Array.isArray(message.actionApprovals))
                    return "actionApprovals: array expected";
                for (var i = 0; i < message.actionApprovals.length; ++i) {
                    var error = $root.nft.ActionApprovals.verify(message.actionApprovals[i]);
                    if (error)
                        return "actionApprovals." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NonFungibleToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nft.NonFungibleToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nft.NonFungibleToken} NonFungibleToken
         */
        NonFungibleToken.fromObject = function fromObject(object) {
            if (object instanceof $root.nft.NonFungibleToken)
                return object;
            var message = new $root.nft.NonFungibleToken();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".nft.NonFungibleToken.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.owner != null)
                if (typeof object.owner === "string")
                    $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                else if (object.owner.length)
                    message.owner = object.owner;
            if (object.actionApprovals) {
                if (!Array.isArray(object.actionApprovals))
                    throw TypeError(".nft.NonFungibleToken.actionApprovals: array expected");
                message.actionApprovals = [];
                for (var i = 0; i < object.actionApprovals.length; ++i) {
                    if (typeof object.actionApprovals[i] !== "object")
                        throw TypeError(".nft.NonFungibleToken.actionApprovals: object expected");
                    message.actionApprovals[i] = $root.nft.ActionApprovals.fromObject(object.actionApprovals[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NonFungibleToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nft.NonFungibleToken
         * @static
         * @param {nft.NonFungibleToken} message NonFungibleToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NonFungibleToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.actionApprovals = [];
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.owner = "";
                else {
                    object.owner = [];
                    if (options.bytes !== Array)
                        object.owner = $util.newBuffer(object.owner);
                }
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
            if (message.actionApprovals && message.actionApprovals.length) {
                object.actionApprovals = [];
                for (var j = 0; j < message.actionApprovals.length; ++j)
                    object.actionApprovals[j] = $root.nft.ActionApprovals.toObject(message.actionApprovals[j], options);
            }
            return object;
        };

        /**
         * Converts this NonFungibleToken to JSON.
         * @function toJSON
         * @memberof nft.NonFungibleToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NonFungibleToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NonFungibleToken;
    })();

    nft.ActionApprovals = (function() {

        /**
         * Properties of an ActionApprovals.
         * @memberof nft
         * @interface IActionApprovals
         * @property {string|null} [action] ActionApprovals action
         * @property {Array.<nft.IApproval>|null} [approvals] ActionApprovals approvals
         */

        /**
         * Constructs a new ActionApprovals.
         * @memberof nft
         * @classdesc execute given operation.
         * @implements IActionApprovals
         * @constructor
         * @param {nft.IActionApprovals=} [properties] Properties to set
         */
        function ActionApprovals(properties) {
            this.approvals = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionApprovals action.
         * @member {string} action
         * @memberof nft.ActionApprovals
         * @instance
         */
        ActionApprovals.prototype.action = "";

        /**
         * ActionApprovals approvals.
         * @member {Array.<nft.IApproval>} approvals
         * @memberof nft.ActionApprovals
         * @instance
         */
        ActionApprovals.prototype.approvals = $util.emptyArray;

        /**
         * Creates a new ActionApprovals instance using the specified properties.
         * @function create
         * @memberof nft.ActionApprovals
         * @static
         * @param {nft.IActionApprovals=} [properties] Properties to set
         * @returns {nft.ActionApprovals} ActionApprovals instance
         */
        ActionApprovals.create = function create(properties) {
            return new ActionApprovals(properties);
        };

        /**
         * Encodes the specified ActionApprovals message. Does not implicitly {@link nft.ActionApprovals.verify|verify} messages.
         * @function encode
         * @memberof nft.ActionApprovals
         * @static
         * @param {nft.IActionApprovals} message ActionApprovals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionApprovals.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && message.hasOwnProperty("action"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.action);
            if (message.approvals != null && message.approvals.length)
                for (var i = 0; i < message.approvals.length; ++i)
                    $root.nft.Approval.encode(message.approvals[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ActionApprovals message, length delimited. Does not implicitly {@link nft.ActionApprovals.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nft.ActionApprovals
         * @static
         * @param {nft.IActionApprovals} message ActionApprovals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionApprovals.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionApprovals message from the specified reader or buffer.
         * @function decode
         * @memberof nft.ActionApprovals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nft.ActionApprovals} ActionApprovals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionApprovals.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nft.ActionApprovals();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.string();
                    break;
                case 2:
                    if (!(message.approvals && message.approvals.length))
                        message.approvals = [];
                    message.approvals.push($root.nft.Approval.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionApprovals message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nft.ActionApprovals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nft.ActionApprovals} ActionApprovals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionApprovals.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionApprovals message.
         * @function verify
         * @memberof nft.ActionApprovals
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionApprovals.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                if (!$util.isString(message.action))
                    return "action: string expected";
            if (message.approvals != null && message.hasOwnProperty("approvals")) {
                if (!Array.isArray(message.approvals))
                    return "approvals: array expected";
                for (var i = 0; i < message.approvals.length; ++i) {
                    var error = $root.nft.Approval.verify(message.approvals[i]);
                    if (error)
                        return "approvals." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ActionApprovals message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nft.ActionApprovals
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nft.ActionApprovals} ActionApprovals
         */
        ActionApprovals.fromObject = function fromObject(object) {
            if (object instanceof $root.nft.ActionApprovals)
                return object;
            var message = new $root.nft.ActionApprovals();
            if (object.action != null)
                message.action = String(object.action);
            if (object.approvals) {
                if (!Array.isArray(object.approvals))
                    throw TypeError(".nft.ActionApprovals.approvals: array expected");
                message.approvals = [];
                for (var i = 0; i < object.approvals.length; ++i) {
                    if (typeof object.approvals[i] !== "object")
                        throw TypeError(".nft.ActionApprovals.approvals: object expected");
                    message.approvals[i] = $root.nft.Approval.fromObject(object.approvals[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ActionApprovals message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nft.ActionApprovals
         * @static
         * @param {nft.ActionApprovals} message ActionApprovals
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionApprovals.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.approvals = [];
            if (options.defaults)
                object.action = "";
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = message.action;
            if (message.approvals && message.approvals.length) {
                object.approvals = [];
                for (var j = 0; j < message.approvals.length; ++j)
                    object.approvals[j] = $root.nft.Approval.toObject(message.approvals[j], options);
            }
            return object;
        };

        /**
         * Converts this ActionApprovals to JSON.
         * @function toJSON
         * @memberof nft.ActionApprovals
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionApprovals.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ActionApprovals;
    })();

    nft.Approval = (function() {

        /**
         * Properties of an Approval.
         * @memberof nft
         * @interface IApproval
         * @property {Uint8Array|null} [address] Approval address
         * @property {nft.IApprovalOptions|null} [options] Approval options
         */

        /**
         * Constructs a new Approval.
         * @memberof nft
         * @classdesc Represents an Approval.
         * @implements IApproval
         * @constructor
         * @param {nft.IApproval=} [properties] Properties to set
         */
        function Approval(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Approval address.
         * @member {Uint8Array} address
         * @memberof nft.Approval
         * @instance
         */
        Approval.prototype.address = $util.newBuffer([]);

        /**
         * Approval options.
         * @member {nft.IApprovalOptions|null|undefined} options
         * @memberof nft.Approval
         * @instance
         */
        Approval.prototype.options = null;

        /**
         * Creates a new Approval instance using the specified properties.
         * @function create
         * @memberof nft.Approval
         * @static
         * @param {nft.IApproval=} [properties] Properties to set
         * @returns {nft.Approval} Approval instance
         */
        Approval.create = function create(properties) {
            return new Approval(properties);
        };

        /**
         * Encodes the specified Approval message. Does not implicitly {@link nft.Approval.verify|verify} messages.
         * @function encode
         * @memberof nft.Approval
         * @static
         * @param {nft.IApproval} message Approval message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Approval.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.options != null && message.hasOwnProperty("options"))
                $root.nft.ApprovalOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Approval message, length delimited. Does not implicitly {@link nft.Approval.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nft.Approval
         * @static
         * @param {nft.IApproval} message Approval message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Approval.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Approval message from the specified reader or buffer.
         * @function decode
         * @memberof nft.Approval
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nft.Approval} Approval
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Approval.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nft.Approval();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.options = $root.nft.ApprovalOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Approval message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nft.Approval
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nft.Approval} Approval
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Approval.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Approval message.
         * @function verify
         * @memberof nft.Approval
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Approval.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.nft.ApprovalOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            return null;
        };

        /**
         * Creates an Approval message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nft.Approval
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nft.Approval} Approval
         */
        Approval.fromObject = function fromObject(object) {
            if (object instanceof $root.nft.Approval)
                return object;
            var message = new $root.nft.Approval();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".nft.Approval.options: object expected");
                message.options = $root.nft.ApprovalOptions.fromObject(object.options);
            }
            return message;
        };

        /**
         * Creates a plain object from an Approval message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nft.Approval
         * @static
         * @param {nft.Approval} message Approval
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Approval.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.options = null;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.nft.ApprovalOptions.toObject(message.options, options);
            return object;
        };

        /**
         * Converts this Approval to JSON.
         * @function toJSON
         * @memberof nft.Approval
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Approval.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Approval;
    })();

    nft.ApprovalOptions = (function() {

        /**
         * Properties of an ApprovalOptions.
         * @memberof nft
         * @interface IApprovalOptions
         * @property {number|Long|null} [untilBlockHeight] approval is valid. This can be used to define an approval expiration.
         * @property {number|Long|null} [count] Use -1 to bypass count expiration.
         * @property {boolean|null} [immutable] changed.
         */

        /**
         * Constructs a new ApprovalOptions.
         * @memberof nft
         * @classdesc Represents an ApprovalOptions.
         * @implements IApprovalOptions
         * @constructor
         * @param {nft.IApprovalOptions=} [properties] Properties to set
         */
        function ApprovalOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * approval is valid. This can be used to define an approval expiration.
         * @member {number|Long} untilBlockHeight
         * @memberof nft.ApprovalOptions
         * @instance
         */
        ApprovalOptions.prototype.untilBlockHeight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Use -1 to bypass count expiration.
         * @member {number|Long} count
         * @memberof nft.ApprovalOptions
         * @instance
         */
        ApprovalOptions.prototype.count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * changed.
         * @member {boolean} immutable
         * @memberof nft.ApprovalOptions
         * @instance
         */
        ApprovalOptions.prototype.immutable = false;

        /**
         * Creates a new ApprovalOptions instance using the specified properties.
         * @function create
         * @memberof nft.ApprovalOptions
         * @static
         * @param {nft.IApprovalOptions=} [properties] Properties to set
         * @returns {nft.ApprovalOptions} ApprovalOptions instance
         */
        ApprovalOptions.create = function create(properties) {
            return new ApprovalOptions(properties);
        };

        /**
         * Encodes the specified ApprovalOptions message. Does not implicitly {@link nft.ApprovalOptions.verify|verify} messages.
         * @function encode
         * @memberof nft.ApprovalOptions
         * @static
         * @param {nft.IApprovalOptions} message ApprovalOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApprovalOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.untilBlockHeight != null && message.hasOwnProperty("untilBlockHeight"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.untilBlockHeight);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.count);
            if (message.immutable != null && message.hasOwnProperty("immutable"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.immutable);
            return writer;
        };

        /**
         * Encodes the specified ApprovalOptions message, length delimited. Does not implicitly {@link nft.ApprovalOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nft.ApprovalOptions
         * @static
         * @param {nft.IApprovalOptions} message ApprovalOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApprovalOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApprovalOptions message from the specified reader or buffer.
         * @function decode
         * @memberof nft.ApprovalOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nft.ApprovalOptions} ApprovalOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApprovalOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nft.ApprovalOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.untilBlockHeight = reader.int64();
                    break;
                case 2:
                    message.count = reader.int64();
                    break;
                case 3:
                    message.immutable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApprovalOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nft.ApprovalOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nft.ApprovalOptions} ApprovalOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApprovalOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApprovalOptions message.
         * @function verify
         * @memberof nft.ApprovalOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApprovalOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.untilBlockHeight != null && message.hasOwnProperty("untilBlockHeight"))
                if (!$util.isInteger(message.untilBlockHeight) && !(message.untilBlockHeight && $util.isInteger(message.untilBlockHeight.low) && $util.isInteger(message.untilBlockHeight.high)))
                    return "untilBlockHeight: integer|Long expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                    return "count: integer|Long expected";
            if (message.immutable != null && message.hasOwnProperty("immutable"))
                if (typeof message.immutable !== "boolean")
                    return "immutable: boolean expected";
            return null;
        };

        /**
         * Creates an ApprovalOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nft.ApprovalOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nft.ApprovalOptions} ApprovalOptions
         */
        ApprovalOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.nft.ApprovalOptions)
                return object;
            var message = new $root.nft.ApprovalOptions();
            if (object.untilBlockHeight != null)
                if ($util.Long)
                    (message.untilBlockHeight = $util.Long.fromValue(object.untilBlockHeight)).unsigned = false;
                else if (typeof object.untilBlockHeight === "string")
                    message.untilBlockHeight = parseInt(object.untilBlockHeight, 10);
                else if (typeof object.untilBlockHeight === "number")
                    message.untilBlockHeight = object.untilBlockHeight;
                else if (typeof object.untilBlockHeight === "object")
                    message.untilBlockHeight = new $util.LongBits(object.untilBlockHeight.low >>> 0, object.untilBlockHeight.high >>> 0).toNumber();
            if (object.count != null)
                if ($util.Long)
                    (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                else if (typeof object.count === "string")
                    message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number")
                    message.count = object.count;
                else if (typeof object.count === "object")
                    message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
            if (object.immutable != null)
                message.immutable = Boolean(object.immutable);
            return message;
        };

        /**
         * Creates a plain object from an ApprovalOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nft.ApprovalOptions
         * @static
         * @param {nft.ApprovalOptions} message ApprovalOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApprovalOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.untilBlockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.untilBlockHeight = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.count = options.longs === String ? "0" : 0;
                object.immutable = false;
            }
            if (message.untilBlockHeight != null && message.hasOwnProperty("untilBlockHeight"))
                if (typeof message.untilBlockHeight === "number")
                    object.untilBlockHeight = options.longs === String ? String(message.untilBlockHeight) : message.untilBlockHeight;
                else
                    object.untilBlockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.untilBlockHeight) : options.longs === Number ? new $util.LongBits(message.untilBlockHeight.low >>> 0, message.untilBlockHeight.high >>> 0).toNumber() : message.untilBlockHeight;
            if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                    object.count = options.longs === String ? String(message.count) : message.count;
                else
                    object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
            if (message.immutable != null && message.hasOwnProperty("immutable"))
                object.immutable = message.immutable;
            return object;
        };

        /**
         * Converts this ApprovalOptions to JSON.
         * @function toJSON
         * @memberof nft.ApprovalOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApprovalOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApprovalOptions;
    })();

    nft.AddApprovalMsg = (function() {

        /**
         * Properties of an AddApprovalMsg.
         * @memberof nft
         * @interface IAddApprovalMsg
         * @property {weave.IMetadata|null} [metadata] AddApprovalMsg metadata
         * @property {Uint8Array|null} [id] AddApprovalMsg id
         * @property {Uint8Array|null} [address] AddApprovalMsg address
         * @property {string|null} [action] AddApprovalMsg action
         * @property {nft.IApprovalOptions|null} [options] AddApprovalMsg options
         * @property {string|null} [t] AddApprovalMsg t
         */

        /**
         * Constructs a new AddApprovalMsg.
         * @memberof nft
         * @classdesc Represents an AddApprovalMsg.
         * @implements IAddApprovalMsg
         * @constructor
         * @param {nft.IAddApprovalMsg=} [properties] Properties to set
         */
        function AddApprovalMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddApprovalMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof nft.AddApprovalMsg
         * @instance
         */
        AddApprovalMsg.prototype.metadata = null;

        /**
         * AddApprovalMsg id.
         * @member {Uint8Array} id
         * @memberof nft.AddApprovalMsg
         * @instance
         */
        AddApprovalMsg.prototype.id = $util.newBuffer([]);

        /**
         * AddApprovalMsg address.
         * @member {Uint8Array} address
         * @memberof nft.AddApprovalMsg
         * @instance
         */
        AddApprovalMsg.prototype.address = $util.newBuffer([]);

        /**
         * AddApprovalMsg action.
         * @member {string} action
         * @memberof nft.AddApprovalMsg
         * @instance
         */
        AddApprovalMsg.prototype.action = "";

        /**
         * AddApprovalMsg options.
         * @member {nft.IApprovalOptions|null|undefined} options
         * @memberof nft.AddApprovalMsg
         * @instance
         */
        AddApprovalMsg.prototype.options = null;

        /**
         * AddApprovalMsg t.
         * @member {string} t
         * @memberof nft.AddApprovalMsg
         * @instance
         */
        AddApprovalMsg.prototype.t = "";

        /**
         * Creates a new AddApprovalMsg instance using the specified properties.
         * @function create
         * @memberof nft.AddApprovalMsg
         * @static
         * @param {nft.IAddApprovalMsg=} [properties] Properties to set
         * @returns {nft.AddApprovalMsg} AddApprovalMsg instance
         */
        AddApprovalMsg.create = function create(properties) {
            return new AddApprovalMsg(properties);
        };

        /**
         * Encodes the specified AddApprovalMsg message. Does not implicitly {@link nft.AddApprovalMsg.verify|verify} messages.
         * @function encode
         * @memberof nft.AddApprovalMsg
         * @static
         * @param {nft.IAddApprovalMsg} message AddApprovalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddApprovalMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.address);
            if (message.action != null && message.hasOwnProperty("action"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.action);
            if (message.options != null && message.hasOwnProperty("options"))
                $root.nft.ApprovalOptions.encode(message.options, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.t != null && message.hasOwnProperty("t"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.t);
            return writer;
        };

        /**
         * Encodes the specified AddApprovalMsg message, length delimited. Does not implicitly {@link nft.AddApprovalMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nft.AddApprovalMsg
         * @static
         * @param {nft.IAddApprovalMsg} message AddApprovalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddApprovalMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddApprovalMsg message from the specified reader or buffer.
         * @function decode
         * @memberof nft.AddApprovalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nft.AddApprovalMsg} AddApprovalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddApprovalMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nft.AddApprovalMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.bytes();
                    break;
                case 3:
                    message.address = reader.bytes();
                    break;
                case 4:
                    message.action = reader.string();
                    break;
                case 5:
                    message.options = $root.nft.ApprovalOptions.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.t = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddApprovalMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nft.AddApprovalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nft.AddApprovalMsg} AddApprovalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddApprovalMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddApprovalMsg message.
         * @function verify
         * @memberof nft.AddApprovalMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddApprovalMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.action != null && message.hasOwnProperty("action"))
                if (!$util.isString(message.action))
                    return "action: string expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                var error = $root.nft.ApprovalOptions.verify(message.options);
                if (error)
                    return "options." + error;
            }
            if (message.t != null && message.hasOwnProperty("t"))
                if (!$util.isString(message.t))
                    return "t: string expected";
            return null;
        };

        /**
         * Creates an AddApprovalMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nft.AddApprovalMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nft.AddApprovalMsg} AddApprovalMsg
         */
        AddApprovalMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.nft.AddApprovalMsg)
                return object;
            var message = new $root.nft.AddApprovalMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".nft.AddApprovalMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.action != null)
                message.action = String(object.action);
            if (object.options != null) {
                if (typeof object.options !== "object")
                    throw TypeError(".nft.AddApprovalMsg.options: object expected");
                message.options = $root.nft.ApprovalOptions.fromObject(object.options);
            }
            if (object.t != null)
                message.t = String(object.t);
            return message;
        };

        /**
         * Creates a plain object from an AddApprovalMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nft.AddApprovalMsg
         * @static
         * @param {nft.AddApprovalMsg} message AddApprovalMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddApprovalMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.action = "";
                object.options = null;
                object.t = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = message.action;
            if (message.options != null && message.hasOwnProperty("options"))
                object.options = $root.nft.ApprovalOptions.toObject(message.options, options);
            if (message.t != null && message.hasOwnProperty("t"))
                object.t = message.t;
            return object;
        };

        /**
         * Converts this AddApprovalMsg to JSON.
         * @function toJSON
         * @memberof nft.AddApprovalMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddApprovalMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddApprovalMsg;
    })();

    nft.RemoveApprovalMsg = (function() {

        /**
         * Properties of a RemoveApprovalMsg.
         * @memberof nft
         * @interface IRemoveApprovalMsg
         * @property {weave.IMetadata|null} [metadata] RemoveApprovalMsg metadata
         * @property {Uint8Array|null} [id] RemoveApprovalMsg id
         * @property {Uint8Array|null} [address] RemoveApprovalMsg address
         * @property {string|null} [action] RemoveApprovalMsg action
         * @property {string|null} [t] RemoveApprovalMsg t
         */

        /**
         * Constructs a new RemoveApprovalMsg.
         * @memberof nft
         * @classdesc Represents a RemoveApprovalMsg.
         * @implements IRemoveApprovalMsg
         * @constructor
         * @param {nft.IRemoveApprovalMsg=} [properties] Properties to set
         */
        function RemoveApprovalMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RemoveApprovalMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof nft.RemoveApprovalMsg
         * @instance
         */
        RemoveApprovalMsg.prototype.metadata = null;

        /**
         * RemoveApprovalMsg id.
         * @member {Uint8Array} id
         * @memberof nft.RemoveApprovalMsg
         * @instance
         */
        RemoveApprovalMsg.prototype.id = $util.newBuffer([]);

        /**
         * RemoveApprovalMsg address.
         * @member {Uint8Array} address
         * @memberof nft.RemoveApprovalMsg
         * @instance
         */
        RemoveApprovalMsg.prototype.address = $util.newBuffer([]);

        /**
         * RemoveApprovalMsg action.
         * @member {string} action
         * @memberof nft.RemoveApprovalMsg
         * @instance
         */
        RemoveApprovalMsg.prototype.action = "";

        /**
         * RemoveApprovalMsg t.
         * @member {string} t
         * @memberof nft.RemoveApprovalMsg
         * @instance
         */
        RemoveApprovalMsg.prototype.t = "";

        /**
         * Creates a new RemoveApprovalMsg instance using the specified properties.
         * @function create
         * @memberof nft.RemoveApprovalMsg
         * @static
         * @param {nft.IRemoveApprovalMsg=} [properties] Properties to set
         * @returns {nft.RemoveApprovalMsg} RemoveApprovalMsg instance
         */
        RemoveApprovalMsg.create = function create(properties) {
            return new RemoveApprovalMsg(properties);
        };

        /**
         * Encodes the specified RemoveApprovalMsg message. Does not implicitly {@link nft.RemoveApprovalMsg.verify|verify} messages.
         * @function encode
         * @memberof nft.RemoveApprovalMsg
         * @static
         * @param {nft.IRemoveApprovalMsg} message RemoveApprovalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveApprovalMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.id);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.address);
            if (message.action != null && message.hasOwnProperty("action"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.action);
            if (message.t != null && message.hasOwnProperty("t"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.t);
            return writer;
        };

        /**
         * Encodes the specified RemoveApprovalMsg message, length delimited. Does not implicitly {@link nft.RemoveApprovalMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nft.RemoveApprovalMsg
         * @static
         * @param {nft.IRemoveApprovalMsg} message RemoveApprovalMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RemoveApprovalMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RemoveApprovalMsg message from the specified reader or buffer.
         * @function decode
         * @memberof nft.RemoveApprovalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nft.RemoveApprovalMsg} RemoveApprovalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveApprovalMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nft.RemoveApprovalMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.id = reader.bytes();
                    break;
                case 3:
                    message.address = reader.bytes();
                    break;
                case 4:
                    message.action = reader.string();
                    break;
                case 5:
                    message.t = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RemoveApprovalMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nft.RemoveApprovalMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nft.RemoveApprovalMsg} RemoveApprovalMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RemoveApprovalMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RemoveApprovalMsg message.
         * @function verify
         * @memberof nft.RemoveApprovalMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RemoveApprovalMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.action != null && message.hasOwnProperty("action"))
                if (!$util.isString(message.action))
                    return "action: string expected";
            if (message.t != null && message.hasOwnProperty("t"))
                if (!$util.isString(message.t))
                    return "t: string expected";
            return null;
        };

        /**
         * Creates a RemoveApprovalMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nft.RemoveApprovalMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nft.RemoveApprovalMsg} RemoveApprovalMsg
         */
        RemoveApprovalMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.nft.RemoveApprovalMsg)
                return object;
            var message = new $root.nft.RemoveApprovalMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".nft.RemoveApprovalMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.action != null)
                message.action = String(object.action);
            if (object.t != null)
                message.t = String(object.t);
            return message;
        };

        /**
         * Creates a plain object from a RemoveApprovalMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nft.RemoveApprovalMsg
         * @static
         * @param {nft.RemoveApprovalMsg} message RemoveApprovalMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RemoveApprovalMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.action = "";
                object.t = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = message.action;
            if (message.t != null && message.hasOwnProperty("t"))
                object.t = message.t;
            return object;
        };

        /**
         * Converts this RemoveApprovalMsg to JSON.
         * @function toJSON
         * @memberof nft.RemoveApprovalMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RemoveApprovalMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RemoveApprovalMsg;
    })();

    return nft;
})();

$root.paychan = (function() {

    /**
     * Namespace paychan.
     * @exports paychan
     * @namespace
     */
    var paychan = {};

    paychan.PaymentChannel = (function() {

        /**
         * Properties of a PaymentChannel.
         * @memberof paychan
         * @interface IPaymentChannel
         * @property {weave.IMetadata|null} [metadata] PaymentChannel metadata
         * @property {Uint8Array|null} [src] Sender is the source that the founds are allocated from.
         * @property {crypto.IPublicKey|null} [senderPubkey] to the recipient. Signature prevents from altering transfer message.
         * @property {Uint8Array|null} [recipient] Recipient is the party that receives payments through this channel
         * @property {coin.ICoin|null} [total] payment channel.
         * @property {number|Long|null} [timeout] expired: [timeout, infinity)
         * @property {string|null} [memo] Max length 128 character.
         * @property {coin.ICoin|null} [transferred] (total) value. Transferred must never exceed total value.
         */

        /**
         * Constructs a new PaymentChannel.
         * @memberof paychan
         * @classdesc PaymentChannel holds the state of a payment channel during its lifetime.
         * @implements IPaymentChannel
         * @constructor
         * @param {paychan.IPaymentChannel=} [properties] Properties to set
         */
        function PaymentChannel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaymentChannel metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.metadata = null;

        /**
         * Sender is the source that the founds are allocated from.
         * @member {Uint8Array} src
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.src = $util.newBuffer([]);

        /**
         * to the recipient. Signature prevents from altering transfer message.
         * @member {crypto.IPublicKey|null|undefined} senderPubkey
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.senderPubkey = null;

        /**
         * Recipient is the party that receives payments through this channel
         * @member {Uint8Array} recipient
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.recipient = $util.newBuffer([]);

        /**
         * payment channel.
         * @member {coin.ICoin|null|undefined} total
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.total = null;

        /**
         * expired: [timeout, infinity)
         * @member {number|Long} timeout
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Max length 128 character.
         * @member {string} memo
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.memo = "";

        /**
         * (total) value. Transferred must never exceed total value.
         * @member {coin.ICoin|null|undefined} transferred
         * @memberof paychan.PaymentChannel
         * @instance
         */
        PaymentChannel.prototype.transferred = null;

        /**
         * Creates a new PaymentChannel instance using the specified properties.
         * @function create
         * @memberof paychan.PaymentChannel
         * @static
         * @param {paychan.IPaymentChannel=} [properties] Properties to set
         * @returns {paychan.PaymentChannel} PaymentChannel instance
         */
        PaymentChannel.create = function create(properties) {
            return new PaymentChannel(properties);
        };

        /**
         * Encodes the specified PaymentChannel message. Does not implicitly {@link paychan.PaymentChannel.verify|verify} messages.
         * @function encode
         * @memberof paychan.PaymentChannel
         * @static
         * @param {paychan.IPaymentChannel} message PaymentChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentChannel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.src != null && message.hasOwnProperty("src"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.src);
            if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey"))
                $root.crypto.PublicKey.encode(message.senderPubkey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.recipient);
            if (message.total != null && message.hasOwnProperty("total"))
                $root.coin.Coin.encode(message.total, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            if (message.transferred != null && message.hasOwnProperty("transferred"))
                $root.coin.Coin.encode(message.transferred, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PaymentChannel message, length delimited. Does not implicitly {@link paychan.PaymentChannel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.PaymentChannel
         * @static
         * @param {paychan.IPaymentChannel} message PaymentChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentChannel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentChannel message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.PaymentChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.PaymentChannel} PaymentChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentChannel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.PaymentChannel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.src = reader.bytes();
                    break;
                case 3:
                    message.senderPubkey = $root.crypto.PublicKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.recipient = reader.bytes();
                    break;
                case 5:
                    message.total = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                case 8:
                    message.transferred = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentChannel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.PaymentChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.PaymentChannel} PaymentChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentChannel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentChannel message.
         * @function verify
         * @memberof paychan.PaymentChannel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentChannel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.src != null && message.hasOwnProperty("src"))
                if (!(message.src && typeof message.src.length === "number" || $util.isString(message.src)))
                    return "src: buffer expected";
            if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey")) {
                var error = $root.crypto.PublicKey.verify(message.senderPubkey);
                if (error)
                    return "senderPubkey." + error;
            }
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.total != null && message.hasOwnProperty("total")) {
                var error = $root.coin.Coin.verify(message.total);
                if (error)
                    return "total." + error;
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.transferred != null && message.hasOwnProperty("transferred")) {
                var error = $root.coin.Coin.verify(message.transferred);
                if (error)
                    return "transferred." + error;
            }
            return null;
        };

        /**
         * Creates a PaymentChannel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.PaymentChannel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.PaymentChannel} PaymentChannel
         */
        PaymentChannel.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.PaymentChannel)
                return object;
            var message = new $root.paychan.PaymentChannel();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".paychan.PaymentChannel.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.src != null)
                if (typeof object.src === "string")
                    $util.base64.decode(object.src, message.src = $util.newBuffer($util.base64.length(object.src)), 0);
                else if (object.src.length)
                    message.src = object.src;
            if (object.senderPubkey != null) {
                if (typeof object.senderPubkey !== "object")
                    throw TypeError(".paychan.PaymentChannel.senderPubkey: object expected");
                message.senderPubkey = $root.crypto.PublicKey.fromObject(object.senderPubkey);
            }
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.total != null) {
                if (typeof object.total !== "object")
                    throw TypeError(".paychan.PaymentChannel.total: object expected");
                message.total = $root.coin.Coin.fromObject(object.total);
            }
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.transferred != null) {
                if (typeof object.transferred !== "object")
                    throw TypeError(".paychan.PaymentChannel.transferred: object expected");
                message.transferred = $root.coin.Coin.fromObject(object.transferred);
            }
            return message;
        };

        /**
         * Creates a plain object from a PaymentChannel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.PaymentChannel
         * @static
         * @param {paychan.PaymentChannel} message PaymentChannel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentChannel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.src = "";
                else {
                    object.src = [];
                    if (options.bytes !== Array)
                        object.src = $util.newBuffer(object.src);
                }
                object.senderPubkey = null;
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                object.total = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
                object.transferred = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.src != null && message.hasOwnProperty("src"))
                object.src = options.bytes === String ? $util.base64.encode(message.src, 0, message.src.length) : options.bytes === Array ? Array.prototype.slice.call(message.src) : message.src;
            if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey"))
                object.senderPubkey = $root.crypto.PublicKey.toObject(message.senderPubkey, options);
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = $root.coin.Coin.toObject(message.total, options);
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.transferred != null && message.hasOwnProperty("transferred"))
                object.transferred = $root.coin.Coin.toObject(message.transferred, options);
            return object;
        };

        /**
         * Converts this PaymentChannel to JSON.
         * @function toJSON
         * @memberof paychan.PaymentChannel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentChannel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaymentChannel;
    })();

    paychan.CreatePaymentChannelMsg = (function() {

        /**
         * Properties of a CreatePaymentChannelMsg.
         * @memberof paychan
         * @interface ICreatePaymentChannelMsg
         * @property {weave.IMetadata|null} [metadata] CreatePaymentChannelMsg metadata
         * @property {Uint8Array|null} [src] Sender address (weave.Address).
         * @property {crypto.IPublicKey|null} [senderPubkey] Sender public key is for validating transfer message signature.
         * @property {Uint8Array|null} [recipient] Recipient address  (weave.Address).
         * @property {coin.ICoin|null} [total] Maximum amount that can be transferred via this channel.
         * @property {number|Long|null} [timeout] If reached, channel can be closed by anyone.
         * @property {string|null} [memo] Max length 128 character.
         */

        /**
         * Constructs a new CreatePaymentChannelMsg.
         * @memberof paychan
         * @classdesc in the transactions done via created payment channel.
         * @implements ICreatePaymentChannelMsg
         * @constructor
         * @param {paychan.ICreatePaymentChannelMsg=} [properties] Properties to set
         */
        function CreatePaymentChannelMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreatePaymentChannelMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof paychan.CreatePaymentChannelMsg
         * @instance
         */
        CreatePaymentChannelMsg.prototype.metadata = null;

        /**
         * Sender address (weave.Address).
         * @member {Uint8Array} src
         * @memberof paychan.CreatePaymentChannelMsg
         * @instance
         */
        CreatePaymentChannelMsg.prototype.src = $util.newBuffer([]);

        /**
         * Sender public key is for validating transfer message signature.
         * @member {crypto.IPublicKey|null|undefined} senderPubkey
         * @memberof paychan.CreatePaymentChannelMsg
         * @instance
         */
        CreatePaymentChannelMsg.prototype.senderPubkey = null;

        /**
         * Recipient address  (weave.Address).
         * @member {Uint8Array} recipient
         * @memberof paychan.CreatePaymentChannelMsg
         * @instance
         */
        CreatePaymentChannelMsg.prototype.recipient = $util.newBuffer([]);

        /**
         * Maximum amount that can be transferred via this channel.
         * @member {coin.ICoin|null|undefined} total
         * @memberof paychan.CreatePaymentChannelMsg
         * @instance
         */
        CreatePaymentChannelMsg.prototype.total = null;

        /**
         * If reached, channel can be closed by anyone.
         * @member {number|Long} timeout
         * @memberof paychan.CreatePaymentChannelMsg
         * @instance
         */
        CreatePaymentChannelMsg.prototype.timeout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Max length 128 character.
         * @member {string} memo
         * @memberof paychan.CreatePaymentChannelMsg
         * @instance
         */
        CreatePaymentChannelMsg.prototype.memo = "";

        /**
         * Creates a new CreatePaymentChannelMsg instance using the specified properties.
         * @function create
         * @memberof paychan.CreatePaymentChannelMsg
         * @static
         * @param {paychan.ICreatePaymentChannelMsg=} [properties] Properties to set
         * @returns {paychan.CreatePaymentChannelMsg} CreatePaymentChannelMsg instance
         */
        CreatePaymentChannelMsg.create = function create(properties) {
            return new CreatePaymentChannelMsg(properties);
        };

        /**
         * Encodes the specified CreatePaymentChannelMsg message. Does not implicitly {@link paychan.CreatePaymentChannelMsg.verify|verify} messages.
         * @function encode
         * @memberof paychan.CreatePaymentChannelMsg
         * @static
         * @param {paychan.ICreatePaymentChannelMsg} message CreatePaymentChannelMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePaymentChannelMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.src != null && message.hasOwnProperty("src"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.src);
            if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey"))
                $root.crypto.PublicKey.encode(message.senderPubkey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.recipient);
            if (message.total != null && message.hasOwnProperty("total"))
                $root.coin.Coin.encode(message.total, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeout);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified CreatePaymentChannelMsg message, length delimited. Does not implicitly {@link paychan.CreatePaymentChannelMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.CreatePaymentChannelMsg
         * @static
         * @param {paychan.ICreatePaymentChannelMsg} message CreatePaymentChannelMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreatePaymentChannelMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreatePaymentChannelMsg message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.CreatePaymentChannelMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.CreatePaymentChannelMsg} CreatePaymentChannelMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePaymentChannelMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.CreatePaymentChannelMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.src = reader.bytes();
                    break;
                case 3:
                    message.senderPubkey = $root.crypto.PublicKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.recipient = reader.bytes();
                    break;
                case 5:
                    message.total = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.timeout = reader.int64();
                    break;
                case 7:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreatePaymentChannelMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.CreatePaymentChannelMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.CreatePaymentChannelMsg} CreatePaymentChannelMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreatePaymentChannelMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreatePaymentChannelMsg message.
         * @function verify
         * @memberof paychan.CreatePaymentChannelMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreatePaymentChannelMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.src != null && message.hasOwnProperty("src"))
                if (!(message.src && typeof message.src.length === "number" || $util.isString(message.src)))
                    return "src: buffer expected";
            if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey")) {
                var error = $root.crypto.PublicKey.verify(message.senderPubkey);
                if (error)
                    return "senderPubkey." + error;
            }
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                if (!(message.recipient && typeof message.recipient.length === "number" || $util.isString(message.recipient)))
                    return "recipient: buffer expected";
            if (message.total != null && message.hasOwnProperty("total")) {
                var error = $root.coin.Coin.verify(message.total);
                if (error)
                    return "total." + error;
            }
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (!$util.isInteger(message.timeout) && !(message.timeout && $util.isInteger(message.timeout.low) && $util.isInteger(message.timeout.high)))
                    return "timeout: integer|Long expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a CreatePaymentChannelMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.CreatePaymentChannelMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.CreatePaymentChannelMsg} CreatePaymentChannelMsg
         */
        CreatePaymentChannelMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.CreatePaymentChannelMsg)
                return object;
            var message = new $root.paychan.CreatePaymentChannelMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".paychan.CreatePaymentChannelMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.src != null)
                if (typeof object.src === "string")
                    $util.base64.decode(object.src, message.src = $util.newBuffer($util.base64.length(object.src)), 0);
                else if (object.src.length)
                    message.src = object.src;
            if (object.senderPubkey != null) {
                if (typeof object.senderPubkey !== "object")
                    throw TypeError(".paychan.CreatePaymentChannelMsg.senderPubkey: object expected");
                message.senderPubkey = $root.crypto.PublicKey.fromObject(object.senderPubkey);
            }
            if (object.recipient != null)
                if (typeof object.recipient === "string")
                    $util.base64.decode(object.recipient, message.recipient = $util.newBuffer($util.base64.length(object.recipient)), 0);
                else if (object.recipient.length)
                    message.recipient = object.recipient;
            if (object.total != null) {
                if (typeof object.total !== "object")
                    throw TypeError(".paychan.CreatePaymentChannelMsg.total: object expected");
                message.total = $root.coin.Coin.fromObject(object.total);
            }
            if (object.timeout != null)
                if ($util.Long)
                    (message.timeout = $util.Long.fromValue(object.timeout)).unsigned = false;
                else if (typeof object.timeout === "string")
                    message.timeout = parseInt(object.timeout, 10);
                else if (typeof object.timeout === "number")
                    message.timeout = object.timeout;
                else if (typeof object.timeout === "object")
                    message.timeout = new $util.LongBits(object.timeout.low >>> 0, object.timeout.high >>> 0).toNumber();
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a CreatePaymentChannelMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.CreatePaymentChannelMsg
         * @static
         * @param {paychan.CreatePaymentChannelMsg} message CreatePaymentChannelMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreatePaymentChannelMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.src = "";
                else {
                    object.src = [];
                    if (options.bytes !== Array)
                        object.src = $util.newBuffer(object.src);
                }
                object.senderPubkey = null;
                if (options.bytes === String)
                    object.recipient = "";
                else {
                    object.recipient = [];
                    if (options.bytes !== Array)
                        object.recipient = $util.newBuffer(object.recipient);
                }
                object.total = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timeout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeout = options.longs === String ? "0" : 0;
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.src != null && message.hasOwnProperty("src"))
                object.src = options.bytes === String ? $util.base64.encode(message.src, 0, message.src.length) : options.bytes === Array ? Array.prototype.slice.call(message.src) : message.src;
            if (message.senderPubkey != null && message.hasOwnProperty("senderPubkey"))
                object.senderPubkey = $root.crypto.PublicKey.toObject(message.senderPubkey, options);
            if (message.recipient != null && message.hasOwnProperty("recipient"))
                object.recipient = options.bytes === String ? $util.base64.encode(message.recipient, 0, message.recipient.length) : options.bytes === Array ? Array.prototype.slice.call(message.recipient) : message.recipient;
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = $root.coin.Coin.toObject(message.total, options);
            if (message.timeout != null && message.hasOwnProperty("timeout"))
                if (typeof message.timeout === "number")
                    object.timeout = options.longs === String ? String(message.timeout) : message.timeout;
                else
                    object.timeout = options.longs === String ? $util.Long.prototype.toString.call(message.timeout) : options.longs === Number ? new $util.LongBits(message.timeout.low >>> 0, message.timeout.high >>> 0).toNumber() : message.timeout;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this CreatePaymentChannelMsg to JSON.
         * @function toJSON
         * @memberof paychan.CreatePaymentChannelMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreatePaymentChannelMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreatePaymentChannelMsg;
    })();

    paychan.Payment = (function() {

        /**
         * Properties of a Payment.
         * @memberof paychan
         * @interface IPayment
         * @property {string|null} [chainId] Payment chainId
         * @property {Uint8Array|null} [channelId] Payment channelId
         * @property {coin.ICoin|null} [amount] Payment amount
         * @property {string|null} [memo] Max length 128 character.
         */

        /**
         * Constructs a new Payment.
         * @memberof paychan
         * @classdesc Each Payment should be created with amount greater than the previous one.
         * @implements IPayment
         * @constructor
         * @param {paychan.IPayment=} [properties] Properties to set
         */
        function Payment(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Payment chainId.
         * @member {string} chainId
         * @memberof paychan.Payment
         * @instance
         */
        Payment.prototype.chainId = "";

        /**
         * Payment channelId.
         * @member {Uint8Array} channelId
         * @memberof paychan.Payment
         * @instance
         */
        Payment.prototype.channelId = $util.newBuffer([]);

        /**
         * Payment amount.
         * @member {coin.ICoin|null|undefined} amount
         * @memberof paychan.Payment
         * @instance
         */
        Payment.prototype.amount = null;

        /**
         * Max length 128 character.
         * @member {string} memo
         * @memberof paychan.Payment
         * @instance
         */
        Payment.prototype.memo = "";

        /**
         * Creates a new Payment instance using the specified properties.
         * @function create
         * @memberof paychan.Payment
         * @static
         * @param {paychan.IPayment=} [properties] Properties to set
         * @returns {paychan.Payment} Payment instance
         */
        Payment.create = function create(properties) {
            return new Payment(properties);
        };

        /**
         * Encodes the specified Payment message. Does not implicitly {@link paychan.Payment.verify|verify} messages.
         * @function encode
         * @memberof paychan.Payment
         * @static
         * @param {paychan.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chainId);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.channelId);
            if (message.amount != null && message.hasOwnProperty("amount"))
                $root.coin.Coin.encode(message.amount, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified Payment message, length delimited. Does not implicitly {@link paychan.Payment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.Payment
         * @static
         * @param {paychan.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Payment message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.Payment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chainId = reader.string();
                    break;
                case 2:
                    message.channelId = reader.bytes();
                    break;
                case 3:
                    message.amount = $root.coin.Coin.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Payment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Payment message.
         * @function verify
         * @memberof paychan.Payment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Payment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                if (!$util.isString(message.chainId))
                    return "chainId: string expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount")) {
                var error = $root.coin.Coin.verify(message.amount);
                if (error)
                    return "amount." + error;
            }
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a Payment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.Payment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.Payment} Payment
         */
        Payment.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.Payment)
                return object;
            var message = new $root.paychan.Payment();
            if (object.chainId != null)
                message.chainId = String(object.chainId);
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length)
                    message.channelId = object.channelId;
            if (object.amount != null) {
                if (typeof object.amount !== "object")
                    throw TypeError(".paychan.Payment.amount: object expected");
                message.amount = $root.coin.Coin.fromObject(object.amount);
            }
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a Payment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.Payment
         * @static
         * @param {paychan.Payment} message Payment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Payment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.chainId = "";
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                object.amount = null;
                object.memo = "";
            }
            if (message.chainId != null && message.hasOwnProperty("chainId"))
                object.chainId = message.chainId;
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = $root.coin.Coin.toObject(message.amount, options);
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this Payment to JSON.
         * @function toJSON
         * @memberof paychan.Payment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Payment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Payment;
    })();

    paychan.TransferPaymentChannelMsg = (function() {

        /**
         * Properties of a TransferPaymentChannelMsg.
         * @memberof paychan
         * @interface ITransferPaymentChannelMsg
         * @property {weave.IMetadata|null} [metadata] TransferPaymentChannelMsg metadata
         * @property {paychan.IPayment|null} [payment] TransferPaymentChannelMsg payment
         * @property {crypto.ISignature|null} [signature] TransferPaymentChannelMsg signature
         */

        /**
         * Constructs a new TransferPaymentChannelMsg.
         * @memberof paychan
         * @classdesc Signature is there to ensure that payment message was not altered.
         * @implements ITransferPaymentChannelMsg
         * @constructor
         * @param {paychan.ITransferPaymentChannelMsg=} [properties] Properties to set
         */
        function TransferPaymentChannelMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransferPaymentChannelMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof paychan.TransferPaymentChannelMsg
         * @instance
         */
        TransferPaymentChannelMsg.prototype.metadata = null;

        /**
         * TransferPaymentChannelMsg payment.
         * @member {paychan.IPayment|null|undefined} payment
         * @memberof paychan.TransferPaymentChannelMsg
         * @instance
         */
        TransferPaymentChannelMsg.prototype.payment = null;

        /**
         * TransferPaymentChannelMsg signature.
         * @member {crypto.ISignature|null|undefined} signature
         * @memberof paychan.TransferPaymentChannelMsg
         * @instance
         */
        TransferPaymentChannelMsg.prototype.signature = null;

        /**
         * Creates a new TransferPaymentChannelMsg instance using the specified properties.
         * @function create
         * @memberof paychan.TransferPaymentChannelMsg
         * @static
         * @param {paychan.ITransferPaymentChannelMsg=} [properties] Properties to set
         * @returns {paychan.TransferPaymentChannelMsg} TransferPaymentChannelMsg instance
         */
        TransferPaymentChannelMsg.create = function create(properties) {
            return new TransferPaymentChannelMsg(properties);
        };

        /**
         * Encodes the specified TransferPaymentChannelMsg message. Does not implicitly {@link paychan.TransferPaymentChannelMsg.verify|verify} messages.
         * @function encode
         * @memberof paychan.TransferPaymentChannelMsg
         * @static
         * @param {paychan.ITransferPaymentChannelMsg} message TransferPaymentChannelMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferPaymentChannelMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.payment != null && message.hasOwnProperty("payment"))
                $root.paychan.Payment.encode(message.payment, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signature != null && message.hasOwnProperty("signature"))
                $root.crypto.Signature.encode(message.signature, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransferPaymentChannelMsg message, length delimited. Does not implicitly {@link paychan.TransferPaymentChannelMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.TransferPaymentChannelMsg
         * @static
         * @param {paychan.ITransferPaymentChannelMsg} message TransferPaymentChannelMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferPaymentChannelMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransferPaymentChannelMsg message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.TransferPaymentChannelMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.TransferPaymentChannelMsg} TransferPaymentChannelMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferPaymentChannelMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.TransferPaymentChannelMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.payment = $root.paychan.Payment.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signature = $root.crypto.Signature.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransferPaymentChannelMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.TransferPaymentChannelMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.TransferPaymentChannelMsg} TransferPaymentChannelMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferPaymentChannelMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransferPaymentChannelMsg message.
         * @function verify
         * @memberof paychan.TransferPaymentChannelMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferPaymentChannelMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.payment != null && message.hasOwnProperty("payment")) {
                var error = $root.paychan.Payment.verify(message.payment);
                if (error)
                    return "payment." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                var error = $root.crypto.Signature.verify(message.signature);
                if (error)
                    return "signature." + error;
            }
            return null;
        };

        /**
         * Creates a TransferPaymentChannelMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.TransferPaymentChannelMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.TransferPaymentChannelMsg} TransferPaymentChannelMsg
         */
        TransferPaymentChannelMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.TransferPaymentChannelMsg)
                return object;
            var message = new $root.paychan.TransferPaymentChannelMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".paychan.TransferPaymentChannelMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.payment != null) {
                if (typeof object.payment !== "object")
                    throw TypeError(".paychan.TransferPaymentChannelMsg.payment: object expected");
                message.payment = $root.paychan.Payment.fromObject(object.payment);
            }
            if (object.signature != null) {
                if (typeof object.signature !== "object")
                    throw TypeError(".paychan.TransferPaymentChannelMsg.signature: object expected");
                message.signature = $root.crypto.Signature.fromObject(object.signature);
            }
            return message;
        };

        /**
         * Creates a plain object from a TransferPaymentChannelMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.TransferPaymentChannelMsg
         * @static
         * @param {paychan.TransferPaymentChannelMsg} message TransferPaymentChannelMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferPaymentChannelMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.payment = null;
                object.signature = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.payment != null && message.hasOwnProperty("payment"))
                object.payment = $root.paychan.Payment.toObject(message.payment, options);
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = $root.crypto.Signature.toObject(message.signature, options);
            return object;
        };

        /**
         * Converts this TransferPaymentChannelMsg to JSON.
         * @function toJSON
         * @memberof paychan.TransferPaymentChannelMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferPaymentChannelMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransferPaymentChannelMsg;
    })();

    paychan.ClosePaymentChannelMsg = (function() {

        /**
         * Properties of a ClosePaymentChannelMsg.
         * @memberof paychan
         * @interface IClosePaymentChannelMsg
         * @property {weave.IMetadata|null} [metadata] ClosePaymentChannelMsg metadata
         * @property {Uint8Array|null} [channelId] ClosePaymentChannelMsg channelId
         * @property {string|null} [memo] Max length 128 character.
         */

        /**
         * Constructs a new ClosePaymentChannelMsg.
         * @memberof paychan
         * @classdesc Sender can close channel only if the timeout was reached.
         * @implements IClosePaymentChannelMsg
         * @constructor
         * @param {paychan.IClosePaymentChannelMsg=} [properties] Properties to set
         */
        function ClosePaymentChannelMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClosePaymentChannelMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof paychan.ClosePaymentChannelMsg
         * @instance
         */
        ClosePaymentChannelMsg.prototype.metadata = null;

        /**
         * ClosePaymentChannelMsg channelId.
         * @member {Uint8Array} channelId
         * @memberof paychan.ClosePaymentChannelMsg
         * @instance
         */
        ClosePaymentChannelMsg.prototype.channelId = $util.newBuffer([]);

        /**
         * Max length 128 character.
         * @member {string} memo
         * @memberof paychan.ClosePaymentChannelMsg
         * @instance
         */
        ClosePaymentChannelMsg.prototype.memo = "";

        /**
         * Creates a new ClosePaymentChannelMsg instance using the specified properties.
         * @function create
         * @memberof paychan.ClosePaymentChannelMsg
         * @static
         * @param {paychan.IClosePaymentChannelMsg=} [properties] Properties to set
         * @returns {paychan.ClosePaymentChannelMsg} ClosePaymentChannelMsg instance
         */
        ClosePaymentChannelMsg.create = function create(properties) {
            return new ClosePaymentChannelMsg(properties);
        };

        /**
         * Encodes the specified ClosePaymentChannelMsg message. Does not implicitly {@link paychan.ClosePaymentChannelMsg.verify|verify} messages.
         * @function encode
         * @memberof paychan.ClosePaymentChannelMsg
         * @static
         * @param {paychan.IClosePaymentChannelMsg} message ClosePaymentChannelMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosePaymentChannelMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.channelId);
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.memo);
            return writer;
        };

        /**
         * Encodes the specified ClosePaymentChannelMsg message, length delimited. Does not implicitly {@link paychan.ClosePaymentChannelMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof paychan.ClosePaymentChannelMsg
         * @static
         * @param {paychan.IClosePaymentChannelMsg} message ClosePaymentChannelMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosePaymentChannelMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosePaymentChannelMsg message from the specified reader or buffer.
         * @function decode
         * @memberof paychan.ClosePaymentChannelMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {paychan.ClosePaymentChannelMsg} ClosePaymentChannelMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosePaymentChannelMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.paychan.ClosePaymentChannelMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.channelId = reader.bytes();
                    break;
                case 3:
                    message.memo = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosePaymentChannelMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof paychan.ClosePaymentChannelMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {paychan.ClosePaymentChannelMsg} ClosePaymentChannelMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosePaymentChannelMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosePaymentChannelMsg message.
         * @function verify
         * @memberof paychan.ClosePaymentChannelMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosePaymentChannelMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!(message.channelId && typeof message.channelId.length === "number" || $util.isString(message.channelId)))
                    return "channelId: buffer expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            return null;
        };

        /**
         * Creates a ClosePaymentChannelMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof paychan.ClosePaymentChannelMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {paychan.ClosePaymentChannelMsg} ClosePaymentChannelMsg
         */
        ClosePaymentChannelMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.paychan.ClosePaymentChannelMsg)
                return object;
            var message = new $root.paychan.ClosePaymentChannelMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".paychan.ClosePaymentChannelMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.channelId != null)
                if (typeof object.channelId === "string")
                    $util.base64.decode(object.channelId, message.channelId = $util.newBuffer($util.base64.length(object.channelId)), 0);
                else if (object.channelId.length)
                    message.channelId = object.channelId;
            if (object.memo != null)
                message.memo = String(object.memo);
            return message;
        };

        /**
         * Creates a plain object from a ClosePaymentChannelMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof paychan.ClosePaymentChannelMsg
         * @static
         * @param {paychan.ClosePaymentChannelMsg} message ClosePaymentChannelMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosePaymentChannelMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if (options.bytes === String)
                    object.channelId = "";
                else {
                    object.channelId = [];
                    if (options.bytes !== Array)
                        object.channelId = $util.newBuffer(object.channelId);
                }
                object.memo = "";
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                object.channelId = options.bytes === String ? $util.base64.encode(message.channelId, 0, message.channelId.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelId) : message.channelId;
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            return object;
        };

        /**
         * Converts this ClosePaymentChannelMsg to JSON.
         * @function toJSON
         * @memberof paychan.ClosePaymentChannelMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosePaymentChannelMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosePaymentChannelMsg;
    })();

    return paychan;
})();

$root.sigs = (function() {

    /**
     * Namespace sigs.
     * @exports sigs
     * @namespace
     */
    var sigs = {};

    sigs.UserData = (function() {

        /**
         * Properties of a UserData.
         * @memberof sigs
         * @interface IUserData
         * @property {weave.IMetadata|null} [metadata] UserData metadata
         * @property {crypto.IPublicKey|null} [pubkey] UserData pubkey
         * @property {number|Long|null} [sequence] UserData sequence
         */

        /**
         * Constructs a new UserData.
         * @memberof sigs
         * @classdesc User is the entry point you want
         * @implements IUserData
         * @constructor
         * @param {sigs.IUserData=} [properties] Properties to set
         */
        function UserData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserData metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof sigs.UserData
         * @instance
         */
        UserData.prototype.metadata = null;

        /**
         * UserData pubkey.
         * @member {crypto.IPublicKey|null|undefined} pubkey
         * @memberof sigs.UserData
         * @instance
         */
        UserData.prototype.pubkey = null;

        /**
         * UserData sequence.
         * @member {number|Long} sequence
         * @memberof sigs.UserData
         * @instance
         */
        UserData.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserData instance using the specified properties.
         * @function create
         * @memberof sigs.UserData
         * @static
         * @param {sigs.IUserData=} [properties] Properties to set
         * @returns {sigs.UserData} UserData instance
         */
        UserData.create = function create(properties) {
            return new UserData(properties);
        };

        /**
         * Encodes the specified UserData message. Does not implicitly {@link sigs.UserData.verify|verify} messages.
         * @function encode
         * @memberof sigs.UserData
         * @static
         * @param {sigs.IUserData} message UserData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                $root.crypto.PublicKey.encode(message.pubkey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sequence);
            return writer;
        };

        /**
         * Encodes the specified UserData message, length delimited. Does not implicitly {@link sigs.UserData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sigs.UserData
         * @static
         * @param {sigs.IUserData} message UserData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserData message from the specified reader or buffer.
         * @function decode
         * @memberof sigs.UserData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sigs.UserData} UserData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.sigs.UserData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pubkey = $root.crypto.PublicKey.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.sequence = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sigs.UserData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sigs.UserData} UserData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserData message.
         * @function verify
         * @memberof sigs.UserData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.pubkey != null && message.hasOwnProperty("pubkey")) {
                var error = $root.crypto.PublicKey.verify(message.pubkey);
                if (error)
                    return "pubkey." + error;
            }
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                    return "sequence: integer|Long expected";
            return null;
        };

        /**
         * Creates a UserData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sigs.UserData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sigs.UserData} UserData
         */
        UserData.fromObject = function fromObject(object) {
            if (object instanceof $root.sigs.UserData)
                return object;
            var message = new $root.sigs.UserData();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".sigs.UserData.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.pubkey != null) {
                if (typeof object.pubkey !== "object")
                    throw TypeError(".sigs.UserData.pubkey: object expected");
                message.pubkey = $root.crypto.PublicKey.fromObject(object.pubkey);
            }
            if (object.sequence != null)
                if ($util.Long)
                    (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                else if (typeof object.sequence === "string")
                    message.sequence = parseInt(object.sequence, 10);
                else if (typeof object.sequence === "number")
                    message.sequence = object.sequence;
                else if (typeof object.sequence === "object")
                    message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a UserData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sigs.UserData
         * @static
         * @param {sigs.UserData} message UserData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.pubkey = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequence = options.longs === String ? "0" : 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = $root.crypto.PublicKey.toObject(message.pubkey, options);
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (typeof message.sequence === "number")
                    object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                else
                    object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
            return object;
        };

        /**
         * Converts this UserData to JSON.
         * @function toJSON
         * @memberof sigs.UserData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserData;
    })();

    sigs.StdSignature = (function() {

        /**
         * Properties of a StdSignature.
         * @memberof sigs
         * @interface IStdSignature
         * @property {weave.IMetadata|null} [metadata] StdSignature metadata
         * @property {number|Long|null} [sequence] StdSignature sequence
         * @property {crypto.IPublicKey|null} [pubkey] StdSignature pubkey
         * @property {crypto.ISignature|null} [signature] Removed Address, Pubkey is more powerful
         */

        /**
         * Constructs a new StdSignature.
         * @memberof sigs
         * @classdesc increasing by 1 each time (starting at 0)
         * @implements IStdSignature
         * @constructor
         * @param {sigs.IStdSignature=} [properties] Properties to set
         */
        function StdSignature(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StdSignature metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof sigs.StdSignature
         * @instance
         */
        StdSignature.prototype.metadata = null;

        /**
         * StdSignature sequence.
         * @member {number|Long} sequence
         * @memberof sigs.StdSignature
         * @instance
         */
        StdSignature.prototype.sequence = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * StdSignature pubkey.
         * @member {crypto.IPublicKey|null|undefined} pubkey
         * @memberof sigs.StdSignature
         * @instance
         */
        StdSignature.prototype.pubkey = null;

        /**
         * Removed Address, Pubkey is more powerful
         * @member {crypto.ISignature|null|undefined} signature
         * @memberof sigs.StdSignature
         * @instance
         */
        StdSignature.prototype.signature = null;

        /**
         * Creates a new StdSignature instance using the specified properties.
         * @function create
         * @memberof sigs.StdSignature
         * @static
         * @param {sigs.IStdSignature=} [properties] Properties to set
         * @returns {sigs.StdSignature} StdSignature instance
         */
        StdSignature.create = function create(properties) {
            return new StdSignature(properties);
        };

        /**
         * Encodes the specified StdSignature message. Does not implicitly {@link sigs.StdSignature.verify|verify} messages.
         * @function encode
         * @memberof sigs.StdSignature
         * @static
         * @param {sigs.IStdSignature} message StdSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StdSignature.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.sequence);
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                $root.crypto.PublicKey.encode(message.pubkey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.signature != null && message.hasOwnProperty("signature"))
                $root.crypto.Signature.encode(message.signature, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StdSignature message, length delimited. Does not implicitly {@link sigs.StdSignature.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sigs.StdSignature
         * @static
         * @param {sigs.IStdSignature} message StdSignature message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StdSignature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StdSignature message from the specified reader or buffer.
         * @function decode
         * @memberof sigs.StdSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sigs.StdSignature} StdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StdSignature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.sigs.StdSignature();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.sequence = reader.int64();
                    break;
                case 3:
                    message.pubkey = $root.crypto.PublicKey.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signature = $root.crypto.Signature.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StdSignature message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sigs.StdSignature
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sigs.StdSignature} StdSignature
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StdSignature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StdSignature message.
         * @function verify
         * @memberof sigs.StdSignature
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StdSignature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (!$util.isInteger(message.sequence) && !(message.sequence && $util.isInteger(message.sequence.low) && $util.isInteger(message.sequence.high)))
                    return "sequence: integer|Long expected";
            if (message.pubkey != null && message.hasOwnProperty("pubkey")) {
                var error = $root.crypto.PublicKey.verify(message.pubkey);
                if (error)
                    return "pubkey." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                var error = $root.crypto.Signature.verify(message.signature);
                if (error)
                    return "signature." + error;
            }
            return null;
        };

        /**
         * Creates a StdSignature message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sigs.StdSignature
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sigs.StdSignature} StdSignature
         */
        StdSignature.fromObject = function fromObject(object) {
            if (object instanceof $root.sigs.StdSignature)
                return object;
            var message = new $root.sigs.StdSignature();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".sigs.StdSignature.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.sequence != null)
                if ($util.Long)
                    (message.sequence = $util.Long.fromValue(object.sequence)).unsigned = false;
                else if (typeof object.sequence === "string")
                    message.sequence = parseInt(object.sequence, 10);
                else if (typeof object.sequence === "number")
                    message.sequence = object.sequence;
                else if (typeof object.sequence === "object")
                    message.sequence = new $util.LongBits(object.sequence.low >>> 0, object.sequence.high >>> 0).toNumber();
            if (object.pubkey != null) {
                if (typeof object.pubkey !== "object")
                    throw TypeError(".sigs.StdSignature.pubkey: object expected");
                message.pubkey = $root.crypto.PublicKey.fromObject(object.pubkey);
            }
            if (object.signature != null) {
                if (typeof object.signature !== "object")
                    throw TypeError(".sigs.StdSignature.signature: object expected");
                message.signature = $root.crypto.Signature.fromObject(object.signature);
            }
            return message;
        };

        /**
         * Creates a plain object from a StdSignature message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sigs.StdSignature
         * @static
         * @param {sigs.StdSignature} message StdSignature
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StdSignature.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.sequence = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.sequence = options.longs === String ? "0" : 0;
                object.pubkey = null;
                object.signature = null;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.sequence != null && message.hasOwnProperty("sequence"))
                if (typeof message.sequence === "number")
                    object.sequence = options.longs === String ? String(message.sequence) : message.sequence;
                else
                    object.sequence = options.longs === String ? $util.Long.prototype.toString.call(message.sequence) : options.longs === Number ? new $util.LongBits(message.sequence.low >>> 0, message.sequence.high >>> 0).toNumber() : message.sequence;
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = $root.crypto.PublicKey.toObject(message.pubkey, options);
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = $root.crypto.Signature.toObject(message.signature, options);
            return object;
        };

        /**
         * Converts this StdSignature to JSON.
         * @function toJSON
         * @memberof sigs.StdSignature
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StdSignature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StdSignature;
    })();

    sigs.BumpSequenceMsg = (function() {

        /**
         * Properties of a BumpSequenceMsg.
         * @memberof sigs
         * @interface IBumpSequenceMsg
         * @property {weave.IMetadata|null} [metadata] BumpSequenceMsg metadata
         * @property {number|null} [increment] total increment value, including the default increment.
         */

        /**
         * Constructs a new BumpSequenceMsg.
         * @memberof sigs
         * @classdesc that signed the transaction.
         * @implements IBumpSequenceMsg
         * @constructor
         * @param {sigs.IBumpSequenceMsg=} [properties] Properties to set
         */
        function BumpSequenceMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BumpSequenceMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof sigs.BumpSequenceMsg
         * @instance
         */
        BumpSequenceMsg.prototype.metadata = null;

        /**
         * total increment value, including the default increment.
         * @member {number} increment
         * @memberof sigs.BumpSequenceMsg
         * @instance
         */
        BumpSequenceMsg.prototype.increment = 0;

        /**
         * Creates a new BumpSequenceMsg instance using the specified properties.
         * @function create
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {sigs.IBumpSequenceMsg=} [properties] Properties to set
         * @returns {sigs.BumpSequenceMsg} BumpSequenceMsg instance
         */
        BumpSequenceMsg.create = function create(properties) {
            return new BumpSequenceMsg(properties);
        };

        /**
         * Encodes the specified BumpSequenceMsg message. Does not implicitly {@link sigs.BumpSequenceMsg.verify|verify} messages.
         * @function encode
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {sigs.IBumpSequenceMsg} message BumpSequenceMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BumpSequenceMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.increment != null && message.hasOwnProperty("increment"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.increment);
            return writer;
        };

        /**
         * Encodes the specified BumpSequenceMsg message, length delimited. Does not implicitly {@link sigs.BumpSequenceMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {sigs.IBumpSequenceMsg} message BumpSequenceMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BumpSequenceMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BumpSequenceMsg message from the specified reader or buffer.
         * @function decode
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {sigs.BumpSequenceMsg} BumpSequenceMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BumpSequenceMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.sigs.BumpSequenceMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.increment = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BumpSequenceMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {sigs.BumpSequenceMsg} BumpSequenceMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BumpSequenceMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BumpSequenceMsg message.
         * @function verify
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BumpSequenceMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.increment != null && message.hasOwnProperty("increment"))
                if (!$util.isInteger(message.increment))
                    return "increment: integer expected";
            return null;
        };

        /**
         * Creates a BumpSequenceMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {sigs.BumpSequenceMsg} BumpSequenceMsg
         */
        BumpSequenceMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.sigs.BumpSequenceMsg)
                return object;
            var message = new $root.sigs.BumpSequenceMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".sigs.BumpSequenceMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.increment != null)
                message.increment = object.increment >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a BumpSequenceMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof sigs.BumpSequenceMsg
         * @static
         * @param {sigs.BumpSequenceMsg} message BumpSequenceMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BumpSequenceMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.metadata = null;
                object.increment = 0;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.increment != null && message.hasOwnProperty("increment"))
                object.increment = message.increment;
            return object;
        };

        /**
         * Converts this BumpSequenceMsg to JSON.
         * @function toJSON
         * @memberof sigs.BumpSequenceMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BumpSequenceMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BumpSequenceMsg;
    })();

    return sigs;
})();

$root.validators = (function() {

    /**
     * Namespace validators.
     * @exports validators
     * @namespace
     */
    var validators = {};

    validators.ValidatorUpdate = (function() {

        /**
         * Properties of a ValidatorUpdate.
         * @memberof validators
         * @interface IValidatorUpdate
         * @property {validators.IPubkey|null} [pubkey] ValidatorUpdate pubkey
         * @property {number|Long|null} [power] ValidatorUpdate power
         */

        /**
         * Constructs a new ValidatorUpdate.
         * @memberof validators
         * @classdesc ValidatorUpdate
         * @implements IValidatorUpdate
         * @constructor
         * @param {validators.IValidatorUpdate=} [properties] Properties to set
         */
        function ValidatorUpdate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidatorUpdate pubkey.
         * @member {validators.IPubkey|null|undefined} pubkey
         * @memberof validators.ValidatorUpdate
         * @instance
         */
        ValidatorUpdate.prototype.pubkey = null;

        /**
         * ValidatorUpdate power.
         * @member {number|Long} power
         * @memberof validators.ValidatorUpdate
         * @instance
         */
        ValidatorUpdate.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ValidatorUpdate instance using the specified properties.
         * @function create
         * @memberof validators.ValidatorUpdate
         * @static
         * @param {validators.IValidatorUpdate=} [properties] Properties to set
         * @returns {validators.ValidatorUpdate} ValidatorUpdate instance
         */
        ValidatorUpdate.create = function create(properties) {
            return new ValidatorUpdate(properties);
        };

        /**
         * Encodes the specified ValidatorUpdate message. Does not implicitly {@link validators.ValidatorUpdate.verify|verify} messages.
         * @function encode
         * @memberof validators.ValidatorUpdate
         * @static
         * @param {validators.IValidatorUpdate} message ValidatorUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                $root.validators.Pubkey.encode(message.pubkey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.power != null && message.hasOwnProperty("power"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.power);
            return writer;
        };

        /**
         * Encodes the specified ValidatorUpdate message, length delimited. Does not implicitly {@link validators.ValidatorUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof validators.ValidatorUpdate
         * @static
         * @param {validators.IValidatorUpdate} message ValidatorUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidatorUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidatorUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof validators.ValidatorUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {validators.ValidatorUpdate} ValidatorUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.validators.ValidatorUpdate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubkey = $root.validators.Pubkey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.power = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidatorUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof validators.ValidatorUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {validators.ValidatorUpdate} ValidatorUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidatorUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidatorUpdate message.
         * @function verify
         * @memberof validators.ValidatorUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidatorUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubkey != null && message.hasOwnProperty("pubkey")) {
                var error = $root.validators.Pubkey.verify(message.pubkey);
                if (error)
                    return "pubkey." + error;
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            return null;
        };

        /**
         * Creates a ValidatorUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validators.ValidatorUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validators.ValidatorUpdate} ValidatorUpdate
         */
        ValidatorUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.validators.ValidatorUpdate)
                return object;
            var message = new $root.validators.ValidatorUpdate();
            if (object.pubkey != null) {
                if (typeof object.pubkey !== "object")
                    throw TypeError(".validators.ValidatorUpdate.pubkey: object expected");
                message.pubkey = $root.validators.Pubkey.fromObject(object.pubkey);
            }
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ValidatorUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validators.ValidatorUpdate
         * @static
         * @param {validators.ValidatorUpdate} message ValidatorUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidatorUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pubkey = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
            }
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = $root.validators.Pubkey.toObject(message.pubkey, options);
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            return object;
        };

        /**
         * Converts this ValidatorUpdate to JSON.
         * @function toJSON
         * @memberof validators.ValidatorUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidatorUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidatorUpdate;
    })();

    validators.Pubkey = (function() {

        /**
         * Properties of a Pubkey.
         * @memberof validators
         * @interface IPubkey
         * @property {string|null} [type] Pubkey type
         * @property {Uint8Array|null} [data] Pubkey data
         */

        /**
         * Constructs a new Pubkey.
         * @memberof validators
         * @classdesc Represents a Pubkey.
         * @implements IPubkey
         * @constructor
         * @param {validators.IPubkey=} [properties] Properties to set
         */
        function Pubkey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Pubkey type.
         * @member {string} type
         * @memberof validators.Pubkey
         * @instance
         */
        Pubkey.prototype.type = "";

        /**
         * Pubkey data.
         * @member {Uint8Array} data
         * @memberof validators.Pubkey
         * @instance
         */
        Pubkey.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new Pubkey instance using the specified properties.
         * @function create
         * @memberof validators.Pubkey
         * @static
         * @param {validators.IPubkey=} [properties] Properties to set
         * @returns {validators.Pubkey} Pubkey instance
         */
        Pubkey.create = function create(properties) {
            return new Pubkey(properties);
        };

        /**
         * Encodes the specified Pubkey message. Does not implicitly {@link validators.Pubkey.verify|verify} messages.
         * @function encode
         * @memberof validators.Pubkey
         * @static
         * @param {validators.IPubkey} message Pubkey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pubkey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified Pubkey message, length delimited. Does not implicitly {@link validators.Pubkey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof validators.Pubkey
         * @static
         * @param {validators.IPubkey} message Pubkey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pubkey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Pubkey message from the specified reader or buffer.
         * @function decode
         * @memberof validators.Pubkey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {validators.Pubkey} Pubkey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pubkey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.validators.Pubkey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Pubkey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof validators.Pubkey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {validators.Pubkey} Pubkey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pubkey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Pubkey message.
         * @function verify
         * @memberof validators.Pubkey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Pubkey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a Pubkey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validators.Pubkey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validators.Pubkey} Pubkey
         */
        Pubkey.fromObject = function fromObject(object) {
            if (object instanceof $root.validators.Pubkey)
                return object;
            var message = new $root.validators.Pubkey();
            if (object.type != null)
                message.type = String(object.type);
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a Pubkey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validators.Pubkey
         * @static
         * @param {validators.Pubkey} message Pubkey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Pubkey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = "";
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this Pubkey to JSON.
         * @function toJSON
         * @memberof validators.Pubkey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Pubkey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Pubkey;
    })();

    validators.SetValidatorsMsg = (function() {

        /**
         * Properties of a SetValidatorsMsg.
         * @memberof validators
         * @interface ISetValidatorsMsg
         * @property {weave.IMetadata|null} [metadata] SetValidatorsMsg metadata
         * @property {Array.<validators.IValidatorUpdate>|null} [validatorUpdates] SetValidatorsMsg validatorUpdates
         */

        /**
         * Constructs a new SetValidatorsMsg.
         * @memberof validators
         * @classdesc This message is designed to update validator power
         * @implements ISetValidatorsMsg
         * @constructor
         * @param {validators.ISetValidatorsMsg=} [properties] Properties to set
         */
        function SetValidatorsMsg(properties) {
            this.validatorUpdates = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetValidatorsMsg metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof validators.SetValidatorsMsg
         * @instance
         */
        SetValidatorsMsg.prototype.metadata = null;

        /**
         * SetValidatorsMsg validatorUpdates.
         * @member {Array.<validators.IValidatorUpdate>} validatorUpdates
         * @memberof validators.SetValidatorsMsg
         * @instance
         */
        SetValidatorsMsg.prototype.validatorUpdates = $util.emptyArray;

        /**
         * Creates a new SetValidatorsMsg instance using the specified properties.
         * @function create
         * @memberof validators.SetValidatorsMsg
         * @static
         * @param {validators.ISetValidatorsMsg=} [properties] Properties to set
         * @returns {validators.SetValidatorsMsg} SetValidatorsMsg instance
         */
        SetValidatorsMsg.create = function create(properties) {
            return new SetValidatorsMsg(properties);
        };

        /**
         * Encodes the specified SetValidatorsMsg message. Does not implicitly {@link validators.SetValidatorsMsg.verify|verify} messages.
         * @function encode
         * @memberof validators.SetValidatorsMsg
         * @static
         * @param {validators.ISetValidatorsMsg} message SetValidatorsMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetValidatorsMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.validatorUpdates != null && message.validatorUpdates.length)
                for (var i = 0; i < message.validatorUpdates.length; ++i)
                    $root.validators.ValidatorUpdate.encode(message.validatorUpdates[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetValidatorsMsg message, length delimited. Does not implicitly {@link validators.SetValidatorsMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof validators.SetValidatorsMsg
         * @static
         * @param {validators.ISetValidatorsMsg} message SetValidatorsMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetValidatorsMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetValidatorsMsg message from the specified reader or buffer.
         * @function decode
         * @memberof validators.SetValidatorsMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {validators.SetValidatorsMsg} SetValidatorsMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetValidatorsMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.validators.SetValidatorsMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.validatorUpdates && message.validatorUpdates.length))
                        message.validatorUpdates = [];
                    message.validatorUpdates.push($root.validators.ValidatorUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetValidatorsMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof validators.SetValidatorsMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {validators.SetValidatorsMsg} SetValidatorsMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetValidatorsMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetValidatorsMsg message.
         * @function verify
         * @memberof validators.SetValidatorsMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetValidatorsMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.validatorUpdates != null && message.hasOwnProperty("validatorUpdates")) {
                if (!Array.isArray(message.validatorUpdates))
                    return "validatorUpdates: array expected";
                for (var i = 0; i < message.validatorUpdates.length; ++i) {
                    var error = $root.validators.ValidatorUpdate.verify(message.validatorUpdates[i]);
                    if (error)
                        return "validatorUpdates." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SetValidatorsMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validators.SetValidatorsMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validators.SetValidatorsMsg} SetValidatorsMsg
         */
        SetValidatorsMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.validators.SetValidatorsMsg)
                return object;
            var message = new $root.validators.SetValidatorsMsg();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".validators.SetValidatorsMsg.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.validatorUpdates) {
                if (!Array.isArray(object.validatorUpdates))
                    throw TypeError(".validators.SetValidatorsMsg.validatorUpdates: array expected");
                message.validatorUpdates = [];
                for (var i = 0; i < object.validatorUpdates.length; ++i) {
                    if (typeof object.validatorUpdates[i] !== "object")
                        throw TypeError(".validators.SetValidatorsMsg.validatorUpdates: object expected");
                    message.validatorUpdates[i] = $root.validators.ValidatorUpdate.fromObject(object.validatorUpdates[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SetValidatorsMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validators.SetValidatorsMsg
         * @static
         * @param {validators.SetValidatorsMsg} message SetValidatorsMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetValidatorsMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.validatorUpdates = [];
            if (options.defaults)
                object.metadata = null;
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.validatorUpdates && message.validatorUpdates.length) {
                object.validatorUpdates = [];
                for (var j = 0; j < message.validatorUpdates.length; ++j)
                    object.validatorUpdates[j] = $root.validators.ValidatorUpdate.toObject(message.validatorUpdates[j], options);
            }
            return object;
        };

        /**
         * Converts this SetValidatorsMsg to JSON.
         * @function toJSON
         * @memberof validators.SetValidatorsMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetValidatorsMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetValidatorsMsg;
    })();

    validators.Accounts = (function() {

        /**
         * Properties of an Accounts.
         * @memberof validators
         * @interface IAccounts
         * @property {weave.IMetadata|null} [metadata] Accounts metadata
         * @property {Array.<Uint8Array>|null} [addresses] Accounts addresses
         */

        /**
         * Constructs a new Accounts.
         * @memberof validators
         * @classdesc Accounts is a list of accounts allowed to update validators
         * @implements IAccounts
         * @constructor
         * @param {validators.IAccounts=} [properties] Properties to set
         */
        function Accounts(properties) {
            this.addresses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Accounts metadata.
         * @member {weave.IMetadata|null|undefined} metadata
         * @memberof validators.Accounts
         * @instance
         */
        Accounts.prototype.metadata = null;

        /**
         * Accounts addresses.
         * @member {Array.<Uint8Array>} addresses
         * @memberof validators.Accounts
         * @instance
         */
        Accounts.prototype.addresses = $util.emptyArray;

        /**
         * Creates a new Accounts instance using the specified properties.
         * @function create
         * @memberof validators.Accounts
         * @static
         * @param {validators.IAccounts=} [properties] Properties to set
         * @returns {validators.Accounts} Accounts instance
         */
        Accounts.create = function create(properties) {
            return new Accounts(properties);
        };

        /**
         * Encodes the specified Accounts message. Does not implicitly {@link validators.Accounts.verify|verify} messages.
         * @function encode
         * @memberof validators.Accounts
         * @static
         * @param {validators.IAccounts} message Accounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Accounts.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.weave.Metadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.addresses != null && message.addresses.length)
                for (var i = 0; i < message.addresses.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.addresses[i]);
            return writer;
        };

        /**
         * Encodes the specified Accounts message, length delimited. Does not implicitly {@link validators.Accounts.verify|verify} messages.
         * @function encodeDelimited
         * @memberof validators.Accounts
         * @static
         * @param {validators.IAccounts} message Accounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Accounts.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Accounts message from the specified reader or buffer.
         * @function decode
         * @memberof validators.Accounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {validators.Accounts} Accounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Accounts.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.validators.Accounts();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.metadata = $root.weave.Metadata.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.addresses && message.addresses.length))
                        message.addresses = [];
                    message.addresses.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Accounts message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof validators.Accounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {validators.Accounts} Accounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Accounts.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Accounts message.
         * @function verify
         * @memberof validators.Accounts
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Accounts.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                var error = $root.weave.Metadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            if (message.addresses != null && message.hasOwnProperty("addresses")) {
                if (!Array.isArray(message.addresses))
                    return "addresses: array expected";
                for (var i = 0; i < message.addresses.length; ++i)
                    if (!(message.addresses[i] && typeof message.addresses[i].length === "number" || $util.isString(message.addresses[i])))
                        return "addresses: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an Accounts message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validators.Accounts
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validators.Accounts} Accounts
         */
        Accounts.fromObject = function fromObject(object) {
            if (object instanceof $root.validators.Accounts)
                return object;
            var message = new $root.validators.Accounts();
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".validators.Accounts.metadata: object expected");
                message.metadata = $root.weave.Metadata.fromObject(object.metadata);
            }
            if (object.addresses) {
                if (!Array.isArray(object.addresses))
                    throw TypeError(".validators.Accounts.addresses: array expected");
                message.addresses = [];
                for (var i = 0; i < object.addresses.length; ++i)
                    if (typeof object.addresses[i] === "string")
                        $util.base64.decode(object.addresses[i], message.addresses[i] = $util.newBuffer($util.base64.length(object.addresses[i])), 0);
                    else if (object.addresses[i].length)
                        message.addresses[i] = object.addresses[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an Accounts message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validators.Accounts
         * @static
         * @param {validators.Accounts} message Accounts
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Accounts.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.addresses = [];
            if (options.defaults)
                object.metadata = null;
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.weave.Metadata.toObject(message.metadata, options);
            if (message.addresses && message.addresses.length) {
                object.addresses = [];
                for (var j = 0; j < message.addresses.length; ++j)
                    object.addresses[j] = options.bytes === String ? $util.base64.encode(message.addresses[j], 0, message.addresses[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.addresses[j]) : message.addresses[j];
            }
            return object;
        };

        /**
         * Converts this Accounts to JSON.
         * @function toJSON
         * @memberof validators.Accounts
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Accounts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Accounts;
    })();

    return validators;
})();

module.exports = $root;
